// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: grpc/gcp/handshaker.proto

package io.grpc.alts.internal;

/**
 * Protobuf type {@code grpc.gcp.StartClientHandshakeReq}
 */
public  final class StartClientHandshakeReq extends
    com.google.protobuf.GeneratedMessageV3 implements
    // @@protoc_insertion_point(message_implements:grpc.gcp.StartClientHandshakeReq)
    StartClientHandshakeReqOrBuilder {
private static final long serialVersionUID = 0L;
  // Use StartClientHandshakeReq.newBuilder() to construct.
  private StartClientHandshakeReq(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
    super(builder);
  }
  private StartClientHandshakeReq() {
    handshakeSecurityProtocol_ = 0;
    applicationProtocols_ = com.google.protobuf.LazyStringArrayList.EMPTY;
    recordProtocols_ = com.google.protobuf.LazyStringArrayList.EMPTY;
    targetIdentities_ = java.util.Collections.emptyList();
    targetName_ = "";
  }

  @java.lang.Override
  public final com.google.protobuf.UnknownFieldSet
  getUnknownFields() {
    return this.unknownFields;
  }
  private StartClientHandshakeReq(
      com.google.protobuf.CodedInputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    this();
    if (extensionRegistry == null) {
      throw new java.lang.NullPointerException();
    }
    int mutable_bitField0_ = 0;
    com.google.protobuf.UnknownFieldSet.Builder unknownFields =
        com.google.protobuf.UnknownFieldSet.newBuilder();
    try {
      boolean done = false;
      while (!done) {
        int tag = input.readTag();
        switch (tag) {
          case 0:
            done = true;
            break;
          case 8: {
            int rawValue = input.readEnum();

            handshakeSecurityProtocol_ = rawValue;
            break;
          }
          case 18: {
            java.lang.String s = input.readStringRequireUtf8();
            if (!((mutable_bitField0_ & 0x00000002) == 0x00000002)) {
              applicationProtocols_ = new com.google.protobuf.LazyStringArrayList();
              mutable_bitField0_ |= 0x00000002;
            }
            applicationProtocols_.add(s);
            break;
          }
          case 26: {
            java.lang.String s = input.readStringRequireUtf8();
            if (!((mutable_bitField0_ & 0x00000004) == 0x00000004)) {
              recordProtocols_ = new com.google.protobuf.LazyStringArrayList();
              mutable_bitField0_ |= 0x00000004;
            }
            recordProtocols_.add(s);
            break;
          }
          case 34: {
            if (!((mutable_bitField0_ & 0x00000008) == 0x00000008)) {
              targetIdentities_ = new java.util.ArrayList<io.grpc.alts.internal.Identity>();
              mutable_bitField0_ |= 0x00000008;
            }
            targetIdentities_.add(
                input.readMessage(io.grpc.alts.internal.Identity.parser(), extensionRegistry));
            break;
          }
          case 42: {
            io.grpc.alts.internal.Identity.Builder subBuilder = null;
            if (localIdentity_ != null) {
              subBuilder = localIdentity_.toBuilder();
            }
            localIdentity_ = input.readMessage(io.grpc.alts.internal.Identity.parser(), extensionRegistry);
            if (subBuilder != null) {
              subBuilder.mergeFrom(localIdentity_);
              localIdentity_ = subBuilder.buildPartial();
            }

            break;
          }
          case 50: {
            io.grpc.alts.internal.Endpoint.Builder subBuilder = null;
            if (localEndpoint_ != null) {
              subBuilder = localEndpoint_.toBuilder();
            }
            localEndpoint_ = input.readMessage(io.grpc.alts.internal.Endpoint.parser(), extensionRegistry);
            if (subBuilder != null) {
              subBuilder.mergeFrom(localEndpoint_);
              localEndpoint_ = subBuilder.buildPartial();
            }

            break;
          }
          case 58: {
            io.grpc.alts.internal.Endpoint.Builder subBuilder = null;
            if (remoteEndpoint_ != null) {
              subBuilder = remoteEndpoint_.toBuilder();
            }
            remoteEndpoint_ = input.readMessage(io.grpc.alts.internal.Endpoint.parser(), extensionRegistry);
            if (subBuilder != null) {
              subBuilder.mergeFrom(remoteEndpoint_);
              remoteEndpoint_ = subBuilder.buildPartial();
            }

            break;
          }
          case 66: {
            java.lang.String s = input.readStringRequireUtf8();

            targetName_ = s;
            break;
          }
          case 74: {
            io.grpc.alts.internal.RpcProtocolVersions.Builder subBuilder = null;
            if (rpcVersions_ != null) {
              subBuilder = rpcVersions_.toBuilder();
            }
            rpcVersions_ = input.readMessage(io.grpc.alts.internal.RpcProtocolVersions.parser(), extensionRegistry);
            if (subBuilder != null) {
              subBuilder.mergeFrom(rpcVersions_);
              rpcVersions_ = subBuilder.buildPartial();
            }

            break;
          }
          default: {
            if (!parseUnknownFieldProto3(
                input, unknownFields, extensionRegistry, tag)) {
              done = true;
            }
            break;
          }
        }
      }
    } catch (com.google.protobuf.InvalidProtocolBufferException e) {
      throw e.setUnfinishedMessage(this);
    } catch (java.io.IOException e) {
      throw new com.google.protobuf.InvalidProtocolBufferException(
          e).setUnfinishedMessage(this);
    } finally {
      if (((mutable_bitField0_ & 0x00000002) == 0x00000002)) {
        applicationProtocols_ = applicationProtocols_.getUnmodifiableView();
      }
      if (((mutable_bitField0_ & 0x00000004) == 0x00000004)) {
        recordProtocols_ = recordProtocols_.getUnmodifiableView();
      }
      if (((mutable_bitField0_ & 0x00000008) == 0x00000008)) {
        targetIdentities_ = java.util.Collections.unmodifiableList(targetIdentities_);
      }
      this.unknownFields = unknownFields.build();
      makeExtensionsImmutable();
    }
  }
  public static final com.google.protobuf.Descriptors.Descriptor
      getDescriptor() {
    return io.grpc.alts.internal.HandshakerProto.internal_static_grpc_gcp_StartClientHandshakeReq_descriptor;
  }

  @java.lang.Override
  protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internalGetFieldAccessorTable() {
    return io.grpc.alts.internal.HandshakerProto.internal_static_grpc_gcp_StartClientHandshakeReq_fieldAccessorTable
        .ensureFieldAccessorsInitialized(
            io.grpc.alts.internal.StartClientHandshakeReq.class, io.grpc.alts.internal.StartClientHandshakeReq.Builder.class);
  }

  private int bitField0_;
  public static final int HANDSHAKE_SECURITY_PROTOCOL_FIELD_NUMBER = 1;
  private int handshakeSecurityProtocol_;
  /**
   * <pre>
   * Handshake security protocol requested by the client.
   * </pre>
   *
   * <code>.grpc.gcp.HandshakeProtocol handshake_security_protocol = 1;</code>
   */
  public int getHandshakeSecurityProtocolValue() {
    return handshakeSecurityProtocol_;
  }
  /**
   * <pre>
   * Handshake security protocol requested by the client.
   * </pre>
   *
   * <code>.grpc.gcp.HandshakeProtocol handshake_security_protocol = 1;</code>
   */
  public io.grpc.alts.internal.HandshakeProtocol getHandshakeSecurityProtocol() {
    @SuppressWarnings("deprecation")
    io.grpc.alts.internal.HandshakeProtocol result = io.grpc.alts.internal.HandshakeProtocol.valueOf(handshakeSecurityProtocol_);
    return result == null ? io.grpc.alts.internal.HandshakeProtocol.UNRECOGNIZED : result;
  }

  public static final int APPLICATION_PROTOCOLS_FIELD_NUMBER = 2;
  private com.google.protobuf.LazyStringList applicationProtocols_;
  /**
   * <pre>
   * The application protocols supported by the client, e.g., "h2" (for http2),
   * "grpc".
   * </pre>
   *
   * <code>repeated string application_protocols = 2;</code>
   */
  public com.google.protobuf.ProtocolStringList
      getApplicationProtocolsList() {
    return applicationProtocols_;
  }
  /**
   * <pre>
   * The application protocols supported by the client, e.g., "h2" (for http2),
   * "grpc".
   * </pre>
   *
   * <code>repeated string application_protocols = 2;</code>
   */
  public int getApplicationProtocolsCount() {
    return applicationProtocols_.size();
  }
  /**
   * <pre>
   * The application protocols supported by the client, e.g., "h2" (for http2),
   * "grpc".
   * </pre>
   *
   * <code>repeated string application_protocols = 2;</code>
   */
  public java.lang.String getApplicationProtocols(int index) {
    return applicationProtocols_.get(index);
  }
  /**
   * <pre>
   * The application protocols supported by the client, e.g., "h2" (for http2),
   * "grpc".
   * </pre>
   *
   * <code>repeated string application_protocols = 2;</code>
   */
  public com.google.protobuf.ByteString
      getApplicationProtocolsBytes(int index) {
    return applicationProtocols_.getByteString(index);
  }

  public static final int RECORD_PROTOCOLS_FIELD_NUMBER = 3;
  private com.google.protobuf.LazyStringList recordProtocols_;
  /**
   * <pre>
   * The record protocols supported by the client, e.g.,
   * "ALTSRP_GCM_AES128".
   * </pre>
   *
   * <code>repeated string record_protocols = 3;</code>
   */
  public com.google.protobuf.ProtocolStringList
      getRecordProtocolsList() {
    return recordProtocols_;
  }
  /**
   * <pre>
   * The record protocols supported by the client, e.g.,
   * "ALTSRP_GCM_AES128".
   * </pre>
   *
   * <code>repeated string record_protocols = 3;</code>
   */
  public int getRecordProtocolsCount() {
    return recordProtocols_.size();
  }
  /**
   * <pre>
   * The record protocols supported by the client, e.g.,
   * "ALTSRP_GCM_AES128".
   * </pre>
   *
   * <code>repeated string record_protocols = 3;</code>
   */
  public java.lang.String getRecordProtocols(int index) {
    return recordProtocols_.get(index);
  }
  /**
   * <pre>
   * The record protocols supported by the client, e.g.,
   * "ALTSRP_GCM_AES128".
   * </pre>
   *
   * <code>repeated string record_protocols = 3;</code>
   */
  public com.google.protobuf.ByteString
      getRecordProtocolsBytes(int index) {
    return recordProtocols_.getByteString(index);
  }

  public static final int TARGET_IDENTITIES_FIELD_NUMBER = 4;
  private java.util.List<io.grpc.alts.internal.Identity> targetIdentities_;
  /**
   * <pre>
   * (Optional) Describes which server identities are acceptable by the client.
   * If target identities are provided and none of them matches the peer
   * identity of the server, handshake will fail.
   * </pre>
   *
   * <code>repeated .grpc.gcp.Identity target_identities = 4;</code>
   */
  public java.util.List<io.grpc.alts.internal.Identity> getTargetIdentitiesList() {
    return targetIdentities_;
  }
  /**
   * <pre>
   * (Optional) Describes which server identities are acceptable by the client.
   * If target identities are provided and none of them matches the peer
   * identity of the server, handshake will fail.
   * </pre>
   *
   * <code>repeated .grpc.gcp.Identity target_identities = 4;</code>
   */
  public java.util.List<? extends io.grpc.alts.internal.IdentityOrBuilder> 
      getTargetIdentitiesOrBuilderList() {
    return targetIdentities_;
  }
  /**
   * <pre>
   * (Optional) Describes which server identities are acceptable by the client.
   * If target identities are provided and none of them matches the peer
   * identity of the server, handshake will fail.
   * </pre>
   *
   * <code>repeated .grpc.gcp.Identity target_identities = 4;</code>
   */
  public int getTargetIdentitiesCount() {
    return targetIdentities_.size();
  }
  /**
   * <pre>
   * (Optional) Describes which server identities are acceptable by the client.
   * If target identities are provided and none of them matches the peer
   * identity of the server, handshake will fail.
   * </pre>
   *
   * <code>repeated .grpc.gcp.Identity target_identities = 4;</code>
   */
  public io.grpc.alts.internal.Identity getTargetIdentities(int index) {
    return targetIdentities_.get(index);
  }
  /**
   * <pre>
   * (Optional) Describes which server identities are acceptable by the client.
   * If target identities are provided and none of them matches the peer
   * identity of the server, handshake will fail.
   * </pre>
   *
   * <code>repeated .grpc.gcp.Identity target_identities = 4;</code>
   */
  public io.grpc.alts.internal.IdentityOrBuilder getTargetIdentitiesOrBuilder(
      int index) {
    return targetIdentities_.get(index);
  }

  public static final int LOCAL_IDENTITY_FIELD_NUMBER = 5;
  private io.grpc.alts.internal.Identity localIdentity_;
  /**
   * <pre>
   * (Optional) Application may specify a local identity. Otherwise, the
   * handshaker chooses a default local identity.
   * </pre>
   *
   * <code>.grpc.gcp.Identity local_identity = 5;</code>
   */
  public boolean hasLocalIdentity() {
    return localIdentity_ != null;
  }
  /**
   * <pre>
   * (Optional) Application may specify a local identity. Otherwise, the
   * handshaker chooses a default local identity.
   * </pre>
   *
   * <code>.grpc.gcp.Identity local_identity = 5;</code>
   */
  public io.grpc.alts.internal.Identity getLocalIdentity() {
    return localIdentity_ == null ? io.grpc.alts.internal.Identity.getDefaultInstance() : localIdentity_;
  }
  /**
   * <pre>
   * (Optional) Application may specify a local identity. Otherwise, the
   * handshaker chooses a default local identity.
   * </pre>
   *
   * <code>.grpc.gcp.Identity local_identity = 5;</code>
   */
  public io.grpc.alts.internal.IdentityOrBuilder getLocalIdentityOrBuilder() {
    return getLocalIdentity();
  }

  public static final int LOCAL_ENDPOINT_FIELD_NUMBER = 6;
  private io.grpc.alts.internal.Endpoint localEndpoint_;
  /**
   * <pre>
   * (Optional) Local endpoint information of the connection to the server,
   * such as local IP address, port number, and network protocol.
   * </pre>
   *
   * <code>.grpc.gcp.Endpoint local_endpoint = 6;</code>
   */
  public boolean hasLocalEndpoint() {
    return localEndpoint_ != null;
  }
  /**
   * <pre>
   * (Optional) Local endpoint information of the connection to the server,
   * such as local IP address, port number, and network protocol.
   * </pre>
   *
   * <code>.grpc.gcp.Endpoint local_endpoint = 6;</code>
   */
  public io.grpc.alts.internal.Endpoint getLocalEndpoint() {
    return localEndpoint_ == null ? io.grpc.alts.internal.Endpoint.getDefaultInstance() : localEndpoint_;
  }
  /**
   * <pre>
   * (Optional) Local endpoint information of the connection to the server,
   * such as local IP address, port number, and network protocol.
   * </pre>
   *
   * <code>.grpc.gcp.Endpoint local_endpoint = 6;</code>
   */
  public io.grpc.alts.internal.EndpointOrBuilder getLocalEndpointOrBuilder() {
    return getLocalEndpoint();
  }

  public static final int REMOTE_ENDPOINT_FIELD_NUMBER = 7;
  private io.grpc.alts.internal.Endpoint remoteEndpoint_;
  /**
   * <pre>
   * (Optional) Endpoint information of the remote server, such as IP address,
   * port number, and network protocol.
   * </pre>
   *
   * <code>.grpc.gcp.Endpoint remote_endpoint = 7;</code>
   */
  public boolean hasRemoteEndpoint() {
    return remoteEndpoint_ != null;
  }
  /**
   * <pre>
   * (Optional) Endpoint information of the remote server, such as IP address,
   * port number, and network protocol.
   * </pre>
   *
   * <code>.grpc.gcp.Endpoint remote_endpoint = 7;</code>
   */
  public io.grpc.alts.internal.Endpoint getRemoteEndpoint() {
    return remoteEndpoint_ == null ? io.grpc.alts.internal.Endpoint.getDefaultInstance() : remoteEndpoint_;
  }
  /**
   * <pre>
   * (Optional) Endpoint information of the remote server, such as IP address,
   * port number, and network protocol.
   * </pre>
   *
   * <code>.grpc.gcp.Endpoint remote_endpoint = 7;</code>
   */
  public io.grpc.alts.internal.EndpointOrBuilder getRemoteEndpointOrBuilder() {
    return getRemoteEndpoint();
  }

  public static final int TARGET_NAME_FIELD_NUMBER = 8;
  private volatile java.lang.Object targetName_;
  /**
   * <pre>
   * (Optional) If target name is provided, a secure naming check is performed
   * to verify that the peer authenticated identity is indeed authorized to run
   * the target name.
   * </pre>
   *
   * <code>string target_name = 8;</code>
   */
  public java.lang.String getTargetName() {
    java.lang.Object ref = targetName_;
    if (ref instanceof java.lang.String) {
      return (java.lang.String) ref;
    } else {
      com.google.protobuf.ByteString bs = 
          (com.google.protobuf.ByteString) ref;
      java.lang.String s = bs.toStringUtf8();
      targetName_ = s;
      return s;
    }
  }
  /**
   * <pre>
   * (Optional) If target name is provided, a secure naming check is performed
   * to verify that the peer authenticated identity is indeed authorized to run
   * the target name.
   * </pre>
   *
   * <code>string target_name = 8;</code>
   */
  public com.google.protobuf.ByteString
      getTargetNameBytes() {
    java.lang.Object ref = targetName_;
    if (ref instanceof java.lang.String) {
      com.google.protobuf.ByteString b = 
          com.google.protobuf.ByteString.copyFromUtf8(
              (java.lang.String) ref);
      targetName_ = b;
      return b;
    } else {
      return (com.google.protobuf.ByteString) ref;
    }
  }

  public static final int RPC_VERSIONS_FIELD_NUMBER = 9;
  private io.grpc.alts.internal.RpcProtocolVersions rpcVersions_;
  /**
   * <pre>
   * (Optional) RPC protocol versions supported by the client.
   * </pre>
   *
   * <code>.grpc.gcp.RpcProtocolVersions rpc_versions = 9;</code>
   */
  public boolean hasRpcVersions() {
    return rpcVersions_ != null;
  }
  /**
   * <pre>
   * (Optional) RPC protocol versions supported by the client.
   * </pre>
   *
   * <code>.grpc.gcp.RpcProtocolVersions rpc_versions = 9;</code>
   */
  public io.grpc.alts.internal.RpcProtocolVersions getRpcVersions() {
    return rpcVersions_ == null ? io.grpc.alts.internal.RpcProtocolVersions.getDefaultInstance() : rpcVersions_;
  }
  /**
   * <pre>
   * (Optional) RPC protocol versions supported by the client.
   * </pre>
   *
   * <code>.grpc.gcp.RpcProtocolVersions rpc_versions = 9;</code>
   */
  public io.grpc.alts.internal.RpcProtocolVersionsOrBuilder getRpcVersionsOrBuilder() {
    return getRpcVersions();
  }

  private byte memoizedIsInitialized = -1;
  @java.lang.Override
  public final boolean isInitialized() {
    byte isInitialized = memoizedIsInitialized;
    if (isInitialized == 1) return true;
    if (isInitialized == 0) return false;

    memoizedIsInitialized = 1;
    return true;
  }

  @java.lang.Override
  public void writeTo(com.google.protobuf.CodedOutputStream output)
                      throws java.io.IOException {
    if (handshakeSecurityProtocol_ != io.grpc.alts.internal.HandshakeProtocol.HANDSHAKE_PROTOCOL_UNSPECIFIED.getNumber()) {
      output.writeEnum(1, handshakeSecurityProtocol_);
    }
    for (int i = 0; i < applicationProtocols_.size(); i++) {
      com.google.protobuf.GeneratedMessageV3.writeString(output, 2, applicationProtocols_.getRaw(i));
    }
    for (int i = 0; i < recordProtocols_.size(); i++) {
      com.google.protobuf.GeneratedMessageV3.writeString(output, 3, recordProtocols_.getRaw(i));
    }
    for (int i = 0; i < targetIdentities_.size(); i++) {
      output.writeMessage(4, targetIdentities_.get(i));
    }
    if (localIdentity_ != null) {
      output.writeMessage(5, getLocalIdentity());
    }
    if (localEndpoint_ != null) {
      output.writeMessage(6, getLocalEndpoint());
    }
    if (remoteEndpoint_ != null) {
      output.writeMessage(7, getRemoteEndpoint());
    }
    if (!getTargetNameBytes().isEmpty()) {
      com.google.protobuf.GeneratedMessageV3.writeString(output, 8, targetName_);
    }
    if (rpcVersions_ != null) {
      output.writeMessage(9, getRpcVersions());
    }
    unknownFields.writeTo(output);
  }

  @java.lang.Override
  public int getSerializedSize() {
    int size = memoizedSize;
    if (size != -1) return size;

    size = 0;
    if (handshakeSecurityProtocol_ != io.grpc.alts.internal.HandshakeProtocol.HANDSHAKE_PROTOCOL_UNSPECIFIED.getNumber()) {
      size += com.google.protobuf.CodedOutputStream
        .computeEnumSize(1, handshakeSecurityProtocol_);
    }
    {
      int dataSize = 0;
      for (int i = 0; i < applicationProtocols_.size(); i++) {
        dataSize += computeStringSizeNoTag(applicationProtocols_.getRaw(i));
      }
      size += dataSize;
      size += 1 * getApplicationProtocolsList().size();
    }
    {
      int dataSize = 0;
      for (int i = 0; i < recordProtocols_.size(); i++) {
        dataSize += computeStringSizeNoTag(recordProtocols_.getRaw(i));
      }
      size += dataSize;
      size += 1 * getRecordProtocolsList().size();
    }
    for (int i = 0; i < targetIdentities_.size(); i++) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(4, targetIdentities_.get(i));
    }
    if (localIdentity_ != null) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(5, getLocalIdentity());
    }
    if (localEndpoint_ != null) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(6, getLocalEndpoint());
    }
    if (remoteEndpoint_ != null) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(7, getRemoteEndpoint());
    }
    if (!getTargetNameBytes().isEmpty()) {
      size += com.google.protobuf.GeneratedMessageV3.computeStringSize(8, targetName_);
    }
    if (rpcVersions_ != null) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(9, getRpcVersions());
    }
    size += unknownFields.getSerializedSize();
    memoizedSize = size;
    return size;
  }

  @java.lang.Override
  public boolean equals(final java.lang.Object obj) {
    if (obj == this) {
     return true;
    }
    if (!(obj instanceof io.grpc.alts.internal.StartClientHandshakeReq)) {
      return super.equals(obj);
    }
    io.grpc.alts.internal.StartClientHandshakeReq other = (io.grpc.alts.internal.StartClientHandshakeReq) obj;

    boolean result = true;
    result = result && handshakeSecurityProtocol_ == other.handshakeSecurityProtocol_;
    result = result && getApplicationProtocolsList()
        .equals(other.getApplicationProtocolsList());
    result = result && getRecordProtocolsList()
        .equals(other.getRecordProtocolsList());
    result = result && getTargetIdentitiesList()
        .equals(other.getTargetIdentitiesList());
    result = result && (hasLocalIdentity() == other.hasLocalIdentity());
    if (hasLocalIdentity()) {
      result = result && getLocalIdentity()
          .equals(other.getLocalIdentity());
    }
    result = result && (hasLocalEndpoint() == other.hasLocalEndpoint());
    if (hasLocalEndpoint()) {
      result = result && getLocalEndpoint()
          .equals(other.getLocalEndpoint());
    }
    result = result && (hasRemoteEndpoint() == other.hasRemoteEndpoint());
    if (hasRemoteEndpoint()) {
      result = result && getRemoteEndpoint()
          .equals(other.getRemoteEndpoint());
    }
    result = result && getTargetName()
        .equals(other.getTargetName());
    result = result && (hasRpcVersions() == other.hasRpcVersions());
    if (hasRpcVersions()) {
      result = result && getRpcVersions()
          .equals(other.getRpcVersions());
    }
    result = result && unknownFields.equals(other.unknownFields);
    return result;
  }

  @java.lang.Override
  public int hashCode() {
    if (memoizedHashCode != 0) {
      return memoizedHashCode;
    }
    int hash = 41;
    hash = (19 * hash) + getDescriptor().hashCode();
    hash = (37 * hash) + HANDSHAKE_SECURITY_PROTOCOL_FIELD_NUMBER;
    hash = (53 * hash) + handshakeSecurityProtocol_;
    if (getApplicationProtocolsCount() > 0) {
      hash = (37 * hash) + APPLICATION_PROTOCOLS_FIELD_NUMBER;
      hash = (53 * hash) + getApplicationProtocolsList().hashCode();
    }
    if (getRecordProtocolsCount() > 0) {
      hash = (37 * hash) + RECORD_PROTOCOLS_FIELD_NUMBER;
      hash = (53 * hash) + getRecordProtocolsList().hashCode();
    }
    if (getTargetIdentitiesCount() > 0) {
      hash = (37 * hash) + TARGET_IDENTITIES_FIELD_NUMBER;
      hash = (53 * hash) + getTargetIdentitiesList().hashCode();
    }
    if (hasLocalIdentity()) {
      hash = (37 * hash) + LOCAL_IDENTITY_FIELD_NUMBER;
      hash = (53 * hash) + getLocalIdentity().hashCode();
    }
    if (hasLocalEndpoint()) {
      hash = (37 * hash) + LOCAL_ENDPOINT_FIELD_NUMBER;
      hash = (53 * hash) + getLocalEndpoint().hashCode();
    }
    if (hasRemoteEndpoint()) {
      hash = (37 * hash) + REMOTE_ENDPOINT_FIELD_NUMBER;
      hash = (53 * hash) + getRemoteEndpoint().hashCode();
    }
    hash = (37 * hash) + TARGET_NAME_FIELD_NUMBER;
    hash = (53 * hash) + getTargetName().hashCode();
    if (hasRpcVersions()) {
      hash = (37 * hash) + RPC_VERSIONS_FIELD_NUMBER;
      hash = (53 * hash) + getRpcVersions().hashCode();
    }
    hash = (29 * hash) + unknownFields.hashCode();
    memoizedHashCode = hash;
    return hash;
  }

  public static io.grpc.alts.internal.StartClientHandshakeReq parseFrom(
      java.nio.ByteBuffer data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data);
  }
  public static io.grpc.alts.internal.StartClientHandshakeReq parseFrom(
      java.nio.ByteBuffer data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data, extensionRegistry);
  }
  public static io.grpc.alts.internal.StartClientHandshakeReq parseFrom(
      com.google.protobuf.ByteString data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data);
  }
  public static io.grpc.alts.internal.StartClientHandshakeReq parseFrom(
      com.google.protobuf.ByteString data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data, extensionRegistry);
  }
  public static io.grpc.alts.internal.StartClientHandshakeReq parseFrom(byte[] data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data);
  }
  public static io.grpc.alts.internal.StartClientHandshakeReq parseFrom(
      byte[] data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data, extensionRegistry);
  }
  public static io.grpc.alts.internal.StartClientHandshakeReq parseFrom(java.io.InputStream input)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3
        .parseWithIOException(PARSER, input);
  }
  public static io.grpc.alts.internal.StartClientHandshakeReq parseFrom(
      java.io.InputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3
        .parseWithIOException(PARSER, input, extensionRegistry);
  }
  public static io.grpc.alts.internal.StartClientHandshakeReq parseDelimitedFrom(java.io.InputStream input)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3
        .parseDelimitedWithIOException(PARSER, input);
  }
  public static io.grpc.alts.internal.StartClientHandshakeReq parseDelimitedFrom(
      java.io.InputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3
        .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
  }
  public static io.grpc.alts.internal.StartClientHandshakeReq parseFrom(
      com.google.protobuf.CodedInputStream input)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3
        .parseWithIOException(PARSER, input);
  }
  public static io.grpc.alts.internal.StartClientHandshakeReq parseFrom(
      com.google.protobuf.CodedInputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3
        .parseWithIOException(PARSER, input, extensionRegistry);
  }

  @java.lang.Override
  public Builder newBuilderForType() { return newBuilder(); }
  public static Builder newBuilder() {
    return DEFAULT_INSTANCE.toBuilder();
  }
  public static Builder newBuilder(io.grpc.alts.internal.StartClientHandshakeReq prototype) {
    return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
  }
  @java.lang.Override
  public Builder toBuilder() {
    return this == DEFAULT_INSTANCE
        ? new Builder() : new Builder().mergeFrom(this);
  }

  @java.lang.Override
  protected Builder newBuilderForType(
      com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
    Builder builder = new Builder(parent);
    return builder;
  }
  /**
   * Protobuf type {@code grpc.gcp.StartClientHandshakeReq}
   */
  public static final class Builder extends
      com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
      // @@protoc_insertion_point(builder_implements:grpc.gcp.StartClientHandshakeReq)
      io.grpc.alts.internal.StartClientHandshakeReqOrBuilder {
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.grpc.alts.internal.HandshakerProto.internal_static_grpc_gcp_StartClientHandshakeReq_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.grpc.alts.internal.HandshakerProto.internal_static_grpc_gcp_StartClientHandshakeReq_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.grpc.alts.internal.StartClientHandshakeReq.class, io.grpc.alts.internal.StartClientHandshakeReq.Builder.class);
    }

    // Construct using io.grpc.alts.internal.StartClientHandshakeReq.newBuilder()
    private Builder() {
      maybeForceBuilderInitialization();
    }

    private Builder(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      super(parent);
      maybeForceBuilderInitialization();
    }
    private void maybeForceBuilderInitialization() {
      if (com.google.protobuf.GeneratedMessageV3
              .alwaysUseFieldBuilders) {
        getTargetIdentitiesFieldBuilder();
      }
    }
    @java.lang.Override
    public Builder clear() {
      super.clear();
      handshakeSecurityProtocol_ = 0;

      applicationProtocols_ = com.google.protobuf.LazyStringArrayList.EMPTY;
      bitField0_ = (bitField0_ & ~0x00000002);
      recordProtocols_ = com.google.protobuf.LazyStringArrayList.EMPTY;
      bitField0_ = (bitField0_ & ~0x00000004);
      if (targetIdentitiesBuilder_ == null) {
        targetIdentities_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x00000008);
      } else {
        targetIdentitiesBuilder_.clear();
      }
      if (localIdentityBuilder_ == null) {
        localIdentity_ = null;
      } else {
        localIdentity_ = null;
        localIdentityBuilder_ = null;
      }
      if (localEndpointBuilder_ == null) {
        localEndpoint_ = null;
      } else {
        localEndpoint_ = null;
        localEndpointBuilder_ = null;
      }
      if (remoteEndpointBuilder_ == null) {
        remoteEndpoint_ = null;
      } else {
        remoteEndpoint_ = null;
        remoteEndpointBuilder_ = null;
      }
      targetName_ = "";

      if (rpcVersionsBuilder_ == null) {
        rpcVersions_ = null;
      } else {
        rpcVersions_ = null;
        rpcVersionsBuilder_ = null;
      }
      return this;
    }

    @java.lang.Override
    public com.google.protobuf.Descriptors.Descriptor
        getDescriptorForType() {
      return io.grpc.alts.internal.HandshakerProto.internal_static_grpc_gcp_StartClientHandshakeReq_descriptor;
    }

    @java.lang.Override
    public io.grpc.alts.internal.StartClientHandshakeReq getDefaultInstanceForType() {
      return io.grpc.alts.internal.StartClientHandshakeReq.getDefaultInstance();
    }

    @java.lang.Override
    public io.grpc.alts.internal.StartClientHandshakeReq build() {
      io.grpc.alts.internal.StartClientHandshakeReq result = buildPartial();
      if (!result.isInitialized()) {
        throw newUninitializedMessageException(result);
      }
      return result;
    }

    @java.lang.Override
    public io.grpc.alts.internal.StartClientHandshakeReq buildPartial() {
      io.grpc.alts.internal.StartClientHandshakeReq result = new io.grpc.alts.internal.StartClientHandshakeReq(this);
      int from_bitField0_ = bitField0_;
      int to_bitField0_ = 0;
      result.handshakeSecurityProtocol_ = handshakeSecurityProtocol_;
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        applicationProtocols_ = applicationProtocols_.getUnmodifiableView();
        bitField0_ = (bitField0_ & ~0x00000002);
      }
      result.applicationProtocols_ = applicationProtocols_;
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        recordProtocols_ = recordProtocols_.getUnmodifiableView();
        bitField0_ = (bitField0_ & ~0x00000004);
      }
      result.recordProtocols_ = recordProtocols_;
      if (targetIdentitiesBuilder_ == null) {
        if (((bitField0_ & 0x00000008) == 0x00000008)) {
          targetIdentities_ = java.util.Collections.unmodifiableList(targetIdentities_);
          bitField0_ = (bitField0_ & ~0x00000008);
        }
        result.targetIdentities_ = targetIdentities_;
      } else {
        result.targetIdentities_ = targetIdentitiesBuilder_.build();
      }
      if (localIdentityBuilder_ == null) {
        result.localIdentity_ = localIdentity_;
      } else {
        result.localIdentity_ = localIdentityBuilder_.build();
      }
      if (localEndpointBuilder_ == null) {
        result.localEndpoint_ = localEndpoint_;
      } else {
        result.localEndpoint_ = localEndpointBuilder_.build();
      }
      if (remoteEndpointBuilder_ == null) {
        result.remoteEndpoint_ = remoteEndpoint_;
      } else {
        result.remoteEndpoint_ = remoteEndpointBuilder_.build();
      }
      result.targetName_ = targetName_;
      if (rpcVersionsBuilder_ == null) {
        result.rpcVersions_ = rpcVersions_;
      } else {
        result.rpcVersions_ = rpcVersionsBuilder_.build();
      }
      result.bitField0_ = to_bitField0_;
      onBuilt();
      return result;
    }

    @java.lang.Override
    public Builder clone() {
      return (Builder) super.clone();
    }
    @java.lang.Override
    public Builder setField(
        com.google.protobuf.Descriptors.FieldDescriptor field,
        java.lang.Object value) {
      return (Builder) super.setField(field, value);
    }
    @java.lang.Override
    public Builder clearField(
        com.google.protobuf.Descriptors.FieldDescriptor field) {
      return (Builder) super.clearField(field);
    }
    @java.lang.Override
    public Builder clearOneof(
        com.google.protobuf.Descriptors.OneofDescriptor oneof) {
      return (Builder) super.clearOneof(oneof);
    }
    @java.lang.Override
    public Builder setRepeatedField(
        com.google.protobuf.Descriptors.FieldDescriptor field,
        int index, java.lang.Object value) {
      return (Builder) super.setRepeatedField(field, index, value);
    }
    @java.lang.Override
    public Builder addRepeatedField(
        com.google.protobuf.Descriptors.FieldDescriptor field,
        java.lang.Object value) {
      return (Builder) super.addRepeatedField(field, value);
    }
    @java.lang.Override
    public Builder mergeFrom(com.google.protobuf.Message other) {
      if (other instanceof io.grpc.alts.internal.StartClientHandshakeReq) {
        return mergeFrom((io.grpc.alts.internal.StartClientHandshakeReq)other);
      } else {
        super.mergeFrom(other);
        return this;
      }
    }

    public Builder mergeFrom(io.grpc.alts.internal.StartClientHandshakeReq other) {
      if (other == io.grpc.alts.internal.StartClientHandshakeReq.getDefaultInstance()) return this;
      if (other.handshakeSecurityProtocol_ != 0) {
        setHandshakeSecurityProtocolValue(other.getHandshakeSecurityProtocolValue());
      }
      if (!other.applicationProtocols_.isEmpty()) {
        if (applicationProtocols_.isEmpty()) {
          applicationProtocols_ = other.applicationProtocols_;
          bitField0_ = (bitField0_ & ~0x00000002);
        } else {
          ensureApplicationProtocolsIsMutable();
          applicationProtocols_.addAll(other.applicationProtocols_);
        }
        onChanged();
      }
      if (!other.recordProtocols_.isEmpty()) {
        if (recordProtocols_.isEmpty()) {
          recordProtocols_ = other.recordProtocols_;
          bitField0_ = (bitField0_ & ~0x00000004);
        } else {
          ensureRecordProtocolsIsMutable();
          recordProtocols_.addAll(other.recordProtocols_);
        }
        onChanged();
      }
      if (targetIdentitiesBuilder_ == null) {
        if (!other.targetIdentities_.isEmpty()) {
          if (targetIdentities_.isEmpty()) {
            targetIdentities_ = other.targetIdentities_;
            bitField0_ = (bitField0_ & ~0x00000008);
          } else {
            ensureTargetIdentitiesIsMutable();
            targetIdentities_.addAll(other.targetIdentities_);
          }
          onChanged();
        }
      } else {
        if (!other.targetIdentities_.isEmpty()) {
          if (targetIdentitiesBuilder_.isEmpty()) {
            targetIdentitiesBuilder_.dispose();
            targetIdentitiesBuilder_ = null;
            targetIdentities_ = other.targetIdentities_;
            bitField0_ = (bitField0_ & ~0x00000008);
            targetIdentitiesBuilder_ = 
              com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                 getTargetIdentitiesFieldBuilder() : null;
          } else {
            targetIdentitiesBuilder_.addAllMessages(other.targetIdentities_);
          }
        }
      }
      if (other.hasLocalIdentity()) {
        mergeLocalIdentity(other.getLocalIdentity());
      }
      if (other.hasLocalEndpoint()) {
        mergeLocalEndpoint(other.getLocalEndpoint());
      }
      if (other.hasRemoteEndpoint()) {
        mergeRemoteEndpoint(other.getRemoteEndpoint());
      }
      if (!other.getTargetName().isEmpty()) {
        targetName_ = other.targetName_;
        onChanged();
      }
      if (other.hasRpcVersions()) {
        mergeRpcVersions(other.getRpcVersions());
      }
      this.mergeUnknownFields(other.unknownFields);
      onChanged();
      return this;
    }

    @java.lang.Override
    public final boolean isInitialized() {
      return true;
    }

    @java.lang.Override
    public Builder mergeFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      io.grpc.alts.internal.StartClientHandshakeReq parsedMessage = null;
      try {
        parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        parsedMessage = (io.grpc.alts.internal.StartClientHandshakeReq) e.getUnfinishedMessage();
        throw e.unwrapIOException();
      } finally {
        if (parsedMessage != null) {
          mergeFrom(parsedMessage);
        }
      }
      return this;
    }
    private int bitField0_;

    private int handshakeSecurityProtocol_ = 0;
    /**
     * <pre>
     * Handshake security protocol requested by the client.
     * </pre>
     *
     * <code>.grpc.gcp.HandshakeProtocol handshake_security_protocol = 1;</code>
     */
    public int getHandshakeSecurityProtocolValue() {
      return handshakeSecurityProtocol_;
    }
    /**
     * <pre>
     * Handshake security protocol requested by the client.
     * </pre>
     *
     * <code>.grpc.gcp.HandshakeProtocol handshake_security_protocol = 1;</code>
     */
    public Builder setHandshakeSecurityProtocolValue(int value) {
      handshakeSecurityProtocol_ = value;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Handshake security protocol requested by the client.
     * </pre>
     *
     * <code>.grpc.gcp.HandshakeProtocol handshake_security_protocol = 1;</code>
     */
    public io.grpc.alts.internal.HandshakeProtocol getHandshakeSecurityProtocol() {
      @SuppressWarnings("deprecation")
      io.grpc.alts.internal.HandshakeProtocol result = io.grpc.alts.internal.HandshakeProtocol.valueOf(handshakeSecurityProtocol_);
      return result == null ? io.grpc.alts.internal.HandshakeProtocol.UNRECOGNIZED : result;
    }
    /**
     * <pre>
     * Handshake security protocol requested by the client.
     * </pre>
     *
     * <code>.grpc.gcp.HandshakeProtocol handshake_security_protocol = 1;</code>
     */
    public Builder setHandshakeSecurityProtocol(io.grpc.alts.internal.HandshakeProtocol value) {
      if (value == null) {
        throw new NullPointerException();
      }
      
      handshakeSecurityProtocol_ = value.getNumber();
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Handshake security protocol requested by the client.
     * </pre>
     *
     * <code>.grpc.gcp.HandshakeProtocol handshake_security_protocol = 1;</code>
     */
    public Builder clearHandshakeSecurityProtocol() {
      
      handshakeSecurityProtocol_ = 0;
      onChanged();
      return this;
    }

    private com.google.protobuf.LazyStringList applicationProtocols_ = com.google.protobuf.LazyStringArrayList.EMPTY;
    private void ensureApplicationProtocolsIsMutable() {
      if (!((bitField0_ & 0x00000002) == 0x00000002)) {
        applicationProtocols_ = new com.google.protobuf.LazyStringArrayList(applicationProtocols_);
        bitField0_ |= 0x00000002;
       }
    }
    /**
     * <pre>
     * The application protocols supported by the client, e.g., "h2" (for http2),
     * "grpc".
     * </pre>
     *
     * <code>repeated string application_protocols = 2;</code>
     */
    public com.google.protobuf.ProtocolStringList
        getApplicationProtocolsList() {
      return applicationProtocols_.getUnmodifiableView();
    }
    /**
     * <pre>
     * The application protocols supported by the client, e.g., "h2" (for http2),
     * "grpc".
     * </pre>
     *
     * <code>repeated string application_protocols = 2;</code>
     */
    public int getApplicationProtocolsCount() {
      return applicationProtocols_.size();
    }
    /**
     * <pre>
     * The application protocols supported by the client, e.g., "h2" (for http2),
     * "grpc".
     * </pre>
     *
     * <code>repeated string application_protocols = 2;</code>
     */
    public java.lang.String getApplicationProtocols(int index) {
      return applicationProtocols_.get(index);
    }
    /**
     * <pre>
     * The application protocols supported by the client, e.g., "h2" (for http2),
     * "grpc".
     * </pre>
     *
     * <code>repeated string application_protocols = 2;</code>
     */
    public com.google.protobuf.ByteString
        getApplicationProtocolsBytes(int index) {
      return applicationProtocols_.getByteString(index);
    }
    /**
     * <pre>
     * The application protocols supported by the client, e.g., "h2" (for http2),
     * "grpc".
     * </pre>
     *
     * <code>repeated string application_protocols = 2;</code>
     */
    public Builder setApplicationProtocols(
        int index, java.lang.String value) {
      if (value == null) {
    throw new NullPointerException();
  }
  ensureApplicationProtocolsIsMutable();
      applicationProtocols_.set(index, value);
      onChanged();
      return this;
    }
    /**
     * <pre>
     * The application protocols supported by the client, e.g., "h2" (for http2),
     * "grpc".
     * </pre>
     *
     * <code>repeated string application_protocols = 2;</code>
     */
    public Builder addApplicationProtocols(
        java.lang.String value) {
      if (value == null) {
    throw new NullPointerException();
  }
  ensureApplicationProtocolsIsMutable();
      applicationProtocols_.add(value);
      onChanged();
      return this;
    }
    /**
     * <pre>
     * The application protocols supported by the client, e.g., "h2" (for http2),
     * "grpc".
     * </pre>
     *
     * <code>repeated string application_protocols = 2;</code>
     */
    public Builder addAllApplicationProtocols(
        java.lang.Iterable<java.lang.String> values) {
      ensureApplicationProtocolsIsMutable();
      com.google.protobuf.AbstractMessageLite.Builder.addAll(
          values, applicationProtocols_);
      onChanged();
      return this;
    }
    /**
     * <pre>
     * The application protocols supported by the client, e.g., "h2" (for http2),
     * "grpc".
     * </pre>
     *
     * <code>repeated string application_protocols = 2;</code>
     */
    public Builder clearApplicationProtocols() {
      applicationProtocols_ = com.google.protobuf.LazyStringArrayList.EMPTY;
      bitField0_ = (bitField0_ & ~0x00000002);
      onChanged();
      return this;
    }
    /**
     * <pre>
     * The application protocols supported by the client, e.g., "h2" (for http2),
     * "grpc".
     * </pre>
     *
     * <code>repeated string application_protocols = 2;</code>
     */
    public Builder addApplicationProtocolsBytes(
        com.google.protobuf.ByteString value) {
      if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
      ensureApplicationProtocolsIsMutable();
      applicationProtocols_.add(value);
      onChanged();
      return this;
    }

    private com.google.protobuf.LazyStringList recordProtocols_ = com.google.protobuf.LazyStringArrayList.EMPTY;
    private void ensureRecordProtocolsIsMutable() {
      if (!((bitField0_ & 0x00000004) == 0x00000004)) {
        recordProtocols_ = new com.google.protobuf.LazyStringArrayList(recordProtocols_);
        bitField0_ |= 0x00000004;
       }
    }
    /**
     * <pre>
     * The record protocols supported by the client, e.g.,
     * "ALTSRP_GCM_AES128".
     * </pre>
     *
     * <code>repeated string record_protocols = 3;</code>
     */
    public com.google.protobuf.ProtocolStringList
        getRecordProtocolsList() {
      return recordProtocols_.getUnmodifiableView();
    }
    /**
     * <pre>
     * The record protocols supported by the client, e.g.,
     * "ALTSRP_GCM_AES128".
     * </pre>
     *
     * <code>repeated string record_protocols = 3;</code>
     */
    public int getRecordProtocolsCount() {
      return recordProtocols_.size();
    }
    /**
     * <pre>
     * The record protocols supported by the client, e.g.,
     * "ALTSRP_GCM_AES128".
     * </pre>
     *
     * <code>repeated string record_protocols = 3;</code>
     */
    public java.lang.String getRecordProtocols(int index) {
      return recordProtocols_.get(index);
    }
    /**
     * <pre>
     * The record protocols supported by the client, e.g.,
     * "ALTSRP_GCM_AES128".
     * </pre>
     *
     * <code>repeated string record_protocols = 3;</code>
     */
    public com.google.protobuf.ByteString
        getRecordProtocolsBytes(int index) {
      return recordProtocols_.getByteString(index);
    }
    /**
     * <pre>
     * The record protocols supported by the client, e.g.,
     * "ALTSRP_GCM_AES128".
     * </pre>
     *
     * <code>repeated string record_protocols = 3;</code>
     */
    public Builder setRecordProtocols(
        int index, java.lang.String value) {
      if (value == null) {
    throw new NullPointerException();
  }
  ensureRecordProtocolsIsMutable();
      recordProtocols_.set(index, value);
      onChanged();
      return this;
    }
    /**
     * <pre>
     * The record protocols supported by the client, e.g.,
     * "ALTSRP_GCM_AES128".
     * </pre>
     *
     * <code>repeated string record_protocols = 3;</code>
     */
    public Builder addRecordProtocols(
        java.lang.String value) {
      if (value == null) {
    throw new NullPointerException();
  }
  ensureRecordProtocolsIsMutable();
      recordProtocols_.add(value);
      onChanged();
      return this;
    }
    /**
     * <pre>
     * The record protocols supported by the client, e.g.,
     * "ALTSRP_GCM_AES128".
     * </pre>
     *
     * <code>repeated string record_protocols = 3;</code>
     */
    public Builder addAllRecordProtocols(
        java.lang.Iterable<java.lang.String> values) {
      ensureRecordProtocolsIsMutable();
      com.google.protobuf.AbstractMessageLite.Builder.addAll(
          values, recordProtocols_);
      onChanged();
      return this;
    }
    /**
     * <pre>
     * The record protocols supported by the client, e.g.,
     * "ALTSRP_GCM_AES128".
     * </pre>
     *
     * <code>repeated string record_protocols = 3;</code>
     */
    public Builder clearRecordProtocols() {
      recordProtocols_ = com.google.protobuf.LazyStringArrayList.EMPTY;
      bitField0_ = (bitField0_ & ~0x00000004);
      onChanged();
      return this;
    }
    /**
     * <pre>
     * The record protocols supported by the client, e.g.,
     * "ALTSRP_GCM_AES128".
     * </pre>
     *
     * <code>repeated string record_protocols = 3;</code>
     */
    public Builder addRecordProtocolsBytes(
        com.google.protobuf.ByteString value) {
      if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
      ensureRecordProtocolsIsMutable();
      recordProtocols_.add(value);
      onChanged();
      return this;
    }

    private java.util.List<io.grpc.alts.internal.Identity> targetIdentities_ =
      java.util.Collections.emptyList();
    private void ensureTargetIdentitiesIsMutable() {
      if (!((bitField0_ & 0x00000008) == 0x00000008)) {
        targetIdentities_ = new java.util.ArrayList<io.grpc.alts.internal.Identity>(targetIdentities_);
        bitField0_ |= 0x00000008;
       }
    }

    private com.google.protobuf.RepeatedFieldBuilderV3<
        io.grpc.alts.internal.Identity, io.grpc.alts.internal.Identity.Builder, io.grpc.alts.internal.IdentityOrBuilder> targetIdentitiesBuilder_;

    /**
     * <pre>
     * (Optional) Describes which server identities are acceptable by the client.
     * If target identities are provided and none of them matches the peer
     * identity of the server, handshake will fail.
     * </pre>
     *
     * <code>repeated .grpc.gcp.Identity target_identities = 4;</code>
     */
    public java.util.List<io.grpc.alts.internal.Identity> getTargetIdentitiesList() {
      if (targetIdentitiesBuilder_ == null) {
        return java.util.Collections.unmodifiableList(targetIdentities_);
      } else {
        return targetIdentitiesBuilder_.getMessageList();
      }
    }
    /**
     * <pre>
     * (Optional) Describes which server identities are acceptable by the client.
     * If target identities are provided and none of them matches the peer
     * identity of the server, handshake will fail.
     * </pre>
     *
     * <code>repeated .grpc.gcp.Identity target_identities = 4;</code>
     */
    public int getTargetIdentitiesCount() {
      if (targetIdentitiesBuilder_ == null) {
        return targetIdentities_.size();
      } else {
        return targetIdentitiesBuilder_.getCount();
      }
    }
    /**
     * <pre>
     * (Optional) Describes which server identities are acceptable by the client.
     * If target identities are provided and none of them matches the peer
     * identity of the server, handshake will fail.
     * </pre>
     *
     * <code>repeated .grpc.gcp.Identity target_identities = 4;</code>
     */
    public io.grpc.alts.internal.Identity getTargetIdentities(int index) {
      if (targetIdentitiesBuilder_ == null) {
        return targetIdentities_.get(index);
      } else {
        return targetIdentitiesBuilder_.getMessage(index);
      }
    }
    /**
     * <pre>
     * (Optional) Describes which server identities are acceptable by the client.
     * If target identities are provided and none of them matches the peer
     * identity of the server, handshake will fail.
     * </pre>
     *
     * <code>repeated .grpc.gcp.Identity target_identities = 4;</code>
     */
    public Builder setTargetIdentities(
        int index, io.grpc.alts.internal.Identity value) {
      if (targetIdentitiesBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureTargetIdentitiesIsMutable();
        targetIdentities_.set(index, value);
        onChanged();
      } else {
        targetIdentitiesBuilder_.setMessage(index, value);
      }
      return this;
    }
    /**
     * <pre>
     * (Optional) Describes which server identities are acceptable by the client.
     * If target identities are provided and none of them matches the peer
     * identity of the server, handshake will fail.
     * </pre>
     *
     * <code>repeated .grpc.gcp.Identity target_identities = 4;</code>
     */
    public Builder setTargetIdentities(
        int index, io.grpc.alts.internal.Identity.Builder builderForValue) {
      if (targetIdentitiesBuilder_ == null) {
        ensureTargetIdentitiesIsMutable();
        targetIdentities_.set(index, builderForValue.build());
        onChanged();
      } else {
        targetIdentitiesBuilder_.setMessage(index, builderForValue.build());
      }
      return this;
    }
    /**
     * <pre>
     * (Optional) Describes which server identities are acceptable by the client.
     * If target identities are provided and none of them matches the peer
     * identity of the server, handshake will fail.
     * </pre>
     *
     * <code>repeated .grpc.gcp.Identity target_identities = 4;</code>
     */
    public Builder addTargetIdentities(io.grpc.alts.internal.Identity value) {
      if (targetIdentitiesBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureTargetIdentitiesIsMutable();
        targetIdentities_.add(value);
        onChanged();
      } else {
        targetIdentitiesBuilder_.addMessage(value);
      }
      return this;
    }
    /**
     * <pre>
     * (Optional) Describes which server identities are acceptable by the client.
     * If target identities are provided and none of them matches the peer
     * identity of the server, handshake will fail.
     * </pre>
     *
     * <code>repeated .grpc.gcp.Identity target_identities = 4;</code>
     */
    public Builder addTargetIdentities(
        int index, io.grpc.alts.internal.Identity value) {
      if (targetIdentitiesBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureTargetIdentitiesIsMutable();
        targetIdentities_.add(index, value);
        onChanged();
      } else {
        targetIdentitiesBuilder_.addMessage(index, value);
      }
      return this;
    }
    /**
     * <pre>
     * (Optional) Describes which server identities are acceptable by the client.
     * If target identities are provided and none of them matches the peer
     * identity of the server, handshake will fail.
     * </pre>
     *
     * <code>repeated .grpc.gcp.Identity target_identities = 4;</code>
     */
    public Builder addTargetIdentities(
        io.grpc.alts.internal.Identity.Builder builderForValue) {
      if (targetIdentitiesBuilder_ == null) {
        ensureTargetIdentitiesIsMutable();
        targetIdentities_.add(builderForValue.build());
        onChanged();
      } else {
        targetIdentitiesBuilder_.addMessage(builderForValue.build());
      }
      return this;
    }
    /**
     * <pre>
     * (Optional) Describes which server identities are acceptable by the client.
     * If target identities are provided and none of them matches the peer
     * identity of the server, handshake will fail.
     * </pre>
     *
     * <code>repeated .grpc.gcp.Identity target_identities = 4;</code>
     */
    public Builder addTargetIdentities(
        int index, io.grpc.alts.internal.Identity.Builder builderForValue) {
      if (targetIdentitiesBuilder_ == null) {
        ensureTargetIdentitiesIsMutable();
        targetIdentities_.add(index, builderForValue.build());
        onChanged();
      } else {
        targetIdentitiesBuilder_.addMessage(index, builderForValue.build());
      }
      return this;
    }
    /**
     * <pre>
     * (Optional) Describes which server identities are acceptable by the client.
     * If target identities are provided and none of them matches the peer
     * identity of the server, handshake will fail.
     * </pre>
     *
     * <code>repeated .grpc.gcp.Identity target_identities = 4;</code>
     */
    public Builder addAllTargetIdentities(
        java.lang.Iterable<? extends io.grpc.alts.internal.Identity> values) {
      if (targetIdentitiesBuilder_ == null) {
        ensureTargetIdentitiesIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, targetIdentities_);
        onChanged();
      } else {
        targetIdentitiesBuilder_.addAllMessages(values);
      }
      return this;
    }
    /**
     * <pre>
     * (Optional) Describes which server identities are acceptable by the client.
     * If target identities are provided and none of them matches the peer
     * identity of the server, handshake will fail.
     * </pre>
     *
     * <code>repeated .grpc.gcp.Identity target_identities = 4;</code>
     */
    public Builder clearTargetIdentities() {
      if (targetIdentitiesBuilder_ == null) {
        targetIdentities_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x00000008);
        onChanged();
      } else {
        targetIdentitiesBuilder_.clear();
      }
      return this;
    }
    /**
     * <pre>
     * (Optional) Describes which server identities are acceptable by the client.
     * If target identities are provided and none of them matches the peer
     * identity of the server, handshake will fail.
     * </pre>
     *
     * <code>repeated .grpc.gcp.Identity target_identities = 4;</code>
     */
    public Builder removeTargetIdentities(int index) {
      if (targetIdentitiesBuilder_ == null) {
        ensureTargetIdentitiesIsMutable();
        targetIdentities_.remove(index);
        onChanged();
      } else {
        targetIdentitiesBuilder_.remove(index);
      }
      return this;
    }
    /**
     * <pre>
     * (Optional) Describes which server identities are acceptable by the client.
     * If target identities are provided and none of them matches the peer
     * identity of the server, handshake will fail.
     * </pre>
     *
     * <code>repeated .grpc.gcp.Identity target_identities = 4;</code>
     */
    public io.grpc.alts.internal.Identity.Builder getTargetIdentitiesBuilder(
        int index) {
      return getTargetIdentitiesFieldBuilder().getBuilder(index);
    }
    /**
     * <pre>
     * (Optional) Describes which server identities are acceptable by the client.
     * If target identities are provided and none of them matches the peer
     * identity of the server, handshake will fail.
     * </pre>
     *
     * <code>repeated .grpc.gcp.Identity target_identities = 4;</code>
     */
    public io.grpc.alts.internal.IdentityOrBuilder getTargetIdentitiesOrBuilder(
        int index) {
      if (targetIdentitiesBuilder_ == null) {
        return targetIdentities_.get(index);  } else {
        return targetIdentitiesBuilder_.getMessageOrBuilder(index);
      }
    }
    /**
     * <pre>
     * (Optional) Describes which server identities are acceptable by the client.
     * If target identities are provided and none of them matches the peer
     * identity of the server, handshake will fail.
     * </pre>
     *
     * <code>repeated .grpc.gcp.Identity target_identities = 4;</code>
     */
    public java.util.List<? extends io.grpc.alts.internal.IdentityOrBuilder> 
         getTargetIdentitiesOrBuilderList() {
      if (targetIdentitiesBuilder_ != null) {
        return targetIdentitiesBuilder_.getMessageOrBuilderList();
      } else {
        return java.util.Collections.unmodifiableList(targetIdentities_);
      }
    }
    /**
     * <pre>
     * (Optional) Describes which server identities are acceptable by the client.
     * If target identities are provided and none of them matches the peer
     * identity of the server, handshake will fail.
     * </pre>
     *
     * <code>repeated .grpc.gcp.Identity target_identities = 4;</code>
     */
    public io.grpc.alts.internal.Identity.Builder addTargetIdentitiesBuilder() {
      return getTargetIdentitiesFieldBuilder().addBuilder(
          io.grpc.alts.internal.Identity.getDefaultInstance());
    }
    /**
     * <pre>
     * (Optional) Describes which server identities are acceptable by the client.
     * If target identities are provided and none of them matches the peer
     * identity of the server, handshake will fail.
     * </pre>
     *
     * <code>repeated .grpc.gcp.Identity target_identities = 4;</code>
     */
    public io.grpc.alts.internal.Identity.Builder addTargetIdentitiesBuilder(
        int index) {
      return getTargetIdentitiesFieldBuilder().addBuilder(
          index, io.grpc.alts.internal.Identity.getDefaultInstance());
    }
    /**
     * <pre>
     * (Optional) Describes which server identities are acceptable by the client.
     * If target identities are provided and none of them matches the peer
     * identity of the server, handshake will fail.
     * </pre>
     *
     * <code>repeated .grpc.gcp.Identity target_identities = 4;</code>
     */
    public java.util.List<io.grpc.alts.internal.Identity.Builder> 
         getTargetIdentitiesBuilderList() {
      return getTargetIdentitiesFieldBuilder().getBuilderList();
    }
    private com.google.protobuf.RepeatedFieldBuilderV3<
        io.grpc.alts.internal.Identity, io.grpc.alts.internal.Identity.Builder, io.grpc.alts.internal.IdentityOrBuilder> 
        getTargetIdentitiesFieldBuilder() {
      if (targetIdentitiesBuilder_ == null) {
        targetIdentitiesBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
            io.grpc.alts.internal.Identity, io.grpc.alts.internal.Identity.Builder, io.grpc.alts.internal.IdentityOrBuilder>(
                targetIdentities_,
                ((bitField0_ & 0x00000008) == 0x00000008),
                getParentForChildren(),
                isClean());
        targetIdentities_ = null;
      }
      return targetIdentitiesBuilder_;
    }

    private io.grpc.alts.internal.Identity localIdentity_ = null;
    private com.google.protobuf.SingleFieldBuilderV3<
        io.grpc.alts.internal.Identity, io.grpc.alts.internal.Identity.Builder, io.grpc.alts.internal.IdentityOrBuilder> localIdentityBuilder_;
    /**
     * <pre>
     * (Optional) Application may specify a local identity. Otherwise, the
     * handshaker chooses a default local identity.
     * </pre>
     *
     * <code>.grpc.gcp.Identity local_identity = 5;</code>
     */
    public boolean hasLocalIdentity() {
      return localIdentityBuilder_ != null || localIdentity_ != null;
    }
    /**
     * <pre>
     * (Optional) Application may specify a local identity. Otherwise, the
     * handshaker chooses a default local identity.
     * </pre>
     *
     * <code>.grpc.gcp.Identity local_identity = 5;</code>
     */
    public io.grpc.alts.internal.Identity getLocalIdentity() {
      if (localIdentityBuilder_ == null) {
        return localIdentity_ == null ? io.grpc.alts.internal.Identity.getDefaultInstance() : localIdentity_;
      } else {
        return localIdentityBuilder_.getMessage();
      }
    }
    /**
     * <pre>
     * (Optional) Application may specify a local identity. Otherwise, the
     * handshaker chooses a default local identity.
     * </pre>
     *
     * <code>.grpc.gcp.Identity local_identity = 5;</code>
     */
    public Builder setLocalIdentity(io.grpc.alts.internal.Identity value) {
      if (localIdentityBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        localIdentity_ = value;
        onChanged();
      } else {
        localIdentityBuilder_.setMessage(value);
      }

      return this;
    }
    /**
     * <pre>
     * (Optional) Application may specify a local identity. Otherwise, the
     * handshaker chooses a default local identity.
     * </pre>
     *
     * <code>.grpc.gcp.Identity local_identity = 5;</code>
     */
    public Builder setLocalIdentity(
        io.grpc.alts.internal.Identity.Builder builderForValue) {
      if (localIdentityBuilder_ == null) {
        localIdentity_ = builderForValue.build();
        onChanged();
      } else {
        localIdentityBuilder_.setMessage(builderForValue.build());
      }

      return this;
    }
    /**
     * <pre>
     * (Optional) Application may specify a local identity. Otherwise, the
     * handshaker chooses a default local identity.
     * </pre>
     *
     * <code>.grpc.gcp.Identity local_identity = 5;</code>
     */
    public Builder mergeLocalIdentity(io.grpc.alts.internal.Identity value) {
      if (localIdentityBuilder_ == null) {
        if (localIdentity_ != null) {
          localIdentity_ =
            io.grpc.alts.internal.Identity.newBuilder(localIdentity_).mergeFrom(value).buildPartial();
        } else {
          localIdentity_ = value;
        }
        onChanged();
      } else {
        localIdentityBuilder_.mergeFrom(value);
      }

      return this;
    }
    /**
     * <pre>
     * (Optional) Application may specify a local identity. Otherwise, the
     * handshaker chooses a default local identity.
     * </pre>
     *
     * <code>.grpc.gcp.Identity local_identity = 5;</code>
     */
    public Builder clearLocalIdentity() {
      if (localIdentityBuilder_ == null) {
        localIdentity_ = null;
        onChanged();
      } else {
        localIdentity_ = null;
        localIdentityBuilder_ = null;
      }

      return this;
    }
    /**
     * <pre>
     * (Optional) Application may specify a local identity. Otherwise, the
     * handshaker chooses a default local identity.
     * </pre>
     *
     * <code>.grpc.gcp.Identity local_identity = 5;</code>
     */
    public io.grpc.alts.internal.Identity.Builder getLocalIdentityBuilder() {
      
      onChanged();
      return getLocalIdentityFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * (Optional) Application may specify a local identity. Otherwise, the
     * handshaker chooses a default local identity.
     * </pre>
     *
     * <code>.grpc.gcp.Identity local_identity = 5;</code>
     */
    public io.grpc.alts.internal.IdentityOrBuilder getLocalIdentityOrBuilder() {
      if (localIdentityBuilder_ != null) {
        return localIdentityBuilder_.getMessageOrBuilder();
      } else {
        return localIdentity_ == null ?
            io.grpc.alts.internal.Identity.getDefaultInstance() : localIdentity_;
      }
    }
    /**
     * <pre>
     * (Optional) Application may specify a local identity. Otherwise, the
     * handshaker chooses a default local identity.
     * </pre>
     *
     * <code>.grpc.gcp.Identity local_identity = 5;</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        io.grpc.alts.internal.Identity, io.grpc.alts.internal.Identity.Builder, io.grpc.alts.internal.IdentityOrBuilder> 
        getLocalIdentityFieldBuilder() {
      if (localIdentityBuilder_ == null) {
        localIdentityBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            io.grpc.alts.internal.Identity, io.grpc.alts.internal.Identity.Builder, io.grpc.alts.internal.IdentityOrBuilder>(
                getLocalIdentity(),
                getParentForChildren(),
                isClean());
        localIdentity_ = null;
      }
      return localIdentityBuilder_;
    }

    private io.grpc.alts.internal.Endpoint localEndpoint_ = null;
    private com.google.protobuf.SingleFieldBuilderV3<
        io.grpc.alts.internal.Endpoint, io.grpc.alts.internal.Endpoint.Builder, io.grpc.alts.internal.EndpointOrBuilder> localEndpointBuilder_;
    /**
     * <pre>
     * (Optional) Local endpoint information of the connection to the server,
     * such as local IP address, port number, and network protocol.
     * </pre>
     *
     * <code>.grpc.gcp.Endpoint local_endpoint = 6;</code>
     */
    public boolean hasLocalEndpoint() {
      return localEndpointBuilder_ != null || localEndpoint_ != null;
    }
    /**
     * <pre>
     * (Optional) Local endpoint information of the connection to the server,
     * such as local IP address, port number, and network protocol.
     * </pre>
     *
     * <code>.grpc.gcp.Endpoint local_endpoint = 6;</code>
     */
    public io.grpc.alts.internal.Endpoint getLocalEndpoint() {
      if (localEndpointBuilder_ == null) {
        return localEndpoint_ == null ? io.grpc.alts.internal.Endpoint.getDefaultInstance() : localEndpoint_;
      } else {
        return localEndpointBuilder_.getMessage();
      }
    }
    /**
     * <pre>
     * (Optional) Local endpoint information of the connection to the server,
     * such as local IP address, port number, and network protocol.
     * </pre>
     *
     * <code>.grpc.gcp.Endpoint local_endpoint = 6;</code>
     */
    public Builder setLocalEndpoint(io.grpc.alts.internal.Endpoint value) {
      if (localEndpointBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        localEndpoint_ = value;
        onChanged();
      } else {
        localEndpointBuilder_.setMessage(value);
      }

      return this;
    }
    /**
     * <pre>
     * (Optional) Local endpoint information of the connection to the server,
     * such as local IP address, port number, and network protocol.
     * </pre>
     *
     * <code>.grpc.gcp.Endpoint local_endpoint = 6;</code>
     */
    public Builder setLocalEndpoint(
        io.grpc.alts.internal.Endpoint.Builder builderForValue) {
      if (localEndpointBuilder_ == null) {
        localEndpoint_ = builderForValue.build();
        onChanged();
      } else {
        localEndpointBuilder_.setMessage(builderForValue.build());
      }

      return this;
    }
    /**
     * <pre>
     * (Optional) Local endpoint information of the connection to the server,
     * such as local IP address, port number, and network protocol.
     * </pre>
     *
     * <code>.grpc.gcp.Endpoint local_endpoint = 6;</code>
     */
    public Builder mergeLocalEndpoint(io.grpc.alts.internal.Endpoint value) {
      if (localEndpointBuilder_ == null) {
        if (localEndpoint_ != null) {
          localEndpoint_ =
            io.grpc.alts.internal.Endpoint.newBuilder(localEndpoint_).mergeFrom(value).buildPartial();
        } else {
          localEndpoint_ = value;
        }
        onChanged();
      } else {
        localEndpointBuilder_.mergeFrom(value);
      }

      return this;
    }
    /**
     * <pre>
     * (Optional) Local endpoint information of the connection to the server,
     * such as local IP address, port number, and network protocol.
     * </pre>
     *
     * <code>.grpc.gcp.Endpoint local_endpoint = 6;</code>
     */
    public Builder clearLocalEndpoint() {
      if (localEndpointBuilder_ == null) {
        localEndpoint_ = null;
        onChanged();
      } else {
        localEndpoint_ = null;
        localEndpointBuilder_ = null;
      }

      return this;
    }
    /**
     * <pre>
     * (Optional) Local endpoint information of the connection to the server,
     * such as local IP address, port number, and network protocol.
     * </pre>
     *
     * <code>.grpc.gcp.Endpoint local_endpoint = 6;</code>
     */
    public io.grpc.alts.internal.Endpoint.Builder getLocalEndpointBuilder() {
      
      onChanged();
      return getLocalEndpointFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * (Optional) Local endpoint information of the connection to the server,
     * such as local IP address, port number, and network protocol.
     * </pre>
     *
     * <code>.grpc.gcp.Endpoint local_endpoint = 6;</code>
     */
    public io.grpc.alts.internal.EndpointOrBuilder getLocalEndpointOrBuilder() {
      if (localEndpointBuilder_ != null) {
        return localEndpointBuilder_.getMessageOrBuilder();
      } else {
        return localEndpoint_ == null ?
            io.grpc.alts.internal.Endpoint.getDefaultInstance() : localEndpoint_;
      }
    }
    /**
     * <pre>
     * (Optional) Local endpoint information of the connection to the server,
     * such as local IP address, port number, and network protocol.
     * </pre>
     *
     * <code>.grpc.gcp.Endpoint local_endpoint = 6;</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        io.grpc.alts.internal.Endpoint, io.grpc.alts.internal.Endpoint.Builder, io.grpc.alts.internal.EndpointOrBuilder> 
        getLocalEndpointFieldBuilder() {
      if (localEndpointBuilder_ == null) {
        localEndpointBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            io.grpc.alts.internal.Endpoint, io.grpc.alts.internal.Endpoint.Builder, io.grpc.alts.internal.EndpointOrBuilder>(
                getLocalEndpoint(),
                getParentForChildren(),
                isClean());
        localEndpoint_ = null;
      }
      return localEndpointBuilder_;
    }

    private io.grpc.alts.internal.Endpoint remoteEndpoint_ = null;
    private com.google.protobuf.SingleFieldBuilderV3<
        io.grpc.alts.internal.Endpoint, io.grpc.alts.internal.Endpoint.Builder, io.grpc.alts.internal.EndpointOrBuilder> remoteEndpointBuilder_;
    /**
     * <pre>
     * (Optional) Endpoint information of the remote server, such as IP address,
     * port number, and network protocol.
     * </pre>
     *
     * <code>.grpc.gcp.Endpoint remote_endpoint = 7;</code>
     */
    public boolean hasRemoteEndpoint() {
      return remoteEndpointBuilder_ != null || remoteEndpoint_ != null;
    }
    /**
     * <pre>
     * (Optional) Endpoint information of the remote server, such as IP address,
     * port number, and network protocol.
     * </pre>
     *
     * <code>.grpc.gcp.Endpoint remote_endpoint = 7;</code>
     */
    public io.grpc.alts.internal.Endpoint getRemoteEndpoint() {
      if (remoteEndpointBuilder_ == null) {
        return remoteEndpoint_ == null ? io.grpc.alts.internal.Endpoint.getDefaultInstance() : remoteEndpoint_;
      } else {
        return remoteEndpointBuilder_.getMessage();
      }
    }
    /**
     * <pre>
     * (Optional) Endpoint information of the remote server, such as IP address,
     * port number, and network protocol.
     * </pre>
     *
     * <code>.grpc.gcp.Endpoint remote_endpoint = 7;</code>
     */
    public Builder setRemoteEndpoint(io.grpc.alts.internal.Endpoint value) {
      if (remoteEndpointBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        remoteEndpoint_ = value;
        onChanged();
      } else {
        remoteEndpointBuilder_.setMessage(value);
      }

      return this;
    }
    /**
     * <pre>
     * (Optional) Endpoint information of the remote server, such as IP address,
     * port number, and network protocol.
     * </pre>
     *
     * <code>.grpc.gcp.Endpoint remote_endpoint = 7;</code>
     */
    public Builder setRemoteEndpoint(
        io.grpc.alts.internal.Endpoint.Builder builderForValue) {
      if (remoteEndpointBuilder_ == null) {
        remoteEndpoint_ = builderForValue.build();
        onChanged();
      } else {
        remoteEndpointBuilder_.setMessage(builderForValue.build());
      }

      return this;
    }
    /**
     * <pre>
     * (Optional) Endpoint information of the remote server, such as IP address,
     * port number, and network protocol.
     * </pre>
     *
     * <code>.grpc.gcp.Endpoint remote_endpoint = 7;</code>
     */
    public Builder mergeRemoteEndpoint(io.grpc.alts.internal.Endpoint value) {
      if (remoteEndpointBuilder_ == null) {
        if (remoteEndpoint_ != null) {
          remoteEndpoint_ =
            io.grpc.alts.internal.Endpoint.newBuilder(remoteEndpoint_).mergeFrom(value).buildPartial();
        } else {
          remoteEndpoint_ = value;
        }
        onChanged();
      } else {
        remoteEndpointBuilder_.mergeFrom(value);
      }

      return this;
    }
    /**
     * <pre>
     * (Optional) Endpoint information of the remote server, such as IP address,
     * port number, and network protocol.
     * </pre>
     *
     * <code>.grpc.gcp.Endpoint remote_endpoint = 7;</code>
     */
    public Builder clearRemoteEndpoint() {
      if (remoteEndpointBuilder_ == null) {
        remoteEndpoint_ = null;
        onChanged();
      } else {
        remoteEndpoint_ = null;
        remoteEndpointBuilder_ = null;
      }

      return this;
    }
    /**
     * <pre>
     * (Optional) Endpoint information of the remote server, such as IP address,
     * port number, and network protocol.
     * </pre>
     *
     * <code>.grpc.gcp.Endpoint remote_endpoint = 7;</code>
     */
    public io.grpc.alts.internal.Endpoint.Builder getRemoteEndpointBuilder() {
      
      onChanged();
      return getRemoteEndpointFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * (Optional) Endpoint information of the remote server, such as IP address,
     * port number, and network protocol.
     * </pre>
     *
     * <code>.grpc.gcp.Endpoint remote_endpoint = 7;</code>
     */
    public io.grpc.alts.internal.EndpointOrBuilder getRemoteEndpointOrBuilder() {
      if (remoteEndpointBuilder_ != null) {
        return remoteEndpointBuilder_.getMessageOrBuilder();
      } else {
        return remoteEndpoint_ == null ?
            io.grpc.alts.internal.Endpoint.getDefaultInstance() : remoteEndpoint_;
      }
    }
    /**
     * <pre>
     * (Optional) Endpoint information of the remote server, such as IP address,
     * port number, and network protocol.
     * </pre>
     *
     * <code>.grpc.gcp.Endpoint remote_endpoint = 7;</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        io.grpc.alts.internal.Endpoint, io.grpc.alts.internal.Endpoint.Builder, io.grpc.alts.internal.EndpointOrBuilder> 
        getRemoteEndpointFieldBuilder() {
      if (remoteEndpointBuilder_ == null) {
        remoteEndpointBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            io.grpc.alts.internal.Endpoint, io.grpc.alts.internal.Endpoint.Builder, io.grpc.alts.internal.EndpointOrBuilder>(
                getRemoteEndpoint(),
                getParentForChildren(),
                isClean());
        remoteEndpoint_ = null;
      }
      return remoteEndpointBuilder_;
    }

    private java.lang.Object targetName_ = "";
    /**
     * <pre>
     * (Optional) If target name is provided, a secure naming check is performed
     * to verify that the peer authenticated identity is indeed authorized to run
     * the target name.
     * </pre>
     *
     * <code>string target_name = 8;</code>
     */
    public java.lang.String getTargetName() {
      java.lang.Object ref = targetName_;
      if (!(ref instanceof java.lang.String)) {
        com.google.protobuf.ByteString bs =
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        targetName_ = s;
        return s;
      } else {
        return (java.lang.String) ref;
      }
    }
    /**
     * <pre>
     * (Optional) If target name is provided, a secure naming check is performed
     * to verify that the peer authenticated identity is indeed authorized to run
     * the target name.
     * </pre>
     *
     * <code>string target_name = 8;</code>
     */
    public com.google.protobuf.ByteString
        getTargetNameBytes() {
      java.lang.Object ref = targetName_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        targetName_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }
    /**
     * <pre>
     * (Optional) If target name is provided, a secure naming check is performed
     * to verify that the peer authenticated identity is indeed authorized to run
     * the target name.
     * </pre>
     *
     * <code>string target_name = 8;</code>
     */
    public Builder setTargetName(
        java.lang.String value) {
      if (value == null) {
    throw new NullPointerException();
  }
  
      targetName_ = value;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * (Optional) If target name is provided, a secure naming check is performed
     * to verify that the peer authenticated identity is indeed authorized to run
     * the target name.
     * </pre>
     *
     * <code>string target_name = 8;</code>
     */
    public Builder clearTargetName() {
      
      targetName_ = getDefaultInstance().getTargetName();
      onChanged();
      return this;
    }
    /**
     * <pre>
     * (Optional) If target name is provided, a secure naming check is performed
     * to verify that the peer authenticated identity is indeed authorized to run
     * the target name.
     * </pre>
     *
     * <code>string target_name = 8;</code>
     */
    public Builder setTargetNameBytes(
        com.google.protobuf.ByteString value) {
      if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
      
      targetName_ = value;
      onChanged();
      return this;
    }

    private io.grpc.alts.internal.RpcProtocolVersions rpcVersions_ = null;
    private com.google.protobuf.SingleFieldBuilderV3<
        io.grpc.alts.internal.RpcProtocolVersions, io.grpc.alts.internal.RpcProtocolVersions.Builder, io.grpc.alts.internal.RpcProtocolVersionsOrBuilder> rpcVersionsBuilder_;
    /**
     * <pre>
     * (Optional) RPC protocol versions supported by the client.
     * </pre>
     *
     * <code>.grpc.gcp.RpcProtocolVersions rpc_versions = 9;</code>
     */
    public boolean hasRpcVersions() {
      return rpcVersionsBuilder_ != null || rpcVersions_ != null;
    }
    /**
     * <pre>
     * (Optional) RPC protocol versions supported by the client.
     * </pre>
     *
     * <code>.grpc.gcp.RpcProtocolVersions rpc_versions = 9;</code>
     */
    public io.grpc.alts.internal.RpcProtocolVersions getRpcVersions() {
      if (rpcVersionsBuilder_ == null) {
        return rpcVersions_ == null ? io.grpc.alts.internal.RpcProtocolVersions.getDefaultInstance() : rpcVersions_;
      } else {
        return rpcVersionsBuilder_.getMessage();
      }
    }
    /**
     * <pre>
     * (Optional) RPC protocol versions supported by the client.
     * </pre>
     *
     * <code>.grpc.gcp.RpcProtocolVersions rpc_versions = 9;</code>
     */
    public Builder setRpcVersions(io.grpc.alts.internal.RpcProtocolVersions value) {
      if (rpcVersionsBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        rpcVersions_ = value;
        onChanged();
      } else {
        rpcVersionsBuilder_.setMessage(value);
      }

      return this;
    }
    /**
     * <pre>
     * (Optional) RPC protocol versions supported by the client.
     * </pre>
     *
     * <code>.grpc.gcp.RpcProtocolVersions rpc_versions = 9;</code>
     */
    public Builder setRpcVersions(
        io.grpc.alts.internal.RpcProtocolVersions.Builder builderForValue) {
      if (rpcVersionsBuilder_ == null) {
        rpcVersions_ = builderForValue.build();
        onChanged();
      } else {
        rpcVersionsBuilder_.setMessage(builderForValue.build());
      }

      return this;
    }
    /**
     * <pre>
     * (Optional) RPC protocol versions supported by the client.
     * </pre>
     *
     * <code>.grpc.gcp.RpcProtocolVersions rpc_versions = 9;</code>
     */
    public Builder mergeRpcVersions(io.grpc.alts.internal.RpcProtocolVersions value) {
      if (rpcVersionsBuilder_ == null) {
        if (rpcVersions_ != null) {
          rpcVersions_ =
            io.grpc.alts.internal.RpcProtocolVersions.newBuilder(rpcVersions_).mergeFrom(value).buildPartial();
        } else {
          rpcVersions_ = value;
        }
        onChanged();
      } else {
        rpcVersionsBuilder_.mergeFrom(value);
      }

      return this;
    }
    /**
     * <pre>
     * (Optional) RPC protocol versions supported by the client.
     * </pre>
     *
     * <code>.grpc.gcp.RpcProtocolVersions rpc_versions = 9;</code>
     */
    public Builder clearRpcVersions() {
      if (rpcVersionsBuilder_ == null) {
        rpcVersions_ = null;
        onChanged();
      } else {
        rpcVersions_ = null;
        rpcVersionsBuilder_ = null;
      }

      return this;
    }
    /**
     * <pre>
     * (Optional) RPC protocol versions supported by the client.
     * </pre>
     *
     * <code>.grpc.gcp.RpcProtocolVersions rpc_versions = 9;</code>
     */
    public io.grpc.alts.internal.RpcProtocolVersions.Builder getRpcVersionsBuilder() {
      
      onChanged();
      return getRpcVersionsFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * (Optional) RPC protocol versions supported by the client.
     * </pre>
     *
     * <code>.grpc.gcp.RpcProtocolVersions rpc_versions = 9;</code>
     */
    public io.grpc.alts.internal.RpcProtocolVersionsOrBuilder getRpcVersionsOrBuilder() {
      if (rpcVersionsBuilder_ != null) {
        return rpcVersionsBuilder_.getMessageOrBuilder();
      } else {
        return rpcVersions_ == null ?
            io.grpc.alts.internal.RpcProtocolVersions.getDefaultInstance() : rpcVersions_;
      }
    }
    /**
     * <pre>
     * (Optional) RPC protocol versions supported by the client.
     * </pre>
     *
     * <code>.grpc.gcp.RpcProtocolVersions rpc_versions = 9;</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        io.grpc.alts.internal.RpcProtocolVersions, io.grpc.alts.internal.RpcProtocolVersions.Builder, io.grpc.alts.internal.RpcProtocolVersionsOrBuilder> 
        getRpcVersionsFieldBuilder() {
      if (rpcVersionsBuilder_ == null) {
        rpcVersionsBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            io.grpc.alts.internal.RpcProtocolVersions, io.grpc.alts.internal.RpcProtocolVersions.Builder, io.grpc.alts.internal.RpcProtocolVersionsOrBuilder>(
                getRpcVersions(),
                getParentForChildren(),
                isClean());
        rpcVersions_ = null;
      }
      return rpcVersionsBuilder_;
    }
    @java.lang.Override
    public final Builder setUnknownFields(
        final com.google.protobuf.UnknownFieldSet unknownFields) {
      return super.setUnknownFieldsProto3(unknownFields);
    }

    @java.lang.Override
    public final Builder mergeUnknownFields(
        final com.google.protobuf.UnknownFieldSet unknownFields) {
      return super.mergeUnknownFields(unknownFields);
    }


    // @@protoc_insertion_point(builder_scope:grpc.gcp.StartClientHandshakeReq)
  }

  // @@protoc_insertion_point(class_scope:grpc.gcp.StartClientHandshakeReq)
  private static final io.grpc.alts.internal.StartClientHandshakeReq DEFAULT_INSTANCE;
  static {
    DEFAULT_INSTANCE = new io.grpc.alts.internal.StartClientHandshakeReq();
  }

  public static io.grpc.alts.internal.StartClientHandshakeReq getDefaultInstance() {
    return DEFAULT_INSTANCE;
  }

  private static final com.google.protobuf.Parser<StartClientHandshakeReq>
      PARSER = new com.google.protobuf.AbstractParser<StartClientHandshakeReq>() {
    @java.lang.Override
    public StartClientHandshakeReq parsePartialFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return new StartClientHandshakeReq(input, extensionRegistry);
    }
  };

  public static com.google.protobuf.Parser<StartClientHandshakeReq> parser() {
    return PARSER;
  }

  @java.lang.Override
  public com.google.protobuf.Parser<StartClientHandshakeReq> getParserForType() {
    return PARSER;
  }

  @java.lang.Override
  public io.grpc.alts.internal.StartClientHandshakeReq getDefaultInstanceForType() {
    return DEFAULT_INSTANCE;
  }

}

