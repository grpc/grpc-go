// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: grpc/gcp/handshaker.proto

package io.grpc.alts.internal;

/**
 * Protobuf type {@code grpc.gcp.StartServerHandshakeReq}
 */
public  final class StartServerHandshakeReq extends
    com.google.protobuf.GeneratedMessageV3 implements
    // @@protoc_insertion_point(message_implements:grpc.gcp.StartServerHandshakeReq)
    StartServerHandshakeReqOrBuilder {
private static final long serialVersionUID = 0L;
  // Use StartServerHandshakeReq.newBuilder() to construct.
  private StartServerHandshakeReq(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
    super(builder);
  }
  private StartServerHandshakeReq() {
    applicationProtocols_ = com.google.protobuf.LazyStringArrayList.EMPTY;
    inBytes_ = com.google.protobuf.ByteString.EMPTY;
  }

  @java.lang.Override
  public final com.google.protobuf.UnknownFieldSet
  getUnknownFields() {
    return this.unknownFields;
  }
  private StartServerHandshakeReq(
      com.google.protobuf.CodedInputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    this();
    if (extensionRegistry == null) {
      throw new java.lang.NullPointerException();
    }
    int mutable_bitField0_ = 0;
    com.google.protobuf.UnknownFieldSet.Builder unknownFields =
        com.google.protobuf.UnknownFieldSet.newBuilder();
    try {
      boolean done = false;
      while (!done) {
        int tag = input.readTag();
        switch (tag) {
          case 0:
            done = true;
            break;
          case 10: {
            java.lang.String s = input.readStringRequireUtf8();
            if (!((mutable_bitField0_ & 0x00000001) == 0x00000001)) {
              applicationProtocols_ = new com.google.protobuf.LazyStringArrayList();
              mutable_bitField0_ |= 0x00000001;
            }
            applicationProtocols_.add(s);
            break;
          }
          case 18: {
            if (!((mutable_bitField0_ & 0x00000002) == 0x00000002)) {
              handshakeParameters_ = com.google.protobuf.MapField.newMapField(
                  HandshakeParametersDefaultEntryHolder.defaultEntry);
              mutable_bitField0_ |= 0x00000002;
            }
            com.google.protobuf.MapEntry<java.lang.Integer, io.grpc.alts.internal.ServerHandshakeParameters>
            handshakeParameters__ = input.readMessage(
                HandshakeParametersDefaultEntryHolder.defaultEntry.getParserForType(), extensionRegistry);
            handshakeParameters_.getMutableMap().put(
                handshakeParameters__.getKey(), handshakeParameters__.getValue());
            break;
          }
          case 26: {

            inBytes_ = input.readBytes();
            break;
          }
          case 34: {
            io.grpc.alts.internal.Endpoint.Builder subBuilder = null;
            if (localEndpoint_ != null) {
              subBuilder = localEndpoint_.toBuilder();
            }
            localEndpoint_ = input.readMessage(io.grpc.alts.internal.Endpoint.parser(), extensionRegistry);
            if (subBuilder != null) {
              subBuilder.mergeFrom(localEndpoint_);
              localEndpoint_ = subBuilder.buildPartial();
            }

            break;
          }
          case 42: {
            io.grpc.alts.internal.Endpoint.Builder subBuilder = null;
            if (remoteEndpoint_ != null) {
              subBuilder = remoteEndpoint_.toBuilder();
            }
            remoteEndpoint_ = input.readMessage(io.grpc.alts.internal.Endpoint.parser(), extensionRegistry);
            if (subBuilder != null) {
              subBuilder.mergeFrom(remoteEndpoint_);
              remoteEndpoint_ = subBuilder.buildPartial();
            }

            break;
          }
          case 50: {
            io.grpc.alts.internal.RpcProtocolVersions.Builder subBuilder = null;
            if (rpcVersions_ != null) {
              subBuilder = rpcVersions_.toBuilder();
            }
            rpcVersions_ = input.readMessage(io.grpc.alts.internal.RpcProtocolVersions.parser(), extensionRegistry);
            if (subBuilder != null) {
              subBuilder.mergeFrom(rpcVersions_);
              rpcVersions_ = subBuilder.buildPartial();
            }

            break;
          }
          default: {
            if (!parseUnknownFieldProto3(
                input, unknownFields, extensionRegistry, tag)) {
              done = true;
            }
            break;
          }
        }
      }
    } catch (com.google.protobuf.InvalidProtocolBufferException e) {
      throw e.setUnfinishedMessage(this);
    } catch (java.io.IOException e) {
      throw new com.google.protobuf.InvalidProtocolBufferException(
          e).setUnfinishedMessage(this);
    } finally {
      if (((mutable_bitField0_ & 0x00000001) == 0x00000001)) {
        applicationProtocols_ = applicationProtocols_.getUnmodifiableView();
      }
      this.unknownFields = unknownFields.build();
      makeExtensionsImmutable();
    }
  }
  public static final com.google.protobuf.Descriptors.Descriptor
      getDescriptor() {
    return io.grpc.alts.internal.HandshakerProto.internal_static_grpc_gcp_StartServerHandshakeReq_descriptor;
  }

  @SuppressWarnings({"rawtypes"})
  @java.lang.Override
  protected com.google.protobuf.MapField internalGetMapField(
      int number) {
    switch (number) {
      case 2:
        return internalGetHandshakeParameters();
      default:
        throw new RuntimeException(
            "Invalid map field number: " + number);
    }
  }
  @java.lang.Override
  protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internalGetFieldAccessorTable() {
    return io.grpc.alts.internal.HandshakerProto.internal_static_grpc_gcp_StartServerHandshakeReq_fieldAccessorTable
        .ensureFieldAccessorsInitialized(
            io.grpc.alts.internal.StartServerHandshakeReq.class, io.grpc.alts.internal.StartServerHandshakeReq.Builder.class);
  }

  private int bitField0_;
  public static final int APPLICATION_PROTOCOLS_FIELD_NUMBER = 1;
  private com.google.protobuf.LazyStringList applicationProtocols_;
  /**
   * <pre>
   * The application protocols supported by the server, e.g., "h2" (for http2),
   * "grpc".
   * </pre>
   *
   * <code>repeated string application_protocols = 1;</code>
   */
  public com.google.protobuf.ProtocolStringList
      getApplicationProtocolsList() {
    return applicationProtocols_;
  }
  /**
   * <pre>
   * The application protocols supported by the server, e.g., "h2" (for http2),
   * "grpc".
   * </pre>
   *
   * <code>repeated string application_protocols = 1;</code>
   */
  public int getApplicationProtocolsCount() {
    return applicationProtocols_.size();
  }
  /**
   * <pre>
   * The application protocols supported by the server, e.g., "h2" (for http2),
   * "grpc".
   * </pre>
   *
   * <code>repeated string application_protocols = 1;</code>
   */
  public java.lang.String getApplicationProtocols(int index) {
    return applicationProtocols_.get(index);
  }
  /**
   * <pre>
   * The application protocols supported by the server, e.g., "h2" (for http2),
   * "grpc".
   * </pre>
   *
   * <code>repeated string application_protocols = 1;</code>
   */
  public com.google.protobuf.ByteString
      getApplicationProtocolsBytes(int index) {
    return applicationProtocols_.getByteString(index);
  }

  public static final int HANDSHAKE_PARAMETERS_FIELD_NUMBER = 2;
  private static final class HandshakeParametersDefaultEntryHolder {
    static final com.google.protobuf.MapEntry<
        java.lang.Integer, io.grpc.alts.internal.ServerHandshakeParameters> defaultEntry =
            com.google.protobuf.MapEntry
            .<java.lang.Integer, io.grpc.alts.internal.ServerHandshakeParameters>newDefaultInstance(
                io.grpc.alts.internal.HandshakerProto.internal_static_grpc_gcp_StartServerHandshakeReq_HandshakeParametersEntry_descriptor, 
                com.google.protobuf.WireFormat.FieldType.INT32,
                0,
                com.google.protobuf.WireFormat.FieldType.MESSAGE,
                io.grpc.alts.internal.ServerHandshakeParameters.getDefaultInstance());
  }
  private com.google.protobuf.MapField<
      java.lang.Integer, io.grpc.alts.internal.ServerHandshakeParameters> handshakeParameters_;
  private com.google.protobuf.MapField<java.lang.Integer, io.grpc.alts.internal.ServerHandshakeParameters>
  internalGetHandshakeParameters() {
    if (handshakeParameters_ == null) {
      return com.google.protobuf.MapField.emptyMapField(
          HandshakeParametersDefaultEntryHolder.defaultEntry);
    }
    return handshakeParameters_;
  }

  public int getHandshakeParametersCount() {
    return internalGetHandshakeParameters().getMap().size();
  }
  /**
   * <pre>
   * Handshake parameters (record protocols and local identities supported by
   * the server) mapped by the handshake protocol. Each handshake security
   * protocol (e.g., TLS or ALTS) has its own set of record protocols and local
   * identities. Since protobuf does not support enum as key to the map, the key
   * to handshake_parameters is the integer value of HandshakeProtocol enum.
   * </pre>
   *
   * <code>map&lt;int32, .grpc.gcp.ServerHandshakeParameters&gt; handshake_parameters = 2;</code>
   */

  public boolean containsHandshakeParameters(
      int key) {
    
    return internalGetHandshakeParameters().getMap().containsKey(key);
  }
  /**
   * Use {@link #getHandshakeParametersMap()} instead.
   */
  @java.lang.Deprecated
  public java.util.Map<java.lang.Integer, io.grpc.alts.internal.ServerHandshakeParameters> getHandshakeParameters() {
    return getHandshakeParametersMap();
  }
  /**
   * <pre>
   * Handshake parameters (record protocols and local identities supported by
   * the server) mapped by the handshake protocol. Each handshake security
   * protocol (e.g., TLS or ALTS) has its own set of record protocols and local
   * identities. Since protobuf does not support enum as key to the map, the key
   * to handshake_parameters is the integer value of HandshakeProtocol enum.
   * </pre>
   *
   * <code>map&lt;int32, .grpc.gcp.ServerHandshakeParameters&gt; handshake_parameters = 2;</code>
   */

  public java.util.Map<java.lang.Integer, io.grpc.alts.internal.ServerHandshakeParameters> getHandshakeParametersMap() {
    return internalGetHandshakeParameters().getMap();
  }
  /**
   * <pre>
   * Handshake parameters (record protocols and local identities supported by
   * the server) mapped by the handshake protocol. Each handshake security
   * protocol (e.g., TLS or ALTS) has its own set of record protocols and local
   * identities. Since protobuf does not support enum as key to the map, the key
   * to handshake_parameters is the integer value of HandshakeProtocol enum.
   * </pre>
   *
   * <code>map&lt;int32, .grpc.gcp.ServerHandshakeParameters&gt; handshake_parameters = 2;</code>
   */

  public io.grpc.alts.internal.ServerHandshakeParameters getHandshakeParametersOrDefault(
      int key,
      io.grpc.alts.internal.ServerHandshakeParameters defaultValue) {
    
    java.util.Map<java.lang.Integer, io.grpc.alts.internal.ServerHandshakeParameters> map =
        internalGetHandshakeParameters().getMap();
    return map.containsKey(key) ? map.get(key) : defaultValue;
  }
  /**
   * <pre>
   * Handshake parameters (record protocols and local identities supported by
   * the server) mapped by the handshake protocol. Each handshake security
   * protocol (e.g., TLS or ALTS) has its own set of record protocols and local
   * identities. Since protobuf does not support enum as key to the map, the key
   * to handshake_parameters is the integer value of HandshakeProtocol enum.
   * </pre>
   *
   * <code>map&lt;int32, .grpc.gcp.ServerHandshakeParameters&gt; handshake_parameters = 2;</code>
   */

  public io.grpc.alts.internal.ServerHandshakeParameters getHandshakeParametersOrThrow(
      int key) {
    
    java.util.Map<java.lang.Integer, io.grpc.alts.internal.ServerHandshakeParameters> map =
        internalGetHandshakeParameters().getMap();
    if (!map.containsKey(key)) {
      throw new java.lang.IllegalArgumentException();
    }
    return map.get(key);
  }

  public static final int IN_BYTES_FIELD_NUMBER = 3;
  private com.google.protobuf.ByteString inBytes_;
  /**
   * <pre>
   * Bytes in out_frames returned from the peer's HandshakerResp. It is possible
   * that the peer's out_frames are split into multiple HandshakReq messages.
   * </pre>
   *
   * <code>bytes in_bytes = 3;</code>
   */
  public com.google.protobuf.ByteString getInBytes() {
    return inBytes_;
  }

  public static final int LOCAL_ENDPOINT_FIELD_NUMBER = 4;
  private io.grpc.alts.internal.Endpoint localEndpoint_;
  /**
   * <pre>
   * (Optional) Local endpoint information of the connection to the client,
   * such as local IP address, port number, and network protocol.
   * </pre>
   *
   * <code>.grpc.gcp.Endpoint local_endpoint = 4;</code>
   */
  public boolean hasLocalEndpoint() {
    return localEndpoint_ != null;
  }
  /**
   * <pre>
   * (Optional) Local endpoint information of the connection to the client,
   * such as local IP address, port number, and network protocol.
   * </pre>
   *
   * <code>.grpc.gcp.Endpoint local_endpoint = 4;</code>
   */
  public io.grpc.alts.internal.Endpoint getLocalEndpoint() {
    return localEndpoint_ == null ? io.grpc.alts.internal.Endpoint.getDefaultInstance() : localEndpoint_;
  }
  /**
   * <pre>
   * (Optional) Local endpoint information of the connection to the client,
   * such as local IP address, port number, and network protocol.
   * </pre>
   *
   * <code>.grpc.gcp.Endpoint local_endpoint = 4;</code>
   */
  public io.grpc.alts.internal.EndpointOrBuilder getLocalEndpointOrBuilder() {
    return getLocalEndpoint();
  }

  public static final int REMOTE_ENDPOINT_FIELD_NUMBER = 5;
  private io.grpc.alts.internal.Endpoint remoteEndpoint_;
  /**
   * <pre>
   * (Optional) Endpoint information of the remote client, such as IP address,
   * port number, and network protocol.
   * </pre>
   *
   * <code>.grpc.gcp.Endpoint remote_endpoint = 5;</code>
   */
  public boolean hasRemoteEndpoint() {
    return remoteEndpoint_ != null;
  }
  /**
   * <pre>
   * (Optional) Endpoint information of the remote client, such as IP address,
   * port number, and network protocol.
   * </pre>
   *
   * <code>.grpc.gcp.Endpoint remote_endpoint = 5;</code>
   */
  public io.grpc.alts.internal.Endpoint getRemoteEndpoint() {
    return remoteEndpoint_ == null ? io.grpc.alts.internal.Endpoint.getDefaultInstance() : remoteEndpoint_;
  }
  /**
   * <pre>
   * (Optional) Endpoint information of the remote client, such as IP address,
   * port number, and network protocol.
   * </pre>
   *
   * <code>.grpc.gcp.Endpoint remote_endpoint = 5;</code>
   */
  public io.grpc.alts.internal.EndpointOrBuilder getRemoteEndpointOrBuilder() {
    return getRemoteEndpoint();
  }

  public static final int RPC_VERSIONS_FIELD_NUMBER = 6;
  private io.grpc.alts.internal.RpcProtocolVersions rpcVersions_;
  /**
   * <pre>
   * (Optional) RPC protocol versions supported by the server.
   * </pre>
   *
   * <code>.grpc.gcp.RpcProtocolVersions rpc_versions = 6;</code>
   */
  public boolean hasRpcVersions() {
    return rpcVersions_ != null;
  }
  /**
   * <pre>
   * (Optional) RPC protocol versions supported by the server.
   * </pre>
   *
   * <code>.grpc.gcp.RpcProtocolVersions rpc_versions = 6;</code>
   */
  public io.grpc.alts.internal.RpcProtocolVersions getRpcVersions() {
    return rpcVersions_ == null ? io.grpc.alts.internal.RpcProtocolVersions.getDefaultInstance() : rpcVersions_;
  }
  /**
   * <pre>
   * (Optional) RPC protocol versions supported by the server.
   * </pre>
   *
   * <code>.grpc.gcp.RpcProtocolVersions rpc_versions = 6;</code>
   */
  public io.grpc.alts.internal.RpcProtocolVersionsOrBuilder getRpcVersionsOrBuilder() {
    return getRpcVersions();
  }

  private byte memoizedIsInitialized = -1;
  @java.lang.Override
  public final boolean isInitialized() {
    byte isInitialized = memoizedIsInitialized;
    if (isInitialized == 1) return true;
    if (isInitialized == 0) return false;

    memoizedIsInitialized = 1;
    return true;
  }

  @java.lang.Override
  public void writeTo(com.google.protobuf.CodedOutputStream output)
                      throws java.io.IOException {
    for (int i = 0; i < applicationProtocols_.size(); i++) {
      com.google.protobuf.GeneratedMessageV3.writeString(output, 1, applicationProtocols_.getRaw(i));
    }
    com.google.protobuf.GeneratedMessageV3
      .serializeIntegerMapTo(
        output,
        internalGetHandshakeParameters(),
        HandshakeParametersDefaultEntryHolder.defaultEntry,
        2);
    if (!inBytes_.isEmpty()) {
      output.writeBytes(3, inBytes_);
    }
    if (localEndpoint_ != null) {
      output.writeMessage(4, getLocalEndpoint());
    }
    if (remoteEndpoint_ != null) {
      output.writeMessage(5, getRemoteEndpoint());
    }
    if (rpcVersions_ != null) {
      output.writeMessage(6, getRpcVersions());
    }
    unknownFields.writeTo(output);
  }

  @java.lang.Override
  public int getSerializedSize() {
    int size = memoizedSize;
    if (size != -1) return size;

    size = 0;
    {
      int dataSize = 0;
      for (int i = 0; i < applicationProtocols_.size(); i++) {
        dataSize += computeStringSizeNoTag(applicationProtocols_.getRaw(i));
      }
      size += dataSize;
      size += 1 * getApplicationProtocolsList().size();
    }
    for (java.util.Map.Entry<java.lang.Integer, io.grpc.alts.internal.ServerHandshakeParameters> entry
         : internalGetHandshakeParameters().getMap().entrySet()) {
      com.google.protobuf.MapEntry<java.lang.Integer, io.grpc.alts.internal.ServerHandshakeParameters>
      handshakeParameters__ = HandshakeParametersDefaultEntryHolder.defaultEntry.newBuilderForType()
          .setKey(entry.getKey())
          .setValue(entry.getValue())
          .build();
      size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, handshakeParameters__);
    }
    if (!inBytes_.isEmpty()) {
      size += com.google.protobuf.CodedOutputStream
        .computeBytesSize(3, inBytes_);
    }
    if (localEndpoint_ != null) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(4, getLocalEndpoint());
    }
    if (remoteEndpoint_ != null) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(5, getRemoteEndpoint());
    }
    if (rpcVersions_ != null) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(6, getRpcVersions());
    }
    size += unknownFields.getSerializedSize();
    memoizedSize = size;
    return size;
  }

  @java.lang.Override
  public boolean equals(final java.lang.Object obj) {
    if (obj == this) {
     return true;
    }
    if (!(obj instanceof io.grpc.alts.internal.StartServerHandshakeReq)) {
      return super.equals(obj);
    }
    io.grpc.alts.internal.StartServerHandshakeReq other = (io.grpc.alts.internal.StartServerHandshakeReq) obj;

    boolean result = true;
    result = result && getApplicationProtocolsList()
        .equals(other.getApplicationProtocolsList());
    result = result && internalGetHandshakeParameters().equals(
        other.internalGetHandshakeParameters());
    result = result && getInBytes()
        .equals(other.getInBytes());
    result = result && (hasLocalEndpoint() == other.hasLocalEndpoint());
    if (hasLocalEndpoint()) {
      result = result && getLocalEndpoint()
          .equals(other.getLocalEndpoint());
    }
    result = result && (hasRemoteEndpoint() == other.hasRemoteEndpoint());
    if (hasRemoteEndpoint()) {
      result = result && getRemoteEndpoint()
          .equals(other.getRemoteEndpoint());
    }
    result = result && (hasRpcVersions() == other.hasRpcVersions());
    if (hasRpcVersions()) {
      result = result && getRpcVersions()
          .equals(other.getRpcVersions());
    }
    result = result && unknownFields.equals(other.unknownFields);
    return result;
  }

  @java.lang.Override
  public int hashCode() {
    if (memoizedHashCode != 0) {
      return memoizedHashCode;
    }
    int hash = 41;
    hash = (19 * hash) + getDescriptor().hashCode();
    if (getApplicationProtocolsCount() > 0) {
      hash = (37 * hash) + APPLICATION_PROTOCOLS_FIELD_NUMBER;
      hash = (53 * hash) + getApplicationProtocolsList().hashCode();
    }
    if (!internalGetHandshakeParameters().getMap().isEmpty()) {
      hash = (37 * hash) + HANDSHAKE_PARAMETERS_FIELD_NUMBER;
      hash = (53 * hash) + internalGetHandshakeParameters().hashCode();
    }
    hash = (37 * hash) + IN_BYTES_FIELD_NUMBER;
    hash = (53 * hash) + getInBytes().hashCode();
    if (hasLocalEndpoint()) {
      hash = (37 * hash) + LOCAL_ENDPOINT_FIELD_NUMBER;
      hash = (53 * hash) + getLocalEndpoint().hashCode();
    }
    if (hasRemoteEndpoint()) {
      hash = (37 * hash) + REMOTE_ENDPOINT_FIELD_NUMBER;
      hash = (53 * hash) + getRemoteEndpoint().hashCode();
    }
    if (hasRpcVersions()) {
      hash = (37 * hash) + RPC_VERSIONS_FIELD_NUMBER;
      hash = (53 * hash) + getRpcVersions().hashCode();
    }
    hash = (29 * hash) + unknownFields.hashCode();
    memoizedHashCode = hash;
    return hash;
  }

  public static io.grpc.alts.internal.StartServerHandshakeReq parseFrom(
      java.nio.ByteBuffer data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data);
  }
  public static io.grpc.alts.internal.StartServerHandshakeReq parseFrom(
      java.nio.ByteBuffer data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data, extensionRegistry);
  }
  public static io.grpc.alts.internal.StartServerHandshakeReq parseFrom(
      com.google.protobuf.ByteString data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data);
  }
  public static io.grpc.alts.internal.StartServerHandshakeReq parseFrom(
      com.google.protobuf.ByteString data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data, extensionRegistry);
  }
  public static io.grpc.alts.internal.StartServerHandshakeReq parseFrom(byte[] data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data);
  }
  public static io.grpc.alts.internal.StartServerHandshakeReq parseFrom(
      byte[] data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data, extensionRegistry);
  }
  public static io.grpc.alts.internal.StartServerHandshakeReq parseFrom(java.io.InputStream input)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3
        .parseWithIOException(PARSER, input);
  }
  public static io.grpc.alts.internal.StartServerHandshakeReq parseFrom(
      java.io.InputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3
        .parseWithIOException(PARSER, input, extensionRegistry);
  }
  public static io.grpc.alts.internal.StartServerHandshakeReq parseDelimitedFrom(java.io.InputStream input)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3
        .parseDelimitedWithIOException(PARSER, input);
  }
  public static io.grpc.alts.internal.StartServerHandshakeReq parseDelimitedFrom(
      java.io.InputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3
        .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
  }
  public static io.grpc.alts.internal.StartServerHandshakeReq parseFrom(
      com.google.protobuf.CodedInputStream input)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3
        .parseWithIOException(PARSER, input);
  }
  public static io.grpc.alts.internal.StartServerHandshakeReq parseFrom(
      com.google.protobuf.CodedInputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3
        .parseWithIOException(PARSER, input, extensionRegistry);
  }

  @java.lang.Override
  public Builder newBuilderForType() { return newBuilder(); }
  public static Builder newBuilder() {
    return DEFAULT_INSTANCE.toBuilder();
  }
  public static Builder newBuilder(io.grpc.alts.internal.StartServerHandshakeReq prototype) {
    return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
  }
  @java.lang.Override
  public Builder toBuilder() {
    return this == DEFAULT_INSTANCE
        ? new Builder() : new Builder().mergeFrom(this);
  }

  @java.lang.Override
  protected Builder newBuilderForType(
      com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
    Builder builder = new Builder(parent);
    return builder;
  }
  /**
   * Protobuf type {@code grpc.gcp.StartServerHandshakeReq}
   */
  public static final class Builder extends
      com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
      // @@protoc_insertion_point(builder_implements:grpc.gcp.StartServerHandshakeReq)
      io.grpc.alts.internal.StartServerHandshakeReqOrBuilder {
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.grpc.alts.internal.HandshakerProto.internal_static_grpc_gcp_StartServerHandshakeReq_descriptor;
    }

    @SuppressWarnings({"rawtypes"})
    protected com.google.protobuf.MapField internalGetMapField(
        int number) {
      switch (number) {
        case 2:
          return internalGetHandshakeParameters();
        default:
          throw new RuntimeException(
              "Invalid map field number: " + number);
      }
    }
    @SuppressWarnings({"rawtypes"})
    protected com.google.protobuf.MapField internalGetMutableMapField(
        int number) {
      switch (number) {
        case 2:
          return internalGetMutableHandshakeParameters();
        default:
          throw new RuntimeException(
              "Invalid map field number: " + number);
      }
    }
    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.grpc.alts.internal.HandshakerProto.internal_static_grpc_gcp_StartServerHandshakeReq_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.grpc.alts.internal.StartServerHandshakeReq.class, io.grpc.alts.internal.StartServerHandshakeReq.Builder.class);
    }

    // Construct using io.grpc.alts.internal.StartServerHandshakeReq.newBuilder()
    private Builder() {
      maybeForceBuilderInitialization();
    }

    private Builder(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      super(parent);
      maybeForceBuilderInitialization();
    }
    private void maybeForceBuilderInitialization() {
      if (com.google.protobuf.GeneratedMessageV3
              .alwaysUseFieldBuilders) {
      }
    }
    @java.lang.Override
    public Builder clear() {
      super.clear();
      applicationProtocols_ = com.google.protobuf.LazyStringArrayList.EMPTY;
      bitField0_ = (bitField0_ & ~0x00000001);
      internalGetMutableHandshakeParameters().clear();
      inBytes_ = com.google.protobuf.ByteString.EMPTY;

      if (localEndpointBuilder_ == null) {
        localEndpoint_ = null;
      } else {
        localEndpoint_ = null;
        localEndpointBuilder_ = null;
      }
      if (remoteEndpointBuilder_ == null) {
        remoteEndpoint_ = null;
      } else {
        remoteEndpoint_ = null;
        remoteEndpointBuilder_ = null;
      }
      if (rpcVersionsBuilder_ == null) {
        rpcVersions_ = null;
      } else {
        rpcVersions_ = null;
        rpcVersionsBuilder_ = null;
      }
      return this;
    }

    @java.lang.Override
    public com.google.protobuf.Descriptors.Descriptor
        getDescriptorForType() {
      return io.grpc.alts.internal.HandshakerProto.internal_static_grpc_gcp_StartServerHandshakeReq_descriptor;
    }

    @java.lang.Override
    public io.grpc.alts.internal.StartServerHandshakeReq getDefaultInstanceForType() {
      return io.grpc.alts.internal.StartServerHandshakeReq.getDefaultInstance();
    }

    @java.lang.Override
    public io.grpc.alts.internal.StartServerHandshakeReq build() {
      io.grpc.alts.internal.StartServerHandshakeReq result = buildPartial();
      if (!result.isInitialized()) {
        throw newUninitializedMessageException(result);
      }
      return result;
    }

    @java.lang.Override
    public io.grpc.alts.internal.StartServerHandshakeReq buildPartial() {
      io.grpc.alts.internal.StartServerHandshakeReq result = new io.grpc.alts.internal.StartServerHandshakeReq(this);
      int from_bitField0_ = bitField0_;
      int to_bitField0_ = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        applicationProtocols_ = applicationProtocols_.getUnmodifiableView();
        bitField0_ = (bitField0_ & ~0x00000001);
      }
      result.applicationProtocols_ = applicationProtocols_;
      result.handshakeParameters_ = internalGetHandshakeParameters();
      result.handshakeParameters_.makeImmutable();
      result.inBytes_ = inBytes_;
      if (localEndpointBuilder_ == null) {
        result.localEndpoint_ = localEndpoint_;
      } else {
        result.localEndpoint_ = localEndpointBuilder_.build();
      }
      if (remoteEndpointBuilder_ == null) {
        result.remoteEndpoint_ = remoteEndpoint_;
      } else {
        result.remoteEndpoint_ = remoteEndpointBuilder_.build();
      }
      if (rpcVersionsBuilder_ == null) {
        result.rpcVersions_ = rpcVersions_;
      } else {
        result.rpcVersions_ = rpcVersionsBuilder_.build();
      }
      result.bitField0_ = to_bitField0_;
      onBuilt();
      return result;
    }

    @java.lang.Override
    public Builder clone() {
      return (Builder) super.clone();
    }
    @java.lang.Override
    public Builder setField(
        com.google.protobuf.Descriptors.FieldDescriptor field,
        java.lang.Object value) {
      return (Builder) super.setField(field, value);
    }
    @java.lang.Override
    public Builder clearField(
        com.google.protobuf.Descriptors.FieldDescriptor field) {
      return (Builder) super.clearField(field);
    }
    @java.lang.Override
    public Builder clearOneof(
        com.google.protobuf.Descriptors.OneofDescriptor oneof) {
      return (Builder) super.clearOneof(oneof);
    }
    @java.lang.Override
    public Builder setRepeatedField(
        com.google.protobuf.Descriptors.FieldDescriptor field,
        int index, java.lang.Object value) {
      return (Builder) super.setRepeatedField(field, index, value);
    }
    @java.lang.Override
    public Builder addRepeatedField(
        com.google.protobuf.Descriptors.FieldDescriptor field,
        java.lang.Object value) {
      return (Builder) super.addRepeatedField(field, value);
    }
    @java.lang.Override
    public Builder mergeFrom(com.google.protobuf.Message other) {
      if (other instanceof io.grpc.alts.internal.StartServerHandshakeReq) {
        return mergeFrom((io.grpc.alts.internal.StartServerHandshakeReq)other);
      } else {
        super.mergeFrom(other);
        return this;
      }
    }

    public Builder mergeFrom(io.grpc.alts.internal.StartServerHandshakeReq other) {
      if (other == io.grpc.alts.internal.StartServerHandshakeReq.getDefaultInstance()) return this;
      if (!other.applicationProtocols_.isEmpty()) {
        if (applicationProtocols_.isEmpty()) {
          applicationProtocols_ = other.applicationProtocols_;
          bitField0_ = (bitField0_ & ~0x00000001);
        } else {
          ensureApplicationProtocolsIsMutable();
          applicationProtocols_.addAll(other.applicationProtocols_);
        }
        onChanged();
      }
      internalGetMutableHandshakeParameters().mergeFrom(
          other.internalGetHandshakeParameters());
      if (other.getInBytes() != com.google.protobuf.ByteString.EMPTY) {
        setInBytes(other.getInBytes());
      }
      if (other.hasLocalEndpoint()) {
        mergeLocalEndpoint(other.getLocalEndpoint());
      }
      if (other.hasRemoteEndpoint()) {
        mergeRemoteEndpoint(other.getRemoteEndpoint());
      }
      if (other.hasRpcVersions()) {
        mergeRpcVersions(other.getRpcVersions());
      }
      this.mergeUnknownFields(other.unknownFields);
      onChanged();
      return this;
    }

    @java.lang.Override
    public final boolean isInitialized() {
      return true;
    }

    @java.lang.Override
    public Builder mergeFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      io.grpc.alts.internal.StartServerHandshakeReq parsedMessage = null;
      try {
        parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        parsedMessage = (io.grpc.alts.internal.StartServerHandshakeReq) e.getUnfinishedMessage();
        throw e.unwrapIOException();
      } finally {
        if (parsedMessage != null) {
          mergeFrom(parsedMessage);
        }
      }
      return this;
    }
    private int bitField0_;

    private com.google.protobuf.LazyStringList applicationProtocols_ = com.google.protobuf.LazyStringArrayList.EMPTY;
    private void ensureApplicationProtocolsIsMutable() {
      if (!((bitField0_ & 0x00000001) == 0x00000001)) {
        applicationProtocols_ = new com.google.protobuf.LazyStringArrayList(applicationProtocols_);
        bitField0_ |= 0x00000001;
       }
    }
    /**
     * <pre>
     * The application protocols supported by the server, e.g., "h2" (for http2),
     * "grpc".
     * </pre>
     *
     * <code>repeated string application_protocols = 1;</code>
     */
    public com.google.protobuf.ProtocolStringList
        getApplicationProtocolsList() {
      return applicationProtocols_.getUnmodifiableView();
    }
    /**
     * <pre>
     * The application protocols supported by the server, e.g., "h2" (for http2),
     * "grpc".
     * </pre>
     *
     * <code>repeated string application_protocols = 1;</code>
     */
    public int getApplicationProtocolsCount() {
      return applicationProtocols_.size();
    }
    /**
     * <pre>
     * The application protocols supported by the server, e.g., "h2" (for http2),
     * "grpc".
     * </pre>
     *
     * <code>repeated string application_protocols = 1;</code>
     */
    public java.lang.String getApplicationProtocols(int index) {
      return applicationProtocols_.get(index);
    }
    /**
     * <pre>
     * The application protocols supported by the server, e.g., "h2" (for http2),
     * "grpc".
     * </pre>
     *
     * <code>repeated string application_protocols = 1;</code>
     */
    public com.google.protobuf.ByteString
        getApplicationProtocolsBytes(int index) {
      return applicationProtocols_.getByteString(index);
    }
    /**
     * <pre>
     * The application protocols supported by the server, e.g., "h2" (for http2),
     * "grpc".
     * </pre>
     *
     * <code>repeated string application_protocols = 1;</code>
     */
    public Builder setApplicationProtocols(
        int index, java.lang.String value) {
      if (value == null) {
    throw new NullPointerException();
  }
  ensureApplicationProtocolsIsMutable();
      applicationProtocols_.set(index, value);
      onChanged();
      return this;
    }
    /**
     * <pre>
     * The application protocols supported by the server, e.g., "h2" (for http2),
     * "grpc".
     * </pre>
     *
     * <code>repeated string application_protocols = 1;</code>
     */
    public Builder addApplicationProtocols(
        java.lang.String value) {
      if (value == null) {
    throw new NullPointerException();
  }
  ensureApplicationProtocolsIsMutable();
      applicationProtocols_.add(value);
      onChanged();
      return this;
    }
    /**
     * <pre>
     * The application protocols supported by the server, e.g., "h2" (for http2),
     * "grpc".
     * </pre>
     *
     * <code>repeated string application_protocols = 1;</code>
     */
    public Builder addAllApplicationProtocols(
        java.lang.Iterable<java.lang.String> values) {
      ensureApplicationProtocolsIsMutable();
      com.google.protobuf.AbstractMessageLite.Builder.addAll(
          values, applicationProtocols_);
      onChanged();
      return this;
    }
    /**
     * <pre>
     * The application protocols supported by the server, e.g., "h2" (for http2),
     * "grpc".
     * </pre>
     *
     * <code>repeated string application_protocols = 1;</code>
     */
    public Builder clearApplicationProtocols() {
      applicationProtocols_ = com.google.protobuf.LazyStringArrayList.EMPTY;
      bitField0_ = (bitField0_ & ~0x00000001);
      onChanged();
      return this;
    }
    /**
     * <pre>
     * The application protocols supported by the server, e.g., "h2" (for http2),
     * "grpc".
     * </pre>
     *
     * <code>repeated string application_protocols = 1;</code>
     */
    public Builder addApplicationProtocolsBytes(
        com.google.protobuf.ByteString value) {
      if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
      ensureApplicationProtocolsIsMutable();
      applicationProtocols_.add(value);
      onChanged();
      return this;
    }

    private com.google.protobuf.MapField<
        java.lang.Integer, io.grpc.alts.internal.ServerHandshakeParameters> handshakeParameters_;
    private com.google.protobuf.MapField<java.lang.Integer, io.grpc.alts.internal.ServerHandshakeParameters>
    internalGetHandshakeParameters() {
      if (handshakeParameters_ == null) {
        return com.google.protobuf.MapField.emptyMapField(
            HandshakeParametersDefaultEntryHolder.defaultEntry);
      }
      return handshakeParameters_;
    }
    private com.google.protobuf.MapField<java.lang.Integer, io.grpc.alts.internal.ServerHandshakeParameters>
    internalGetMutableHandshakeParameters() {
      onChanged();;
      if (handshakeParameters_ == null) {
        handshakeParameters_ = com.google.protobuf.MapField.newMapField(
            HandshakeParametersDefaultEntryHolder.defaultEntry);
      }
      if (!handshakeParameters_.isMutable()) {
        handshakeParameters_ = handshakeParameters_.copy();
      }
      return handshakeParameters_;
    }

    public int getHandshakeParametersCount() {
      return internalGetHandshakeParameters().getMap().size();
    }
    /**
     * <pre>
     * Handshake parameters (record protocols and local identities supported by
     * the server) mapped by the handshake protocol. Each handshake security
     * protocol (e.g., TLS or ALTS) has its own set of record protocols and local
     * identities. Since protobuf does not support enum as key to the map, the key
     * to handshake_parameters is the integer value of HandshakeProtocol enum.
     * </pre>
     *
     * <code>map&lt;int32, .grpc.gcp.ServerHandshakeParameters&gt; handshake_parameters = 2;</code>
     */

    public boolean containsHandshakeParameters(
        int key) {
      
      return internalGetHandshakeParameters().getMap().containsKey(key);
    }
    /**
     * Use {@link #getHandshakeParametersMap()} instead.
     */
    @java.lang.Deprecated
    public java.util.Map<java.lang.Integer, io.grpc.alts.internal.ServerHandshakeParameters> getHandshakeParameters() {
      return getHandshakeParametersMap();
    }
    /**
     * <pre>
     * Handshake parameters (record protocols and local identities supported by
     * the server) mapped by the handshake protocol. Each handshake security
     * protocol (e.g., TLS or ALTS) has its own set of record protocols and local
     * identities. Since protobuf does not support enum as key to the map, the key
     * to handshake_parameters is the integer value of HandshakeProtocol enum.
     * </pre>
     *
     * <code>map&lt;int32, .grpc.gcp.ServerHandshakeParameters&gt; handshake_parameters = 2;</code>
     */

    public java.util.Map<java.lang.Integer, io.grpc.alts.internal.ServerHandshakeParameters> getHandshakeParametersMap() {
      return internalGetHandshakeParameters().getMap();
    }
    /**
     * <pre>
     * Handshake parameters (record protocols and local identities supported by
     * the server) mapped by the handshake protocol. Each handshake security
     * protocol (e.g., TLS or ALTS) has its own set of record protocols and local
     * identities. Since protobuf does not support enum as key to the map, the key
     * to handshake_parameters is the integer value of HandshakeProtocol enum.
     * </pre>
     *
     * <code>map&lt;int32, .grpc.gcp.ServerHandshakeParameters&gt; handshake_parameters = 2;</code>
     */

    public io.grpc.alts.internal.ServerHandshakeParameters getHandshakeParametersOrDefault(
        int key,
        io.grpc.alts.internal.ServerHandshakeParameters defaultValue) {
      
      java.util.Map<java.lang.Integer, io.grpc.alts.internal.ServerHandshakeParameters> map =
          internalGetHandshakeParameters().getMap();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }
    /**
     * <pre>
     * Handshake parameters (record protocols and local identities supported by
     * the server) mapped by the handshake protocol. Each handshake security
     * protocol (e.g., TLS or ALTS) has its own set of record protocols and local
     * identities. Since protobuf does not support enum as key to the map, the key
     * to handshake_parameters is the integer value of HandshakeProtocol enum.
     * </pre>
     *
     * <code>map&lt;int32, .grpc.gcp.ServerHandshakeParameters&gt; handshake_parameters = 2;</code>
     */

    public io.grpc.alts.internal.ServerHandshakeParameters getHandshakeParametersOrThrow(
        int key) {
      
      java.util.Map<java.lang.Integer, io.grpc.alts.internal.ServerHandshakeParameters> map =
          internalGetHandshakeParameters().getMap();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return map.get(key);
    }

    public Builder clearHandshakeParameters() {
      internalGetMutableHandshakeParameters().getMutableMap()
          .clear();
      return this;
    }
    /**
     * <pre>
     * Handshake parameters (record protocols and local identities supported by
     * the server) mapped by the handshake protocol. Each handshake security
     * protocol (e.g., TLS or ALTS) has its own set of record protocols and local
     * identities. Since protobuf does not support enum as key to the map, the key
     * to handshake_parameters is the integer value of HandshakeProtocol enum.
     * </pre>
     *
     * <code>map&lt;int32, .grpc.gcp.ServerHandshakeParameters&gt; handshake_parameters = 2;</code>
     */

    public Builder removeHandshakeParameters(
        int key) {
      
      internalGetMutableHandshakeParameters().getMutableMap()
          .remove(key);
      return this;
    }
    /**
     * Use alternate mutation accessors instead.
     */
    @java.lang.Deprecated
    public java.util.Map<java.lang.Integer, io.grpc.alts.internal.ServerHandshakeParameters>
    getMutableHandshakeParameters() {
      return internalGetMutableHandshakeParameters().getMutableMap();
    }
    /**
     * <pre>
     * Handshake parameters (record protocols and local identities supported by
     * the server) mapped by the handshake protocol. Each handshake security
     * protocol (e.g., TLS or ALTS) has its own set of record protocols and local
     * identities. Since protobuf does not support enum as key to the map, the key
     * to handshake_parameters is the integer value of HandshakeProtocol enum.
     * </pre>
     *
     * <code>map&lt;int32, .grpc.gcp.ServerHandshakeParameters&gt; handshake_parameters = 2;</code>
     */
    public Builder putHandshakeParameters(
        int key,
        io.grpc.alts.internal.ServerHandshakeParameters value) {
      
      if (value == null) { throw new java.lang.NullPointerException(); }
      internalGetMutableHandshakeParameters().getMutableMap()
          .put(key, value);
      return this;
    }
    /**
     * <pre>
     * Handshake parameters (record protocols and local identities supported by
     * the server) mapped by the handshake protocol. Each handshake security
     * protocol (e.g., TLS or ALTS) has its own set of record protocols and local
     * identities. Since protobuf does not support enum as key to the map, the key
     * to handshake_parameters is the integer value of HandshakeProtocol enum.
     * </pre>
     *
     * <code>map&lt;int32, .grpc.gcp.ServerHandshakeParameters&gt; handshake_parameters = 2;</code>
     */

    public Builder putAllHandshakeParameters(
        java.util.Map<java.lang.Integer, io.grpc.alts.internal.ServerHandshakeParameters> values) {
      internalGetMutableHandshakeParameters().getMutableMap()
          .putAll(values);
      return this;
    }

    private com.google.protobuf.ByteString inBytes_ = com.google.protobuf.ByteString.EMPTY;
    /**
     * <pre>
     * Bytes in out_frames returned from the peer's HandshakerResp. It is possible
     * that the peer's out_frames are split into multiple HandshakReq messages.
     * </pre>
     *
     * <code>bytes in_bytes = 3;</code>
     */
    public com.google.protobuf.ByteString getInBytes() {
      return inBytes_;
    }
    /**
     * <pre>
     * Bytes in out_frames returned from the peer's HandshakerResp. It is possible
     * that the peer's out_frames are split into multiple HandshakReq messages.
     * </pre>
     *
     * <code>bytes in_bytes = 3;</code>
     */
    public Builder setInBytes(com.google.protobuf.ByteString value) {
      if (value == null) {
    throw new NullPointerException();
  }
  
      inBytes_ = value;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Bytes in out_frames returned from the peer's HandshakerResp. It is possible
     * that the peer's out_frames are split into multiple HandshakReq messages.
     * </pre>
     *
     * <code>bytes in_bytes = 3;</code>
     */
    public Builder clearInBytes() {
      
      inBytes_ = getDefaultInstance().getInBytes();
      onChanged();
      return this;
    }

    private io.grpc.alts.internal.Endpoint localEndpoint_ = null;
    private com.google.protobuf.SingleFieldBuilderV3<
        io.grpc.alts.internal.Endpoint, io.grpc.alts.internal.Endpoint.Builder, io.grpc.alts.internal.EndpointOrBuilder> localEndpointBuilder_;
    /**
     * <pre>
     * (Optional) Local endpoint information of the connection to the client,
     * such as local IP address, port number, and network protocol.
     * </pre>
     *
     * <code>.grpc.gcp.Endpoint local_endpoint = 4;</code>
     */
    public boolean hasLocalEndpoint() {
      return localEndpointBuilder_ != null || localEndpoint_ != null;
    }
    /**
     * <pre>
     * (Optional) Local endpoint information of the connection to the client,
     * such as local IP address, port number, and network protocol.
     * </pre>
     *
     * <code>.grpc.gcp.Endpoint local_endpoint = 4;</code>
     */
    public io.grpc.alts.internal.Endpoint getLocalEndpoint() {
      if (localEndpointBuilder_ == null) {
        return localEndpoint_ == null ? io.grpc.alts.internal.Endpoint.getDefaultInstance() : localEndpoint_;
      } else {
        return localEndpointBuilder_.getMessage();
      }
    }
    /**
     * <pre>
     * (Optional) Local endpoint information of the connection to the client,
     * such as local IP address, port number, and network protocol.
     * </pre>
     *
     * <code>.grpc.gcp.Endpoint local_endpoint = 4;</code>
     */
    public Builder setLocalEndpoint(io.grpc.alts.internal.Endpoint value) {
      if (localEndpointBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        localEndpoint_ = value;
        onChanged();
      } else {
        localEndpointBuilder_.setMessage(value);
      }

      return this;
    }
    /**
     * <pre>
     * (Optional) Local endpoint information of the connection to the client,
     * such as local IP address, port number, and network protocol.
     * </pre>
     *
     * <code>.grpc.gcp.Endpoint local_endpoint = 4;</code>
     */
    public Builder setLocalEndpoint(
        io.grpc.alts.internal.Endpoint.Builder builderForValue) {
      if (localEndpointBuilder_ == null) {
        localEndpoint_ = builderForValue.build();
        onChanged();
      } else {
        localEndpointBuilder_.setMessage(builderForValue.build());
      }

      return this;
    }
    /**
     * <pre>
     * (Optional) Local endpoint information of the connection to the client,
     * such as local IP address, port number, and network protocol.
     * </pre>
     *
     * <code>.grpc.gcp.Endpoint local_endpoint = 4;</code>
     */
    public Builder mergeLocalEndpoint(io.grpc.alts.internal.Endpoint value) {
      if (localEndpointBuilder_ == null) {
        if (localEndpoint_ != null) {
          localEndpoint_ =
            io.grpc.alts.internal.Endpoint.newBuilder(localEndpoint_).mergeFrom(value).buildPartial();
        } else {
          localEndpoint_ = value;
        }
        onChanged();
      } else {
        localEndpointBuilder_.mergeFrom(value);
      }

      return this;
    }
    /**
     * <pre>
     * (Optional) Local endpoint information of the connection to the client,
     * such as local IP address, port number, and network protocol.
     * </pre>
     *
     * <code>.grpc.gcp.Endpoint local_endpoint = 4;</code>
     */
    public Builder clearLocalEndpoint() {
      if (localEndpointBuilder_ == null) {
        localEndpoint_ = null;
        onChanged();
      } else {
        localEndpoint_ = null;
        localEndpointBuilder_ = null;
      }

      return this;
    }
    /**
     * <pre>
     * (Optional) Local endpoint information of the connection to the client,
     * such as local IP address, port number, and network protocol.
     * </pre>
     *
     * <code>.grpc.gcp.Endpoint local_endpoint = 4;</code>
     */
    public io.grpc.alts.internal.Endpoint.Builder getLocalEndpointBuilder() {
      
      onChanged();
      return getLocalEndpointFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * (Optional) Local endpoint information of the connection to the client,
     * such as local IP address, port number, and network protocol.
     * </pre>
     *
     * <code>.grpc.gcp.Endpoint local_endpoint = 4;</code>
     */
    public io.grpc.alts.internal.EndpointOrBuilder getLocalEndpointOrBuilder() {
      if (localEndpointBuilder_ != null) {
        return localEndpointBuilder_.getMessageOrBuilder();
      } else {
        return localEndpoint_ == null ?
            io.grpc.alts.internal.Endpoint.getDefaultInstance() : localEndpoint_;
      }
    }
    /**
     * <pre>
     * (Optional) Local endpoint information of the connection to the client,
     * such as local IP address, port number, and network protocol.
     * </pre>
     *
     * <code>.grpc.gcp.Endpoint local_endpoint = 4;</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        io.grpc.alts.internal.Endpoint, io.grpc.alts.internal.Endpoint.Builder, io.grpc.alts.internal.EndpointOrBuilder> 
        getLocalEndpointFieldBuilder() {
      if (localEndpointBuilder_ == null) {
        localEndpointBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            io.grpc.alts.internal.Endpoint, io.grpc.alts.internal.Endpoint.Builder, io.grpc.alts.internal.EndpointOrBuilder>(
                getLocalEndpoint(),
                getParentForChildren(),
                isClean());
        localEndpoint_ = null;
      }
      return localEndpointBuilder_;
    }

    private io.grpc.alts.internal.Endpoint remoteEndpoint_ = null;
    private com.google.protobuf.SingleFieldBuilderV3<
        io.grpc.alts.internal.Endpoint, io.grpc.alts.internal.Endpoint.Builder, io.grpc.alts.internal.EndpointOrBuilder> remoteEndpointBuilder_;
    /**
     * <pre>
     * (Optional) Endpoint information of the remote client, such as IP address,
     * port number, and network protocol.
     * </pre>
     *
     * <code>.grpc.gcp.Endpoint remote_endpoint = 5;</code>
     */
    public boolean hasRemoteEndpoint() {
      return remoteEndpointBuilder_ != null || remoteEndpoint_ != null;
    }
    /**
     * <pre>
     * (Optional) Endpoint information of the remote client, such as IP address,
     * port number, and network protocol.
     * </pre>
     *
     * <code>.grpc.gcp.Endpoint remote_endpoint = 5;</code>
     */
    public io.grpc.alts.internal.Endpoint getRemoteEndpoint() {
      if (remoteEndpointBuilder_ == null) {
        return remoteEndpoint_ == null ? io.grpc.alts.internal.Endpoint.getDefaultInstance() : remoteEndpoint_;
      } else {
        return remoteEndpointBuilder_.getMessage();
      }
    }
    /**
     * <pre>
     * (Optional) Endpoint information of the remote client, such as IP address,
     * port number, and network protocol.
     * </pre>
     *
     * <code>.grpc.gcp.Endpoint remote_endpoint = 5;</code>
     */
    public Builder setRemoteEndpoint(io.grpc.alts.internal.Endpoint value) {
      if (remoteEndpointBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        remoteEndpoint_ = value;
        onChanged();
      } else {
        remoteEndpointBuilder_.setMessage(value);
      }

      return this;
    }
    /**
     * <pre>
     * (Optional) Endpoint information of the remote client, such as IP address,
     * port number, and network protocol.
     * </pre>
     *
     * <code>.grpc.gcp.Endpoint remote_endpoint = 5;</code>
     */
    public Builder setRemoteEndpoint(
        io.grpc.alts.internal.Endpoint.Builder builderForValue) {
      if (remoteEndpointBuilder_ == null) {
        remoteEndpoint_ = builderForValue.build();
        onChanged();
      } else {
        remoteEndpointBuilder_.setMessage(builderForValue.build());
      }

      return this;
    }
    /**
     * <pre>
     * (Optional) Endpoint information of the remote client, such as IP address,
     * port number, and network protocol.
     * </pre>
     *
     * <code>.grpc.gcp.Endpoint remote_endpoint = 5;</code>
     */
    public Builder mergeRemoteEndpoint(io.grpc.alts.internal.Endpoint value) {
      if (remoteEndpointBuilder_ == null) {
        if (remoteEndpoint_ != null) {
          remoteEndpoint_ =
            io.grpc.alts.internal.Endpoint.newBuilder(remoteEndpoint_).mergeFrom(value).buildPartial();
        } else {
          remoteEndpoint_ = value;
        }
        onChanged();
      } else {
        remoteEndpointBuilder_.mergeFrom(value);
      }

      return this;
    }
    /**
     * <pre>
     * (Optional) Endpoint information of the remote client, such as IP address,
     * port number, and network protocol.
     * </pre>
     *
     * <code>.grpc.gcp.Endpoint remote_endpoint = 5;</code>
     */
    public Builder clearRemoteEndpoint() {
      if (remoteEndpointBuilder_ == null) {
        remoteEndpoint_ = null;
        onChanged();
      } else {
        remoteEndpoint_ = null;
        remoteEndpointBuilder_ = null;
      }

      return this;
    }
    /**
     * <pre>
     * (Optional) Endpoint information of the remote client, such as IP address,
     * port number, and network protocol.
     * </pre>
     *
     * <code>.grpc.gcp.Endpoint remote_endpoint = 5;</code>
     */
    public io.grpc.alts.internal.Endpoint.Builder getRemoteEndpointBuilder() {
      
      onChanged();
      return getRemoteEndpointFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * (Optional) Endpoint information of the remote client, such as IP address,
     * port number, and network protocol.
     * </pre>
     *
     * <code>.grpc.gcp.Endpoint remote_endpoint = 5;</code>
     */
    public io.grpc.alts.internal.EndpointOrBuilder getRemoteEndpointOrBuilder() {
      if (remoteEndpointBuilder_ != null) {
        return remoteEndpointBuilder_.getMessageOrBuilder();
      } else {
        return remoteEndpoint_ == null ?
            io.grpc.alts.internal.Endpoint.getDefaultInstance() : remoteEndpoint_;
      }
    }
    /**
     * <pre>
     * (Optional) Endpoint information of the remote client, such as IP address,
     * port number, and network protocol.
     * </pre>
     *
     * <code>.grpc.gcp.Endpoint remote_endpoint = 5;</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        io.grpc.alts.internal.Endpoint, io.grpc.alts.internal.Endpoint.Builder, io.grpc.alts.internal.EndpointOrBuilder> 
        getRemoteEndpointFieldBuilder() {
      if (remoteEndpointBuilder_ == null) {
        remoteEndpointBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            io.grpc.alts.internal.Endpoint, io.grpc.alts.internal.Endpoint.Builder, io.grpc.alts.internal.EndpointOrBuilder>(
                getRemoteEndpoint(),
                getParentForChildren(),
                isClean());
        remoteEndpoint_ = null;
      }
      return remoteEndpointBuilder_;
    }

    private io.grpc.alts.internal.RpcProtocolVersions rpcVersions_ = null;
    private com.google.protobuf.SingleFieldBuilderV3<
        io.grpc.alts.internal.RpcProtocolVersions, io.grpc.alts.internal.RpcProtocolVersions.Builder, io.grpc.alts.internal.RpcProtocolVersionsOrBuilder> rpcVersionsBuilder_;
    /**
     * <pre>
     * (Optional) RPC protocol versions supported by the server.
     * </pre>
     *
     * <code>.grpc.gcp.RpcProtocolVersions rpc_versions = 6;</code>
     */
    public boolean hasRpcVersions() {
      return rpcVersionsBuilder_ != null || rpcVersions_ != null;
    }
    /**
     * <pre>
     * (Optional) RPC protocol versions supported by the server.
     * </pre>
     *
     * <code>.grpc.gcp.RpcProtocolVersions rpc_versions = 6;</code>
     */
    public io.grpc.alts.internal.RpcProtocolVersions getRpcVersions() {
      if (rpcVersionsBuilder_ == null) {
        return rpcVersions_ == null ? io.grpc.alts.internal.RpcProtocolVersions.getDefaultInstance() : rpcVersions_;
      } else {
        return rpcVersionsBuilder_.getMessage();
      }
    }
    /**
     * <pre>
     * (Optional) RPC protocol versions supported by the server.
     * </pre>
     *
     * <code>.grpc.gcp.RpcProtocolVersions rpc_versions = 6;</code>
     */
    public Builder setRpcVersions(io.grpc.alts.internal.RpcProtocolVersions value) {
      if (rpcVersionsBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        rpcVersions_ = value;
        onChanged();
      } else {
        rpcVersionsBuilder_.setMessage(value);
      }

      return this;
    }
    /**
     * <pre>
     * (Optional) RPC protocol versions supported by the server.
     * </pre>
     *
     * <code>.grpc.gcp.RpcProtocolVersions rpc_versions = 6;</code>
     */
    public Builder setRpcVersions(
        io.grpc.alts.internal.RpcProtocolVersions.Builder builderForValue) {
      if (rpcVersionsBuilder_ == null) {
        rpcVersions_ = builderForValue.build();
        onChanged();
      } else {
        rpcVersionsBuilder_.setMessage(builderForValue.build());
      }

      return this;
    }
    /**
     * <pre>
     * (Optional) RPC protocol versions supported by the server.
     * </pre>
     *
     * <code>.grpc.gcp.RpcProtocolVersions rpc_versions = 6;</code>
     */
    public Builder mergeRpcVersions(io.grpc.alts.internal.RpcProtocolVersions value) {
      if (rpcVersionsBuilder_ == null) {
        if (rpcVersions_ != null) {
          rpcVersions_ =
            io.grpc.alts.internal.RpcProtocolVersions.newBuilder(rpcVersions_).mergeFrom(value).buildPartial();
        } else {
          rpcVersions_ = value;
        }
        onChanged();
      } else {
        rpcVersionsBuilder_.mergeFrom(value);
      }

      return this;
    }
    /**
     * <pre>
     * (Optional) RPC protocol versions supported by the server.
     * </pre>
     *
     * <code>.grpc.gcp.RpcProtocolVersions rpc_versions = 6;</code>
     */
    public Builder clearRpcVersions() {
      if (rpcVersionsBuilder_ == null) {
        rpcVersions_ = null;
        onChanged();
      } else {
        rpcVersions_ = null;
        rpcVersionsBuilder_ = null;
      }

      return this;
    }
    /**
     * <pre>
     * (Optional) RPC protocol versions supported by the server.
     * </pre>
     *
     * <code>.grpc.gcp.RpcProtocolVersions rpc_versions = 6;</code>
     */
    public io.grpc.alts.internal.RpcProtocolVersions.Builder getRpcVersionsBuilder() {
      
      onChanged();
      return getRpcVersionsFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * (Optional) RPC protocol versions supported by the server.
     * </pre>
     *
     * <code>.grpc.gcp.RpcProtocolVersions rpc_versions = 6;</code>
     */
    public io.grpc.alts.internal.RpcProtocolVersionsOrBuilder getRpcVersionsOrBuilder() {
      if (rpcVersionsBuilder_ != null) {
        return rpcVersionsBuilder_.getMessageOrBuilder();
      } else {
        return rpcVersions_ == null ?
            io.grpc.alts.internal.RpcProtocolVersions.getDefaultInstance() : rpcVersions_;
      }
    }
    /**
     * <pre>
     * (Optional) RPC protocol versions supported by the server.
     * </pre>
     *
     * <code>.grpc.gcp.RpcProtocolVersions rpc_versions = 6;</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        io.grpc.alts.internal.RpcProtocolVersions, io.grpc.alts.internal.RpcProtocolVersions.Builder, io.grpc.alts.internal.RpcProtocolVersionsOrBuilder> 
        getRpcVersionsFieldBuilder() {
      if (rpcVersionsBuilder_ == null) {
        rpcVersionsBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            io.grpc.alts.internal.RpcProtocolVersions, io.grpc.alts.internal.RpcProtocolVersions.Builder, io.grpc.alts.internal.RpcProtocolVersionsOrBuilder>(
                getRpcVersions(),
                getParentForChildren(),
                isClean());
        rpcVersions_ = null;
      }
      return rpcVersionsBuilder_;
    }
    @java.lang.Override
    public final Builder setUnknownFields(
        final com.google.protobuf.UnknownFieldSet unknownFields) {
      return super.setUnknownFieldsProto3(unknownFields);
    }

    @java.lang.Override
    public final Builder mergeUnknownFields(
        final com.google.protobuf.UnknownFieldSet unknownFields) {
      return super.mergeUnknownFields(unknownFields);
    }


    // @@protoc_insertion_point(builder_scope:grpc.gcp.StartServerHandshakeReq)
  }

  // @@protoc_insertion_point(class_scope:grpc.gcp.StartServerHandshakeReq)
  private static final io.grpc.alts.internal.StartServerHandshakeReq DEFAULT_INSTANCE;
  static {
    DEFAULT_INSTANCE = new io.grpc.alts.internal.StartServerHandshakeReq();
  }

  public static io.grpc.alts.internal.StartServerHandshakeReq getDefaultInstance() {
    return DEFAULT_INSTANCE;
  }

  private static final com.google.protobuf.Parser<StartServerHandshakeReq>
      PARSER = new com.google.protobuf.AbstractParser<StartServerHandshakeReq>() {
    @java.lang.Override
    public StartServerHandshakeReq parsePartialFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return new StartServerHandshakeReq(input, extensionRegistry);
    }
  };

  public static com.google.protobuf.Parser<StartServerHandshakeReq> parser() {
    return PARSER;
  }

  @java.lang.Override
  public com.google.protobuf.Parser<StartServerHandshakeReq> getParserForType() {
    return PARSER;
  }

  @java.lang.Override
  public io.grpc.alts.internal.StartServerHandshakeReq getDefaultInstanceForType() {
    return DEFAULT_INSTANCE;
  }

}

