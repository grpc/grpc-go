// Code generated by protoc-gen-go. DO NOT EDIT.
// source: grpc/rls/grpc_lookup_v1/rls.proto

package grpc_lookup_v1

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type RouteLookupRequest struct {
	// Full host name of the target server, e.g. firestore.googleapis.com.
	// Only set for gRPC requests; HTTP requests must use key_map explicitly.
	Server string `protobuf:"bytes,1,opt,name=server,proto3" json:"server,omitempty"`
	// Full path of the request, i.e. "/service/method".
	// Only set for gRPC requests; HTTP requests must use key_map explicitly.
	Path string `protobuf:"bytes,2,opt,name=path,proto3" json:"path,omitempty"`
	// Target type allows the client to specify what kind of target format it
	// would like from RLS to allow it to find the regional server, e.g. "grpc".
	TargetType string `protobuf:"bytes,3,opt,name=target_type,json=targetType,proto3" json:"target_type,omitempty"`
	// Map of key values extracted via key builders for the gRPC or HTTP request.
	KeyMap               map[string]string `protobuf:"bytes,4,rep,name=key_map,json=keyMap,proto3" json:"key_map,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *RouteLookupRequest) Reset()         { *m = RouteLookupRequest{} }
func (m *RouteLookupRequest) String() string { return proto.CompactTextString(m) }
func (*RouteLookupRequest) ProtoMessage()    {}
func (*RouteLookupRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_5fe9649e373b9d12, []int{0}
}

func (m *RouteLookupRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RouteLookupRequest.Unmarshal(m, b)
}
func (m *RouteLookupRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RouteLookupRequest.Marshal(b, m, deterministic)
}
func (m *RouteLookupRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RouteLookupRequest.Merge(m, src)
}
func (m *RouteLookupRequest) XXX_Size() int {
	return xxx_messageInfo_RouteLookupRequest.Size(m)
}
func (m *RouteLookupRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RouteLookupRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RouteLookupRequest proto.InternalMessageInfo

func (m *RouteLookupRequest) GetServer() string {
	if m != nil {
		return m.Server
	}
	return ""
}

func (m *RouteLookupRequest) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *RouteLookupRequest) GetTargetType() string {
	if m != nil {
		return m.TargetType
	}
	return ""
}

func (m *RouteLookupRequest) GetKeyMap() map[string]string {
	if m != nil {
		return m.KeyMap
	}
	return nil
}

type RouteLookupResponse struct {
	// Actual addressable entity to use for routing decision, using syntax
	// requested by the request target_type.
	// This field is deprecated in favor of the new "targets" field, below.
	Target string `protobuf:"bytes,1,opt,name=target,proto3" json:"target,omitempty"` // Deprecated: Do not use.
	// Prioritized list (best one first) of addressable entities to use
	// for routing, using syntax requested by the request target_type.
	// The targets will be tried in order until a healthy one is found.
	// If present, it should be used by proxy/gRPC client code instead of
	// "target" (which is deprecated).
	Targets []string `protobuf:"bytes,3,rep,name=targets,proto3" json:"targets,omitempty"`
	// Optional header value to pass along to AFE in the X-Google-RLS-Data header.
	// Cached with "target" and sent with all requests that match the request key.
	// Allows the RLS to pass its work product to the eventual target.
	HeaderData           string   `protobuf:"bytes,2,opt,name=header_data,json=headerData,proto3" json:"header_data,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RouteLookupResponse) Reset()         { *m = RouteLookupResponse{} }
func (m *RouteLookupResponse) String() string { return proto.CompactTextString(m) }
func (*RouteLookupResponse) ProtoMessage()    {}
func (*RouteLookupResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_5fe9649e373b9d12, []int{1}
}

func (m *RouteLookupResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RouteLookupResponse.Unmarshal(m, b)
}
func (m *RouteLookupResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RouteLookupResponse.Marshal(b, m, deterministic)
}
func (m *RouteLookupResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RouteLookupResponse.Merge(m, src)
}
func (m *RouteLookupResponse) XXX_Size() int {
	return xxx_messageInfo_RouteLookupResponse.Size(m)
}
func (m *RouteLookupResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RouteLookupResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RouteLookupResponse proto.InternalMessageInfo

// Deprecated: Do not use.
func (m *RouteLookupResponse) GetTarget() string {
	if m != nil {
		return m.Target
	}
	return ""
}

func (m *RouteLookupResponse) GetTargets() []string {
	if m != nil {
		return m.Targets
	}
	return nil
}

func (m *RouteLookupResponse) GetHeaderData() string {
	if m != nil {
		return m.HeaderData
	}
	return ""
}

func init() {
	proto.RegisterType((*RouteLookupRequest)(nil), "grpc.lookup.v1.RouteLookupRequest")
	proto.RegisterMapType((map[string]string)(nil), "grpc.lookup.v1.RouteLookupRequest.KeyMapEntry")
	proto.RegisterType((*RouteLookupResponse)(nil), "grpc.lookup.v1.RouteLookupResponse")
}

func init() { proto.RegisterFile("grpc/rls/grpc_lookup_v1/rls.proto", fileDescriptor_5fe9649e373b9d12) }

var fileDescriptor_5fe9649e373b9d12 = []byte{
	// 345 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x84, 0x92, 0xc1, 0x4b, 0xeb, 0x40,
	0x10, 0xc6, 0x5f, 0x9a, 0xbe, 0xf4, 0x75, 0x02, 0x8f, 0xf7, 0x56, 0x91, 0xd0, 0x8b, 0x35, 0x5e,
	0x7a, 0x90, 0x2d, 0xad, 0x17, 0xf5, 0x58, 0x14, 0x0f, 0x5a, 0x28, 0xd1, 0x83, 0x78, 0x09, 0x6b,
	0x3b, 0xa4, 0x25, 0x6b, 0x76, 0xdd, 0xdd, 0x04, 0xf2, 0x07, 0xfb, 0x7f, 0x48, 0x76, 0x23, 0xb4,
	0x15, 0xf4, 0xf6, 0x7d, 0xbf, 0x19, 0xb2, 0xdf, 0x4c, 0x06, 0x4e, 0x32, 0x25, 0x97, 0x63, 0xc5,
	0xf5, 0xb8, 0x11, 0x29, 0x17, 0x22, 0x2f, 0x65, 0x5a, 0x4d, 0x1a, 0x44, 0xa5, 0x12, 0x46, 0x90,
	0xbf, 0x4d, 0x85, 0xba, 0x0a, 0xad, 0x26, 0xf1, 0xbb, 0x07, 0x24, 0x11, 0xa5, 0xc1, 0x7b, 0x8b,
	0x12, 0x7c, 0x2b, 0x51, 0x1b, 0x72, 0x04, 0x81, 0x46, 0x55, 0xa1, 0x8a, 0xbc, 0xa1, 0x37, 0xea,
	0x27, 0xad, 0x23, 0x04, 0xba, 0x92, 0x99, 0x75, 0xd4, 0xb1, 0xd4, 0x6a, 0x72, 0x0c, 0xa1, 0x61,
	0x2a, 0x43, 0x93, 0x9a, 0x5a, 0x62, 0xe4, 0xdb, 0x12, 0x38, 0xf4, 0x58, 0x4b, 0x24, 0xb7, 0xd0,
	0xcb, 0xb1, 0x4e, 0x5f, 0x99, 0x8c, 0xba, 0x43, 0x7f, 0x14, 0x4e, 0x29, 0xdd, 0x4d, 0x41, 0xbf,
	0x26, 0xa0, 0x77, 0x58, 0xcf, 0x99, 0xbc, 0x29, 0x8c, 0xaa, 0x93, 0x20, 0xb7, 0x66, 0x70, 0x09,
	0xe1, 0x16, 0x26, 0xff, 0xc0, 0xcf, 0xb1, 0x6e, 0x13, 0x36, 0x92, 0x1c, 0xc2, 0xef, 0x8a, 0xf1,
	0x12, 0xdb, 0x7c, 0xce, 0x5c, 0x75, 0x2e, 0xbc, 0x98, 0xc3, 0xc1, 0xce, 0x23, 0x5a, 0x8a, 0x42,
	0x23, 0x19, 0x40, 0xe0, 0x82, 0xba, 0xaf, 0xcc, 0x3a, 0x91, 0x97, 0xb4, 0x84, 0x44, 0xd0, 0x73,
	0x4a, 0x47, 0xfe, 0xd0, 0x1f, 0xf5, 0x93, 0x4f, 0xdb, 0x4c, 0xbc, 0x46, 0xb6, 0x42, 0x95, 0xae,
	0x98, 0x61, 0xed, 0x63, 0xe0, 0xd0, 0x35, 0x33, 0x6c, 0x5a, 0xec, 0x2c, 0xf5, 0x01, 0x55, 0xb5,
	0x59, 0x22, 0x79, 0x82, 0x70, 0x8b, 0x92, 0xf8, 0xe7, 0x2d, 0x0c, 0x4e, 0xbf, 0xed, 0x71, 0x43,
	0xc4, 0xbf, 0x66, 0x73, 0xf8, 0xbf, 0x11, 0x7b, 0xad, 0xb3, 0x3f, 0x09, 0xd7, 0x8b, 0xe6, 0xa7,
	0x2f, 0xbc, 0xe7, 0xb3, 0x4c, 0x88, 0x8c, 0x23, 0xcd, 0x04, 0x67, 0x45, 0x46, 0x85, 0xca, 0xec,
	0x89, 0x8c, 0x5d, 0xf7, 0xde, 0xb9, 0xbc, 0x04, 0xf6, 0x56, 0xce, 0x3f, 0x02, 0x00, 0x00, 0xff,
	0xff, 0xb4, 0xe3, 0xe2, 0xd0, 0x50, 0x02, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConnInterface

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion6

// RouteLookupServiceClient is the client API for RouteLookupService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type RouteLookupServiceClient interface {
	// Lookup returns a target for a single key.
	RouteLookup(ctx context.Context, in *RouteLookupRequest, opts ...grpc.CallOption) (*RouteLookupResponse, error)
}

type routeLookupServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewRouteLookupServiceClient(cc grpc.ClientConnInterface) RouteLookupServiceClient {
	return &routeLookupServiceClient{cc}
}

func (c *routeLookupServiceClient) RouteLookup(ctx context.Context, in *RouteLookupRequest, opts ...grpc.CallOption) (*RouteLookupResponse, error) {
	out := new(RouteLookupResponse)
	err := c.cc.Invoke(ctx, "/grpc.lookup.v1.RouteLookupService/RouteLookup", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RouteLookupServiceServer is the server API for RouteLookupService service.
type RouteLookupServiceServer interface {
	// Lookup returns a target for a single key.
	RouteLookup(context.Context, *RouteLookupRequest) (*RouteLookupResponse, error)
}

// UnimplementedRouteLookupServiceServer can be embedded to have forward compatible implementations.
type UnimplementedRouteLookupServiceServer struct {
}

func (*UnimplementedRouteLookupServiceServer) RouteLookup(ctx context.Context, req *RouteLookupRequest) (*RouteLookupResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RouteLookup not implemented")
}

func RegisterRouteLookupServiceServer(s *grpc.Server, srv RouteLookupServiceServer) {
	s.RegisterService(&_RouteLookupService_serviceDesc, srv)
}

func _RouteLookupService_RouteLookup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RouteLookupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RouteLookupServiceServer).RouteLookup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grpc.lookup.v1.RouteLookupService/RouteLookup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RouteLookupServiceServer).RouteLookup(ctx, req.(*RouteLookupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _RouteLookupService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "grpc.lookup.v1.RouteLookupService",
	HandlerType: (*RouteLookupServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RouteLookup",
			Handler:    _RouteLookupService_RouteLookup_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "grpc/rls/grpc_lookup_v1/rls.proto",
}
