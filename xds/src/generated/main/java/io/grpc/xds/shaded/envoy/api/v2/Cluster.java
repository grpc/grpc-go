// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: envoy/api/v2/cds.proto

package io.grpc.xds.shaded.envoy.api.v2;

/**
 * <pre>
 * Configuration for a single upstream cluster.
 * [#comment:next free field: 38]
 * </pre>
 *
 * Protobuf type {@code envoy.api.v2.Cluster}
 */
public  final class Cluster extends
    com.google.protobuf.GeneratedMessageV3 implements
    // @@protoc_insertion_point(message_implements:envoy.api.v2.Cluster)
    ClusterOrBuilder {
private static final long serialVersionUID = 0L;
  // Use Cluster.newBuilder() to construct.
  private Cluster(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
    super(builder);
  }
  private Cluster() {
    name_ = "";
    altStatName_ = "";
    type_ = 0;
    lbPolicy_ = 0;
    hosts_ = java.util.Collections.emptyList();
    healthChecks_ = java.util.Collections.emptyList();
    dnsLookupFamily_ = 0;
    dnsResolvers_ = java.util.Collections.emptyList();
    protocolSelection_ = 0;
    closeConnectionsOnHostHealthFailure_ = false;
    drainConnectionsOnHostRemoval_ = false;
  }

  @java.lang.Override
  public final com.google.protobuf.UnknownFieldSet
  getUnknownFields() {
    return this.unknownFields;
  }
  private Cluster(
      com.google.protobuf.CodedInputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    this();
    if (extensionRegistry == null) {
      throw new java.lang.NullPointerException();
    }
    int mutable_bitField0_ = 0;
    int mutable_bitField1_ = 0;
    com.google.protobuf.UnknownFieldSet.Builder unknownFields =
        com.google.protobuf.UnknownFieldSet.newBuilder();
    try {
      boolean done = false;
      while (!done) {
        int tag = input.readTag();
        switch (tag) {
          case 0:
            done = true;
            break;
          default: {
            if (!parseUnknownFieldProto3(
                input, unknownFields, extensionRegistry, tag)) {
              done = true;
            }
            break;
          }
          case 10: {
            java.lang.String s = input.readStringRequireUtf8();

            name_ = s;
            break;
          }
          case 16: {
            int rawValue = input.readEnum();

            type_ = rawValue;
            break;
          }
          case 26: {
            io.grpc.xds.shaded.envoy.api.v2.Cluster.EdsClusterConfig.Builder subBuilder = null;
            if (edsClusterConfig_ != null) {
              subBuilder = edsClusterConfig_.toBuilder();
            }
            edsClusterConfig_ = input.readMessage(io.grpc.xds.shaded.envoy.api.v2.Cluster.EdsClusterConfig.parser(), extensionRegistry);
            if (subBuilder != null) {
              subBuilder.mergeFrom(edsClusterConfig_);
              edsClusterConfig_ = subBuilder.buildPartial();
            }

            break;
          }
          case 34: {
            com.google.protobuf.Duration.Builder subBuilder = null;
            if (connectTimeout_ != null) {
              subBuilder = connectTimeout_.toBuilder();
            }
            connectTimeout_ = input.readMessage(com.google.protobuf.Duration.parser(), extensionRegistry);
            if (subBuilder != null) {
              subBuilder.mergeFrom(connectTimeout_);
              connectTimeout_ = subBuilder.buildPartial();
            }

            break;
          }
          case 42: {
            com.google.protobuf.UInt32Value.Builder subBuilder = null;
            if (perConnectionBufferLimitBytes_ != null) {
              subBuilder = perConnectionBufferLimitBytes_.toBuilder();
            }
            perConnectionBufferLimitBytes_ = input.readMessage(com.google.protobuf.UInt32Value.parser(), extensionRegistry);
            if (subBuilder != null) {
              subBuilder.mergeFrom(perConnectionBufferLimitBytes_);
              perConnectionBufferLimitBytes_ = subBuilder.buildPartial();
            }

            break;
          }
          case 48: {
            int rawValue = input.readEnum();

            lbPolicy_ = rawValue;
            break;
          }
          case 58: {
            if (!((mutable_bitField0_ & 0x00000080) == 0x00000080)) {
              hosts_ = new java.util.ArrayList<io.grpc.xds.shaded.envoy.api.v2.core.Address>();
              mutable_bitField0_ |= 0x00000080;
            }
            hosts_.add(
                input.readMessage(io.grpc.xds.shaded.envoy.api.v2.core.Address.parser(), extensionRegistry));
            break;
          }
          case 66: {
            if (!((mutable_bitField0_ & 0x00000200) == 0x00000200)) {
              healthChecks_ = new java.util.ArrayList<io.grpc.xds.shaded.envoy.api.v2.core.HealthCheck>();
              mutable_bitField0_ |= 0x00000200;
            }
            healthChecks_.add(
                input.readMessage(io.grpc.xds.shaded.envoy.api.v2.core.HealthCheck.parser(), extensionRegistry));
            break;
          }
          case 74: {
            com.google.protobuf.UInt32Value.Builder subBuilder = null;
            if (maxRequestsPerConnection_ != null) {
              subBuilder = maxRequestsPerConnection_.toBuilder();
            }
            maxRequestsPerConnection_ = input.readMessage(com.google.protobuf.UInt32Value.parser(), extensionRegistry);
            if (subBuilder != null) {
              subBuilder.mergeFrom(maxRequestsPerConnection_);
              maxRequestsPerConnection_ = subBuilder.buildPartial();
            }

            break;
          }
          case 82: {
            io.grpc.xds.shaded.envoy.api.v2.cluster.CircuitBreakers.Builder subBuilder = null;
            if (circuitBreakers_ != null) {
              subBuilder = circuitBreakers_.toBuilder();
            }
            circuitBreakers_ = input.readMessage(io.grpc.xds.shaded.envoy.api.v2.cluster.CircuitBreakers.parser(), extensionRegistry);
            if (subBuilder != null) {
              subBuilder.mergeFrom(circuitBreakers_);
              circuitBreakers_ = subBuilder.buildPartial();
            }

            break;
          }
          case 90: {
            io.grpc.xds.shaded.envoy.api.v2.auth.UpstreamTlsContext.Builder subBuilder = null;
            if (tlsContext_ != null) {
              subBuilder = tlsContext_.toBuilder();
            }
            tlsContext_ = input.readMessage(io.grpc.xds.shaded.envoy.api.v2.auth.UpstreamTlsContext.parser(), extensionRegistry);
            if (subBuilder != null) {
              subBuilder.mergeFrom(tlsContext_);
              tlsContext_ = subBuilder.buildPartial();
            }

            break;
          }
          case 106: {
            io.grpc.xds.shaded.envoy.api.v2.core.Http1ProtocolOptions.Builder subBuilder = null;
            if (httpProtocolOptions_ != null) {
              subBuilder = httpProtocolOptions_.toBuilder();
            }
            httpProtocolOptions_ = input.readMessage(io.grpc.xds.shaded.envoy.api.v2.core.Http1ProtocolOptions.parser(), extensionRegistry);
            if (subBuilder != null) {
              subBuilder.mergeFrom(httpProtocolOptions_);
              httpProtocolOptions_ = subBuilder.buildPartial();
            }

            break;
          }
          case 114: {
            io.grpc.xds.shaded.envoy.api.v2.core.Http2ProtocolOptions.Builder subBuilder = null;
            if (http2ProtocolOptions_ != null) {
              subBuilder = http2ProtocolOptions_.toBuilder();
            }
            http2ProtocolOptions_ = input.readMessage(io.grpc.xds.shaded.envoy.api.v2.core.Http2ProtocolOptions.parser(), extensionRegistry);
            if (subBuilder != null) {
              subBuilder.mergeFrom(http2ProtocolOptions_);
              http2ProtocolOptions_ = subBuilder.buildPartial();
            }

            break;
          }
          case 130: {
            com.google.protobuf.Duration.Builder subBuilder = null;
            if (dnsRefreshRate_ != null) {
              subBuilder = dnsRefreshRate_.toBuilder();
            }
            dnsRefreshRate_ = input.readMessage(com.google.protobuf.Duration.parser(), extensionRegistry);
            if (subBuilder != null) {
              subBuilder.mergeFrom(dnsRefreshRate_);
              dnsRefreshRate_ = subBuilder.buildPartial();
            }

            break;
          }
          case 136: {
            int rawValue = input.readEnum();

            dnsLookupFamily_ = rawValue;
            break;
          }
          case 146: {
            if (!((mutable_bitField0_ & 0x00100000) == 0x00100000)) {
              dnsResolvers_ = new java.util.ArrayList<io.grpc.xds.shaded.envoy.api.v2.core.Address>();
              mutable_bitField0_ |= 0x00100000;
            }
            dnsResolvers_.add(
                input.readMessage(io.grpc.xds.shaded.envoy.api.v2.core.Address.parser(), extensionRegistry));
            break;
          }
          case 154: {
            io.grpc.xds.shaded.envoy.api.v2.cluster.OutlierDetection.Builder subBuilder = null;
            if (outlierDetection_ != null) {
              subBuilder = outlierDetection_.toBuilder();
            }
            outlierDetection_ = input.readMessage(io.grpc.xds.shaded.envoy.api.v2.cluster.OutlierDetection.parser(), extensionRegistry);
            if (subBuilder != null) {
              subBuilder.mergeFrom(outlierDetection_);
              outlierDetection_ = subBuilder.buildPartial();
            }

            break;
          }
          case 162: {
            com.google.protobuf.Duration.Builder subBuilder = null;
            if (cleanupInterval_ != null) {
              subBuilder = cleanupInterval_.toBuilder();
            }
            cleanupInterval_ = input.readMessage(com.google.protobuf.Duration.parser(), extensionRegistry);
            if (subBuilder != null) {
              subBuilder.mergeFrom(cleanupInterval_);
              cleanupInterval_ = subBuilder.buildPartial();
            }

            break;
          }
          case 170: {
            io.grpc.xds.shaded.envoy.api.v2.core.BindConfig.Builder subBuilder = null;
            if (upstreamBindConfig_ != null) {
              subBuilder = upstreamBindConfig_.toBuilder();
            }
            upstreamBindConfig_ = input.readMessage(io.grpc.xds.shaded.envoy.api.v2.core.BindConfig.parser(), extensionRegistry);
            if (subBuilder != null) {
              subBuilder.mergeFrom(upstreamBindConfig_);
              upstreamBindConfig_ = subBuilder.buildPartial();
            }

            break;
          }
          case 178: {
            io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfig.Builder subBuilder = null;
            if (lbSubsetConfig_ != null) {
              subBuilder = lbSubsetConfig_.toBuilder();
            }
            lbSubsetConfig_ = input.readMessage(io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfig.parser(), extensionRegistry);
            if (subBuilder != null) {
              subBuilder.mergeFrom(lbSubsetConfig_);
              lbSubsetConfig_ = subBuilder.buildPartial();
            }

            break;
          }
          case 186: {
            io.grpc.xds.shaded.envoy.api.v2.Cluster.RingHashLbConfig.Builder subBuilder = null;
            if (lbConfigCase_ == 23) {
              subBuilder = ((io.grpc.xds.shaded.envoy.api.v2.Cluster.RingHashLbConfig) lbConfig_).toBuilder();
            }
            lbConfig_ =
                input.readMessage(io.grpc.xds.shaded.envoy.api.v2.Cluster.RingHashLbConfig.parser(), extensionRegistry);
            if (subBuilder != null) {
              subBuilder.mergeFrom((io.grpc.xds.shaded.envoy.api.v2.Cluster.RingHashLbConfig) lbConfig_);
              lbConfig_ = subBuilder.buildPartial();
            }
            lbConfigCase_ = 23;
            break;
          }
          case 194: {
            io.grpc.xds.shaded.envoy.api.v2.core.TransportSocket.Builder subBuilder = null;
            if (transportSocket_ != null) {
              subBuilder = transportSocket_.toBuilder();
            }
            transportSocket_ = input.readMessage(io.grpc.xds.shaded.envoy.api.v2.core.TransportSocket.parser(), extensionRegistry);
            if (subBuilder != null) {
              subBuilder.mergeFrom(transportSocket_);
              transportSocket_ = subBuilder.buildPartial();
            }

            break;
          }
          case 202: {
            io.grpc.xds.shaded.envoy.api.v2.core.Metadata.Builder subBuilder = null;
            if (metadata_ != null) {
              subBuilder = metadata_.toBuilder();
            }
            metadata_ = input.readMessage(io.grpc.xds.shaded.envoy.api.v2.core.Metadata.parser(), extensionRegistry);
            if (subBuilder != null) {
              subBuilder.mergeFrom(metadata_);
              metadata_ = subBuilder.buildPartial();
            }

            break;
          }
          case 208: {
            int rawValue = input.readEnum();

            protocolSelection_ = rawValue;
            break;
          }
          case 218: {
            io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.Builder subBuilder = null;
            if (commonLbConfig_ != null) {
              subBuilder = commonLbConfig_.toBuilder();
            }
            commonLbConfig_ = input.readMessage(io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.parser(), extensionRegistry);
            if (subBuilder != null) {
              subBuilder.mergeFrom(commonLbConfig_);
              commonLbConfig_ = subBuilder.buildPartial();
            }

            break;
          }
          case 226: {
            java.lang.String s = input.readStringRequireUtf8();

            altStatName_ = s;
            break;
          }
          case 234: {
            io.grpc.xds.shaded.envoy.api.v2.core.HttpProtocolOptions.Builder subBuilder = null;
            if (commonHttpProtocolOptions_ != null) {
              subBuilder = commonHttpProtocolOptions_.toBuilder();
            }
            commonHttpProtocolOptions_ = input.readMessage(io.grpc.xds.shaded.envoy.api.v2.core.HttpProtocolOptions.parser(), extensionRegistry);
            if (subBuilder != null) {
              subBuilder.mergeFrom(commonHttpProtocolOptions_);
              commonHttpProtocolOptions_ = subBuilder.buildPartial();
            }

            break;
          }
          case 242: {
            io.grpc.xds.shaded.envoy.api.v2.UpstreamConnectionOptions.Builder subBuilder = null;
            if (upstreamConnectionOptions_ != null) {
              subBuilder = upstreamConnectionOptions_.toBuilder();
            }
            upstreamConnectionOptions_ = input.readMessage(io.grpc.xds.shaded.envoy.api.v2.UpstreamConnectionOptions.parser(), extensionRegistry);
            if (subBuilder != null) {
              subBuilder.mergeFrom(upstreamConnectionOptions_);
              upstreamConnectionOptions_ = subBuilder.buildPartial();
            }

            break;
          }
          case 248: {

            closeConnectionsOnHostHealthFailure_ = input.readBool();
            break;
          }
          case 256: {

            drainConnectionsOnHostRemoval_ = input.readBool();
            break;
          }
          case 266: {
            io.grpc.xds.shaded.envoy.api.v2.ClusterLoadAssignment.Builder subBuilder = null;
            if (loadAssignment_ != null) {
              subBuilder = loadAssignment_.toBuilder();
            }
            loadAssignment_ = input.readMessage(io.grpc.xds.shaded.envoy.api.v2.ClusterLoadAssignment.parser(), extensionRegistry);
            if (subBuilder != null) {
              subBuilder.mergeFrom(loadAssignment_);
              loadAssignment_ = subBuilder.buildPartial();
            }

            break;
          }
          case 274: {
            io.grpc.xds.shaded.envoy.api.v2.Cluster.OriginalDstLbConfig.Builder subBuilder = null;
            if (lbConfigCase_ == 34) {
              subBuilder = ((io.grpc.xds.shaded.envoy.api.v2.Cluster.OriginalDstLbConfig) lbConfig_).toBuilder();
            }
            lbConfig_ =
                input.readMessage(io.grpc.xds.shaded.envoy.api.v2.Cluster.OriginalDstLbConfig.parser(), extensionRegistry);
            if (subBuilder != null) {
              subBuilder.mergeFrom((io.grpc.xds.shaded.envoy.api.v2.Cluster.OriginalDstLbConfig) lbConfig_);
              lbConfig_ = subBuilder.buildPartial();
            }
            lbConfigCase_ = 34;
            break;
          }
          case 282: {
            if (!((mutable_bitField0_ & 0x00010000) == 0x00010000)) {
              extensionProtocolOptions_ = com.google.protobuf.MapField.newMapField(
                  ExtensionProtocolOptionsDefaultEntryHolder.defaultEntry);
              mutable_bitField0_ |= 0x00010000;
            }
            com.google.protobuf.MapEntry<java.lang.String, com.google.protobuf.Struct>
            extensionProtocolOptions__ = input.readMessage(
                ExtensionProtocolOptionsDefaultEntryHolder.defaultEntry.getParserForType(), extensionRegistry);
            extensionProtocolOptions_.getMutableMap().put(
                extensionProtocolOptions__.getKey(), extensionProtocolOptions__.getValue());
            break;
          }
          case 290: {
            if (!((mutable_bitField0_ & 0x00020000) == 0x00020000)) {
              typedExtensionProtocolOptions_ = com.google.protobuf.MapField.newMapField(
                  TypedExtensionProtocolOptionsDefaultEntryHolder.defaultEntry);
              mutable_bitField0_ |= 0x00020000;
            }
            com.google.protobuf.MapEntry<java.lang.String, com.google.protobuf.Any>
            typedExtensionProtocolOptions__ = input.readMessage(
                TypedExtensionProtocolOptionsDefaultEntryHolder.defaultEntry.getParserForType(), extensionRegistry);
            typedExtensionProtocolOptions_.getMutableMap().put(
                typedExtensionProtocolOptions__.getKey(), typedExtensionProtocolOptions__.getValue());
            break;
          }
          case 298: {
            io.grpc.xds.shaded.envoy.api.v2.Cluster.LeastRequestLbConfig.Builder subBuilder = null;
            if (lbConfigCase_ == 37) {
              subBuilder = ((io.grpc.xds.shaded.envoy.api.v2.Cluster.LeastRequestLbConfig) lbConfig_).toBuilder();
            }
            lbConfig_ =
                input.readMessage(io.grpc.xds.shaded.envoy.api.v2.Cluster.LeastRequestLbConfig.parser(), extensionRegistry);
            if (subBuilder != null) {
              subBuilder.mergeFrom((io.grpc.xds.shaded.envoy.api.v2.Cluster.LeastRequestLbConfig) lbConfig_);
              lbConfig_ = subBuilder.buildPartial();
            }
            lbConfigCase_ = 37;
            break;
          }
        }
      }
    } catch (com.google.protobuf.InvalidProtocolBufferException e) {
      throw e.setUnfinishedMessage(this);
    } catch (java.io.IOException e) {
      throw new com.google.protobuf.InvalidProtocolBufferException(
          e).setUnfinishedMessage(this);
    } finally {
      if (((mutable_bitField0_ & 0x00000080) == 0x00000080)) {
        hosts_ = java.util.Collections.unmodifiableList(hosts_);
      }
      if (((mutable_bitField0_ & 0x00000200) == 0x00000200)) {
        healthChecks_ = java.util.Collections.unmodifiableList(healthChecks_);
      }
      if (((mutable_bitField0_ & 0x00100000) == 0x00100000)) {
        dnsResolvers_ = java.util.Collections.unmodifiableList(dnsResolvers_);
      }
      this.unknownFields = unknownFields.build();
      makeExtensionsImmutable();
    }
  }
  public static final com.google.protobuf.Descriptors.Descriptor
      getDescriptor() {
    return io.grpc.xds.shaded.envoy.api.v2.Cds.internal_static_envoy_api_v2_Cluster_descriptor;
  }

  @SuppressWarnings({"rawtypes"})
  protected com.google.protobuf.MapField internalGetMapField(
      int number) {
    switch (number) {
      case 35:
        return internalGetExtensionProtocolOptions();
      case 36:
        return internalGetTypedExtensionProtocolOptions();
      default:
        throw new RuntimeException(
            "Invalid map field number: " + number);
    }
  }
  protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internalGetFieldAccessorTable() {
    return io.grpc.xds.shaded.envoy.api.v2.Cds.internal_static_envoy_api_v2_Cluster_fieldAccessorTable
        .ensureFieldAccessorsInitialized(
            io.grpc.xds.shaded.envoy.api.v2.Cluster.class, io.grpc.xds.shaded.envoy.api.v2.Cluster.Builder.class);
  }

  /**
   * <pre>
   * Refer to :ref:`service discovery type &lt;arch_overview_service_discovery_types&gt;`
   * for an explanation on each type.
   * </pre>
   *
   * Protobuf enum {@code envoy.api.v2.Cluster.DiscoveryType}
   */
  public enum DiscoveryType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <pre>
     * Refer to the :ref:`static discovery type&lt;arch_overview_service_discovery_types_static&gt;`
     * for an explanation.
     * </pre>
     *
     * <code>STATIC = 0;</code>
     */
    STATIC(0),
    /**
     * <pre>
     * Refer to the :ref:`strict DNS discovery
     * type&lt;arch_overview_service_discovery_types_strict_dns&gt;`
     * for an explanation.
     * </pre>
     *
     * <code>STRICT_DNS = 1;</code>
     */
    STRICT_DNS(1),
    /**
     * <pre>
     * Refer to the :ref:`logical DNS discovery
     * type&lt;arch_overview_service_discovery_types_logical_dns&gt;`
     * for an explanation.
     * </pre>
     *
     * <code>LOGICAL_DNS = 2;</code>
     */
    LOGICAL_DNS(2),
    /**
     * <pre>
     * Refer to the :ref:`service discovery type&lt;arch_overview_service_discovery_types_eds&gt;`
     * for an explanation.
     * </pre>
     *
     * <code>EDS = 3;</code>
     */
    EDS(3),
    /**
     * <pre>
     * Refer to the :ref:`original destination discovery
     * type&lt;arch_overview_service_discovery_types_original_destination&gt;`
     * for an explanation.
     * </pre>
     *
     * <code>ORIGINAL_DST = 4;</code>
     */
    ORIGINAL_DST(4),
    UNRECOGNIZED(-1),
    ;

    /**
     * <pre>
     * Refer to the :ref:`static discovery type&lt;arch_overview_service_discovery_types_static&gt;`
     * for an explanation.
     * </pre>
     *
     * <code>STATIC = 0;</code>
     */
    public static final int STATIC_VALUE = 0;
    /**
     * <pre>
     * Refer to the :ref:`strict DNS discovery
     * type&lt;arch_overview_service_discovery_types_strict_dns&gt;`
     * for an explanation.
     * </pre>
     *
     * <code>STRICT_DNS = 1;</code>
     */
    public static final int STRICT_DNS_VALUE = 1;
    /**
     * <pre>
     * Refer to the :ref:`logical DNS discovery
     * type&lt;arch_overview_service_discovery_types_logical_dns&gt;`
     * for an explanation.
     * </pre>
     *
     * <code>LOGICAL_DNS = 2;</code>
     */
    public static final int LOGICAL_DNS_VALUE = 2;
    /**
     * <pre>
     * Refer to the :ref:`service discovery type&lt;arch_overview_service_discovery_types_eds&gt;`
     * for an explanation.
     * </pre>
     *
     * <code>EDS = 3;</code>
     */
    public static final int EDS_VALUE = 3;
    /**
     * <pre>
     * Refer to the :ref:`original destination discovery
     * type&lt;arch_overview_service_discovery_types_original_destination&gt;`
     * for an explanation.
     * </pre>
     *
     * <code>ORIGINAL_DST = 4;</code>
     */
    public static final int ORIGINAL_DST_VALUE = 4;


    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalArgumentException(
            "Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static DiscoveryType valueOf(int value) {
      return forNumber(value);
    }

    public static DiscoveryType forNumber(int value) {
      switch (value) {
        case 0: return STATIC;
        case 1: return STRICT_DNS;
        case 2: return LOGICAL_DNS;
        case 3: return EDS;
        case 4: return ORIGINAL_DST;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<DiscoveryType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static final com.google.protobuf.Internal.EnumLiteMap<
        DiscoveryType> internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<DiscoveryType>() {
            public DiscoveryType findValueByNumber(int number) {
              return DiscoveryType.forNumber(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(ordinal());
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return io.grpc.xds.shaded.envoy.api.v2.Cluster.getDescriptor().getEnumTypes().get(0);
    }

    private static final DiscoveryType[] VALUES = values();

    public static DiscoveryType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      if (desc.getIndex() == -1) {
        return UNRECOGNIZED;
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private DiscoveryType(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:envoy.api.v2.Cluster.DiscoveryType)
  }

  /**
   * <pre>
   * Refer to :ref:`load balancer type &lt;arch_overview_load_balancing_types&gt;` architecture
   * overview section for information on each type.
   * </pre>
   *
   * Protobuf enum {@code envoy.api.v2.Cluster.LbPolicy}
   */
  public enum LbPolicy
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <pre>
     * Refer to the :ref:`round robin load balancing
     * policy&lt;arch_overview_load_balancing_types_round_robin&gt;`
     * for an explanation.
     * </pre>
     *
     * <code>ROUND_ROBIN = 0;</code>
     */
    ROUND_ROBIN(0),
    /**
     * <pre>
     * Refer to the :ref:`least request load balancing
     * policy&lt;arch_overview_load_balancing_types_least_request&gt;`
     * for an explanation.
     * </pre>
     *
     * <code>LEAST_REQUEST = 1;</code>
     */
    LEAST_REQUEST(1),
    /**
     * <pre>
     * Refer to the :ref:`ring hash load balancing
     * policy&lt;arch_overview_load_balancing_types_ring_hash&gt;`
     * for an explanation.
     * </pre>
     *
     * <code>RING_HASH = 2;</code>
     */
    RING_HASH(2),
    /**
     * <pre>
     * Refer to the :ref:`random load balancing
     * policy&lt;arch_overview_load_balancing_types_random&gt;`
     * for an explanation.
     * </pre>
     *
     * <code>RANDOM = 3;</code>
     */
    RANDOM(3),
    /**
     * <pre>
     * Refer to the :ref:`original destination load balancing
     * policy&lt;arch_overview_load_balancing_types_original_destination&gt;`
     * for an explanation.
     * </pre>
     *
     * <code>ORIGINAL_DST_LB = 4;</code>
     */
    ORIGINAL_DST_LB(4),
    /**
     * <pre>
     * Refer to the :ref:`Maglev load balancing policy&lt;arch_overview_load_balancing_types_maglev&gt;`
     * for an explanation.
     * </pre>
     *
     * <code>MAGLEV = 5;</code>
     */
    MAGLEV(5),
    UNRECOGNIZED(-1),
    ;

    /**
     * <pre>
     * Refer to the :ref:`round robin load balancing
     * policy&lt;arch_overview_load_balancing_types_round_robin&gt;`
     * for an explanation.
     * </pre>
     *
     * <code>ROUND_ROBIN = 0;</code>
     */
    public static final int ROUND_ROBIN_VALUE = 0;
    /**
     * <pre>
     * Refer to the :ref:`least request load balancing
     * policy&lt;arch_overview_load_balancing_types_least_request&gt;`
     * for an explanation.
     * </pre>
     *
     * <code>LEAST_REQUEST = 1;</code>
     */
    public static final int LEAST_REQUEST_VALUE = 1;
    /**
     * <pre>
     * Refer to the :ref:`ring hash load balancing
     * policy&lt;arch_overview_load_balancing_types_ring_hash&gt;`
     * for an explanation.
     * </pre>
     *
     * <code>RING_HASH = 2;</code>
     */
    public static final int RING_HASH_VALUE = 2;
    /**
     * <pre>
     * Refer to the :ref:`random load balancing
     * policy&lt;arch_overview_load_balancing_types_random&gt;`
     * for an explanation.
     * </pre>
     *
     * <code>RANDOM = 3;</code>
     */
    public static final int RANDOM_VALUE = 3;
    /**
     * <pre>
     * Refer to the :ref:`original destination load balancing
     * policy&lt;arch_overview_load_balancing_types_original_destination&gt;`
     * for an explanation.
     * </pre>
     *
     * <code>ORIGINAL_DST_LB = 4;</code>
     */
    public static final int ORIGINAL_DST_LB_VALUE = 4;
    /**
     * <pre>
     * Refer to the :ref:`Maglev load balancing policy&lt;arch_overview_load_balancing_types_maglev&gt;`
     * for an explanation.
     * </pre>
     *
     * <code>MAGLEV = 5;</code>
     */
    public static final int MAGLEV_VALUE = 5;


    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalArgumentException(
            "Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static LbPolicy valueOf(int value) {
      return forNumber(value);
    }

    public static LbPolicy forNumber(int value) {
      switch (value) {
        case 0: return ROUND_ROBIN;
        case 1: return LEAST_REQUEST;
        case 2: return RING_HASH;
        case 3: return RANDOM;
        case 4: return ORIGINAL_DST_LB;
        case 5: return MAGLEV;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<LbPolicy>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static final com.google.protobuf.Internal.EnumLiteMap<
        LbPolicy> internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<LbPolicy>() {
            public LbPolicy findValueByNumber(int number) {
              return LbPolicy.forNumber(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(ordinal());
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return io.grpc.xds.shaded.envoy.api.v2.Cluster.getDescriptor().getEnumTypes().get(1);
    }

    private static final LbPolicy[] VALUES = values();

    public static LbPolicy valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      if (desc.getIndex() == -1) {
        return UNRECOGNIZED;
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private LbPolicy(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:envoy.api.v2.Cluster.LbPolicy)
  }

  /**
   * <pre>
   * When V4_ONLY is selected, the DNS resolver will only perform a lookup for
   * addresses in the IPv4 family. If V6_ONLY is selected, the DNS resolver will
   * only perform a lookup for addresses in the IPv6 family. If AUTO is
   * specified, the DNS resolver will first perform a lookup for addresses in
   * the IPv6 family and fallback to a lookup for addresses in the IPv4 family.
   * For cluster types other than
   * :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS&gt;` and
   * :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS&gt;`,
   * this setting is
   * ignored.
   * </pre>
   *
   * Protobuf enum {@code envoy.api.v2.Cluster.DnsLookupFamily}
   */
  public enum DnsLookupFamily
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>AUTO = 0;</code>
     */
    AUTO(0),
    /**
     * <code>V4_ONLY = 1;</code>
     */
    V4_ONLY(1),
    /**
     * <code>V6_ONLY = 2;</code>
     */
    V6_ONLY(2),
    UNRECOGNIZED(-1),
    ;

    /**
     * <code>AUTO = 0;</code>
     */
    public static final int AUTO_VALUE = 0;
    /**
     * <code>V4_ONLY = 1;</code>
     */
    public static final int V4_ONLY_VALUE = 1;
    /**
     * <code>V6_ONLY = 2;</code>
     */
    public static final int V6_ONLY_VALUE = 2;


    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalArgumentException(
            "Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static DnsLookupFamily valueOf(int value) {
      return forNumber(value);
    }

    public static DnsLookupFamily forNumber(int value) {
      switch (value) {
        case 0: return AUTO;
        case 1: return V4_ONLY;
        case 2: return V6_ONLY;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<DnsLookupFamily>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static final com.google.protobuf.Internal.EnumLiteMap<
        DnsLookupFamily> internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<DnsLookupFamily>() {
            public DnsLookupFamily findValueByNumber(int number) {
              return DnsLookupFamily.forNumber(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(ordinal());
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return io.grpc.xds.shaded.envoy.api.v2.Cluster.getDescriptor().getEnumTypes().get(2);
    }

    private static final DnsLookupFamily[] VALUES = values();

    public static DnsLookupFamily valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      if (desc.getIndex() == -1) {
        return UNRECOGNIZED;
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private DnsLookupFamily(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:envoy.api.v2.Cluster.DnsLookupFamily)
  }

  /**
   * Protobuf enum {@code envoy.api.v2.Cluster.ClusterProtocolSelection}
   */
  public enum ClusterProtocolSelection
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <pre>
     * Cluster can only operate on one of the possible upstream protocols (HTTP1.1, HTTP2).
     * If :ref:`http2_protocol_options &lt;envoy_api_field_Cluster.http2_protocol_options&gt;` are
     * present, HTTP2 will be used, otherwise HTTP1.1 will be used.
     * </pre>
     *
     * <code>USE_CONFIGURED_PROTOCOL = 0;</code>
     */
    USE_CONFIGURED_PROTOCOL(0),
    /**
     * <pre>
     * Use HTTP1.1 or HTTP2, depending on which one is used on the downstream connection.
     * </pre>
     *
     * <code>USE_DOWNSTREAM_PROTOCOL = 1;</code>
     */
    USE_DOWNSTREAM_PROTOCOL(1),
    UNRECOGNIZED(-1),
    ;

    /**
     * <pre>
     * Cluster can only operate on one of the possible upstream protocols (HTTP1.1, HTTP2).
     * If :ref:`http2_protocol_options &lt;envoy_api_field_Cluster.http2_protocol_options&gt;` are
     * present, HTTP2 will be used, otherwise HTTP1.1 will be used.
     * </pre>
     *
     * <code>USE_CONFIGURED_PROTOCOL = 0;</code>
     */
    public static final int USE_CONFIGURED_PROTOCOL_VALUE = 0;
    /**
     * <pre>
     * Use HTTP1.1 or HTTP2, depending on which one is used on the downstream connection.
     * </pre>
     *
     * <code>USE_DOWNSTREAM_PROTOCOL = 1;</code>
     */
    public static final int USE_DOWNSTREAM_PROTOCOL_VALUE = 1;


    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalArgumentException(
            "Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static ClusterProtocolSelection valueOf(int value) {
      return forNumber(value);
    }

    public static ClusterProtocolSelection forNumber(int value) {
      switch (value) {
        case 0: return USE_CONFIGURED_PROTOCOL;
        case 1: return USE_DOWNSTREAM_PROTOCOL;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<ClusterProtocolSelection>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static final com.google.protobuf.Internal.EnumLiteMap<
        ClusterProtocolSelection> internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<ClusterProtocolSelection>() {
            public ClusterProtocolSelection findValueByNumber(int number) {
              return ClusterProtocolSelection.forNumber(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(ordinal());
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return io.grpc.xds.shaded.envoy.api.v2.Cluster.getDescriptor().getEnumTypes().get(3);
    }

    private static final ClusterProtocolSelection[] VALUES = values();

    public static ClusterProtocolSelection valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      if (desc.getIndex() == -1) {
        return UNRECOGNIZED;
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private ClusterProtocolSelection(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:envoy.api.v2.Cluster.ClusterProtocolSelection)
  }

  public interface EdsClusterConfigOrBuilder extends
      // @@protoc_insertion_point(interface_extends:envoy.api.v2.Cluster.EdsClusterConfig)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Configuration for the source of EDS updates for this Cluster.
     * </pre>
     *
     * <code>.envoy.api.v2.core.ConfigSource eds_config = 1;</code>
     */
    boolean hasEdsConfig();
    /**
     * <pre>
     * Configuration for the source of EDS updates for this Cluster.
     * </pre>
     *
     * <code>.envoy.api.v2.core.ConfigSource eds_config = 1;</code>
     */
    io.grpc.xds.shaded.envoy.api.v2.core.ConfigSource getEdsConfig();
    /**
     * <pre>
     * Configuration for the source of EDS updates for this Cluster.
     * </pre>
     *
     * <code>.envoy.api.v2.core.ConfigSource eds_config = 1;</code>
     */
    io.grpc.xds.shaded.envoy.api.v2.core.ConfigSourceOrBuilder getEdsConfigOrBuilder();

    /**
     * <pre>
     * Optional alternative to cluster name to present to EDS. This does not
     * have the same restrictions as cluster name, i.e. it may be arbitrary
     * length.
     * </pre>
     *
     * <code>string service_name = 2;</code>
     */
    java.lang.String getServiceName();
    /**
     * <pre>
     * Optional alternative to cluster name to present to EDS. This does not
     * have the same restrictions as cluster name, i.e. it may be arbitrary
     * length.
     * </pre>
     *
     * <code>string service_name = 2;</code>
     */
    com.google.protobuf.ByteString
        getServiceNameBytes();
  }
  /**
   * <pre>
   * Only valid when discovery type is EDS.
   * </pre>
   *
   * Protobuf type {@code envoy.api.v2.Cluster.EdsClusterConfig}
   */
  public  static final class EdsClusterConfig extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:envoy.api.v2.Cluster.EdsClusterConfig)
      EdsClusterConfigOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use EdsClusterConfig.newBuilder() to construct.
    private EdsClusterConfig(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private EdsClusterConfig() {
      serviceName_ = "";
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private EdsClusterConfig(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!parseUnknownFieldProto3(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
            case 10: {
              io.grpc.xds.shaded.envoy.api.v2.core.ConfigSource.Builder subBuilder = null;
              if (edsConfig_ != null) {
                subBuilder = edsConfig_.toBuilder();
              }
              edsConfig_ = input.readMessage(io.grpc.xds.shaded.envoy.api.v2.core.ConfigSource.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(edsConfig_);
                edsConfig_ = subBuilder.buildPartial();
              }

              break;
            }
            case 18: {
              java.lang.String s = input.readStringRequireUtf8();

              serviceName_ = s;
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.grpc.xds.shaded.envoy.api.v2.Cds.internal_static_envoy_api_v2_Cluster_EdsClusterConfig_descriptor;
    }

    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.grpc.xds.shaded.envoy.api.v2.Cds.internal_static_envoy_api_v2_Cluster_EdsClusterConfig_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.grpc.xds.shaded.envoy.api.v2.Cluster.EdsClusterConfig.class, io.grpc.xds.shaded.envoy.api.v2.Cluster.EdsClusterConfig.Builder.class);
    }

    public static final int EDS_CONFIG_FIELD_NUMBER = 1;
    private io.grpc.xds.shaded.envoy.api.v2.core.ConfigSource edsConfig_;
    /**
     * <pre>
     * Configuration for the source of EDS updates for this Cluster.
     * </pre>
     *
     * <code>.envoy.api.v2.core.ConfigSource eds_config = 1;</code>
     */
    public boolean hasEdsConfig() {
      return edsConfig_ != null;
    }
    /**
     * <pre>
     * Configuration for the source of EDS updates for this Cluster.
     * </pre>
     *
     * <code>.envoy.api.v2.core.ConfigSource eds_config = 1;</code>
     */
    public io.grpc.xds.shaded.envoy.api.v2.core.ConfigSource getEdsConfig() {
      return edsConfig_ == null ? io.grpc.xds.shaded.envoy.api.v2.core.ConfigSource.getDefaultInstance() : edsConfig_;
    }
    /**
     * <pre>
     * Configuration for the source of EDS updates for this Cluster.
     * </pre>
     *
     * <code>.envoy.api.v2.core.ConfigSource eds_config = 1;</code>
     */
    public io.grpc.xds.shaded.envoy.api.v2.core.ConfigSourceOrBuilder getEdsConfigOrBuilder() {
      return getEdsConfig();
    }

    public static final int SERVICE_NAME_FIELD_NUMBER = 2;
    private volatile java.lang.Object serviceName_;
    /**
     * <pre>
     * Optional alternative to cluster name to present to EDS. This does not
     * have the same restrictions as cluster name, i.e. it may be arbitrary
     * length.
     * </pre>
     *
     * <code>string service_name = 2;</code>
     */
    public java.lang.String getServiceName() {
      java.lang.Object ref = serviceName_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        serviceName_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * Optional alternative to cluster name to present to EDS. This does not
     * have the same restrictions as cluster name, i.e. it may be arbitrary
     * length.
     * </pre>
     *
     * <code>string service_name = 2;</code>
     */
    public com.google.protobuf.ByteString
        getServiceNameBytes() {
      java.lang.Object ref = serviceName_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        serviceName_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    private byte memoizedIsInitialized = -1;
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (edsConfig_ != null) {
        output.writeMessage(1, getEdsConfig());
      }
      if (!getServiceNameBytes().isEmpty()) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 2, serviceName_);
      }
      unknownFields.writeTo(output);
    }

    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (edsConfig_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, getEdsConfig());
      }
      if (!getServiceNameBytes().isEmpty()) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(2, serviceName_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.grpc.xds.shaded.envoy.api.v2.Cluster.EdsClusterConfig)) {
        return super.equals(obj);
      }
      io.grpc.xds.shaded.envoy.api.v2.Cluster.EdsClusterConfig other = (io.grpc.xds.shaded.envoy.api.v2.Cluster.EdsClusterConfig) obj;

      boolean result = true;
      result = result && (hasEdsConfig() == other.hasEdsConfig());
      if (hasEdsConfig()) {
        result = result && getEdsConfig()
            .equals(other.getEdsConfig());
      }
      result = result && getServiceName()
          .equals(other.getServiceName());
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasEdsConfig()) {
        hash = (37 * hash) + EDS_CONFIG_FIELD_NUMBER;
        hash = (53 * hash) + getEdsConfig().hashCode();
      }
      hash = (37 * hash) + SERVICE_NAME_FIELD_NUMBER;
      hash = (53 * hash) + getServiceName().hashCode();
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.grpc.xds.shaded.envoy.api.v2.Cluster.EdsClusterConfig parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.grpc.xds.shaded.envoy.api.v2.Cluster.EdsClusterConfig parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.grpc.xds.shaded.envoy.api.v2.Cluster.EdsClusterConfig parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.grpc.xds.shaded.envoy.api.v2.Cluster.EdsClusterConfig parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.grpc.xds.shaded.envoy.api.v2.Cluster.EdsClusterConfig parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.grpc.xds.shaded.envoy.api.v2.Cluster.EdsClusterConfig parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.grpc.xds.shaded.envoy.api.v2.Cluster.EdsClusterConfig parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.grpc.xds.shaded.envoy.api.v2.Cluster.EdsClusterConfig parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.grpc.xds.shaded.envoy.api.v2.Cluster.EdsClusterConfig parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static io.grpc.xds.shaded.envoy.api.v2.Cluster.EdsClusterConfig parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.grpc.xds.shaded.envoy.api.v2.Cluster.EdsClusterConfig parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.grpc.xds.shaded.envoy.api.v2.Cluster.EdsClusterConfig parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.grpc.xds.shaded.envoy.api.v2.Cluster.EdsClusterConfig prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Only valid when discovery type is EDS.
     * </pre>
     *
     * Protobuf type {@code envoy.api.v2.Cluster.EdsClusterConfig}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:envoy.api.v2.Cluster.EdsClusterConfig)
        io.grpc.xds.shaded.envoy.api.v2.Cluster.EdsClusterConfigOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.grpc.xds.shaded.envoy.api.v2.Cds.internal_static_envoy_api_v2_Cluster_EdsClusterConfig_descriptor;
      }

      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.grpc.xds.shaded.envoy.api.v2.Cds.internal_static_envoy_api_v2_Cluster_EdsClusterConfig_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.grpc.xds.shaded.envoy.api.v2.Cluster.EdsClusterConfig.class, io.grpc.xds.shaded.envoy.api.v2.Cluster.EdsClusterConfig.Builder.class);
      }

      // Construct using io.grpc.xds.shaded.envoy.api.v2.Cluster.EdsClusterConfig.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      public Builder clear() {
        super.clear();
        if (edsConfigBuilder_ == null) {
          edsConfig_ = null;
        } else {
          edsConfig_ = null;
          edsConfigBuilder_ = null;
        }
        serviceName_ = "";

        return this;
      }

      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.grpc.xds.shaded.envoy.api.v2.Cds.internal_static_envoy_api_v2_Cluster_EdsClusterConfig_descriptor;
      }

      public io.grpc.xds.shaded.envoy.api.v2.Cluster.EdsClusterConfig getDefaultInstanceForType() {
        return io.grpc.xds.shaded.envoy.api.v2.Cluster.EdsClusterConfig.getDefaultInstance();
      }

      public io.grpc.xds.shaded.envoy.api.v2.Cluster.EdsClusterConfig build() {
        io.grpc.xds.shaded.envoy.api.v2.Cluster.EdsClusterConfig result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      public io.grpc.xds.shaded.envoy.api.v2.Cluster.EdsClusterConfig buildPartial() {
        io.grpc.xds.shaded.envoy.api.v2.Cluster.EdsClusterConfig result = new io.grpc.xds.shaded.envoy.api.v2.Cluster.EdsClusterConfig(this);
        if (edsConfigBuilder_ == null) {
          result.edsConfig_ = edsConfig_;
        } else {
          result.edsConfig_ = edsConfigBuilder_.build();
        }
        result.serviceName_ = serviceName_;
        onBuilt();
        return result;
      }

      public Builder clone() {
        return (Builder) super.clone();
      }
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.grpc.xds.shaded.envoy.api.v2.Cluster.EdsClusterConfig) {
          return mergeFrom((io.grpc.xds.shaded.envoy.api.v2.Cluster.EdsClusterConfig)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.grpc.xds.shaded.envoy.api.v2.Cluster.EdsClusterConfig other) {
        if (other == io.grpc.xds.shaded.envoy.api.v2.Cluster.EdsClusterConfig.getDefaultInstance()) return this;
        if (other.hasEdsConfig()) {
          mergeEdsConfig(other.getEdsConfig());
        }
        if (!other.getServiceName().isEmpty()) {
          serviceName_ = other.serviceName_;
          onChanged();
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      public final boolean isInitialized() {
        return true;
      }

      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.grpc.xds.shaded.envoy.api.v2.Cluster.EdsClusterConfig parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (io.grpc.xds.shaded.envoy.api.v2.Cluster.EdsClusterConfig) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }

      private io.grpc.xds.shaded.envoy.api.v2.core.ConfigSource edsConfig_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          io.grpc.xds.shaded.envoy.api.v2.core.ConfigSource, io.grpc.xds.shaded.envoy.api.v2.core.ConfigSource.Builder, io.grpc.xds.shaded.envoy.api.v2.core.ConfigSourceOrBuilder> edsConfigBuilder_;
      /**
       * <pre>
       * Configuration for the source of EDS updates for this Cluster.
       * </pre>
       *
       * <code>.envoy.api.v2.core.ConfigSource eds_config = 1;</code>
       */
      public boolean hasEdsConfig() {
        return edsConfigBuilder_ != null || edsConfig_ != null;
      }
      /**
       * <pre>
       * Configuration for the source of EDS updates for this Cluster.
       * </pre>
       *
       * <code>.envoy.api.v2.core.ConfigSource eds_config = 1;</code>
       */
      public io.grpc.xds.shaded.envoy.api.v2.core.ConfigSource getEdsConfig() {
        if (edsConfigBuilder_ == null) {
          return edsConfig_ == null ? io.grpc.xds.shaded.envoy.api.v2.core.ConfigSource.getDefaultInstance() : edsConfig_;
        } else {
          return edsConfigBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Configuration for the source of EDS updates for this Cluster.
       * </pre>
       *
       * <code>.envoy.api.v2.core.ConfigSource eds_config = 1;</code>
       */
      public Builder setEdsConfig(io.grpc.xds.shaded.envoy.api.v2.core.ConfigSource value) {
        if (edsConfigBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          edsConfig_ = value;
          onChanged();
        } else {
          edsConfigBuilder_.setMessage(value);
        }

        return this;
      }
      /**
       * <pre>
       * Configuration for the source of EDS updates for this Cluster.
       * </pre>
       *
       * <code>.envoy.api.v2.core.ConfigSource eds_config = 1;</code>
       */
      public Builder setEdsConfig(
          io.grpc.xds.shaded.envoy.api.v2.core.ConfigSource.Builder builderForValue) {
        if (edsConfigBuilder_ == null) {
          edsConfig_ = builderForValue.build();
          onChanged();
        } else {
          edsConfigBuilder_.setMessage(builderForValue.build());
        }

        return this;
      }
      /**
       * <pre>
       * Configuration for the source of EDS updates for this Cluster.
       * </pre>
       *
       * <code>.envoy.api.v2.core.ConfigSource eds_config = 1;</code>
       */
      public Builder mergeEdsConfig(io.grpc.xds.shaded.envoy.api.v2.core.ConfigSource value) {
        if (edsConfigBuilder_ == null) {
          if (edsConfig_ != null) {
            edsConfig_ =
              io.grpc.xds.shaded.envoy.api.v2.core.ConfigSource.newBuilder(edsConfig_).mergeFrom(value).buildPartial();
          } else {
            edsConfig_ = value;
          }
          onChanged();
        } else {
          edsConfigBuilder_.mergeFrom(value);
        }

        return this;
      }
      /**
       * <pre>
       * Configuration for the source of EDS updates for this Cluster.
       * </pre>
       *
       * <code>.envoy.api.v2.core.ConfigSource eds_config = 1;</code>
       */
      public Builder clearEdsConfig() {
        if (edsConfigBuilder_ == null) {
          edsConfig_ = null;
          onChanged();
        } else {
          edsConfig_ = null;
          edsConfigBuilder_ = null;
        }

        return this;
      }
      /**
       * <pre>
       * Configuration for the source of EDS updates for this Cluster.
       * </pre>
       *
       * <code>.envoy.api.v2.core.ConfigSource eds_config = 1;</code>
       */
      public io.grpc.xds.shaded.envoy.api.v2.core.ConfigSource.Builder getEdsConfigBuilder() {
        
        onChanged();
        return getEdsConfigFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Configuration for the source of EDS updates for this Cluster.
       * </pre>
       *
       * <code>.envoy.api.v2.core.ConfigSource eds_config = 1;</code>
       */
      public io.grpc.xds.shaded.envoy.api.v2.core.ConfigSourceOrBuilder getEdsConfigOrBuilder() {
        if (edsConfigBuilder_ != null) {
          return edsConfigBuilder_.getMessageOrBuilder();
        } else {
          return edsConfig_ == null ?
              io.grpc.xds.shaded.envoy.api.v2.core.ConfigSource.getDefaultInstance() : edsConfig_;
        }
      }
      /**
       * <pre>
       * Configuration for the source of EDS updates for this Cluster.
       * </pre>
       *
       * <code>.envoy.api.v2.core.ConfigSource eds_config = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          io.grpc.xds.shaded.envoy.api.v2.core.ConfigSource, io.grpc.xds.shaded.envoy.api.v2.core.ConfigSource.Builder, io.grpc.xds.shaded.envoy.api.v2.core.ConfigSourceOrBuilder> 
          getEdsConfigFieldBuilder() {
        if (edsConfigBuilder_ == null) {
          edsConfigBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              io.grpc.xds.shaded.envoy.api.v2.core.ConfigSource, io.grpc.xds.shaded.envoy.api.v2.core.ConfigSource.Builder, io.grpc.xds.shaded.envoy.api.v2.core.ConfigSourceOrBuilder>(
                  getEdsConfig(),
                  getParentForChildren(),
                  isClean());
          edsConfig_ = null;
        }
        return edsConfigBuilder_;
      }

      private java.lang.Object serviceName_ = "";
      /**
       * <pre>
       * Optional alternative to cluster name to present to EDS. This does not
       * have the same restrictions as cluster name, i.e. it may be arbitrary
       * length.
       * </pre>
       *
       * <code>string service_name = 2;</code>
       */
      public java.lang.String getServiceName() {
        java.lang.Object ref = serviceName_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          serviceName_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Optional alternative to cluster name to present to EDS. This does not
       * have the same restrictions as cluster name, i.e. it may be arbitrary
       * length.
       * </pre>
       *
       * <code>string service_name = 2;</code>
       */
      public com.google.protobuf.ByteString
          getServiceNameBytes() {
        java.lang.Object ref = serviceName_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          serviceName_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Optional alternative to cluster name to present to EDS. This does not
       * have the same restrictions as cluster name, i.e. it may be arbitrary
       * length.
       * </pre>
       *
       * <code>string service_name = 2;</code>
       */
      public Builder setServiceName(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        serviceName_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Optional alternative to cluster name to present to EDS. This does not
       * have the same restrictions as cluster name, i.e. it may be arbitrary
       * length.
       * </pre>
       *
       * <code>string service_name = 2;</code>
       */
      public Builder clearServiceName() {
        
        serviceName_ = getDefaultInstance().getServiceName();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Optional alternative to cluster name to present to EDS. This does not
       * have the same restrictions as cluster name, i.e. it may be arbitrary
       * length.
       * </pre>
       *
       * <code>string service_name = 2;</code>
       */
      public Builder setServiceNameBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        serviceName_ = value;
        onChanged();
        return this;
      }
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFieldsProto3(unknownFields);
      }

      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:envoy.api.v2.Cluster.EdsClusterConfig)
    }

    // @@protoc_insertion_point(class_scope:envoy.api.v2.Cluster.EdsClusterConfig)
    private static final io.grpc.xds.shaded.envoy.api.v2.Cluster.EdsClusterConfig DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.grpc.xds.shaded.envoy.api.v2.Cluster.EdsClusterConfig();
    }

    public static io.grpc.xds.shaded.envoy.api.v2.Cluster.EdsClusterConfig getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<EdsClusterConfig>
        PARSER = new com.google.protobuf.AbstractParser<EdsClusterConfig>() {
      public EdsClusterConfig parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new EdsClusterConfig(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<EdsClusterConfig> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<EdsClusterConfig> getParserForType() {
      return PARSER;
    }

    public io.grpc.xds.shaded.envoy.api.v2.Cluster.EdsClusterConfig getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface LbSubsetConfigOrBuilder extends
      // @@protoc_insertion_point(interface_extends:envoy.api.v2.Cluster.LbSubsetConfig)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * The behavior used when no endpoint subset matches the selected route's
     * metadata. The value defaults to
     * :ref:`NO_FALLBACK&lt;envoy_api_enum_value_Cluster.LbSubsetConfig.LbSubsetFallbackPolicy.NO_FALLBACK&gt;`.
     * </pre>
     *
     * <code>.envoy.api.v2.Cluster.LbSubsetConfig.LbSubsetFallbackPolicy fallback_policy = 1 [(.validate.rules) = { ... }</code>
     */
    int getFallbackPolicyValue();
    /**
     * <pre>
     * The behavior used when no endpoint subset matches the selected route's
     * metadata. The value defaults to
     * :ref:`NO_FALLBACK&lt;envoy_api_enum_value_Cluster.LbSubsetConfig.LbSubsetFallbackPolicy.NO_FALLBACK&gt;`.
     * </pre>
     *
     * <code>.envoy.api.v2.Cluster.LbSubsetConfig.LbSubsetFallbackPolicy fallback_policy = 1 [(.validate.rules) = { ... }</code>
     */
    io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfig.LbSubsetFallbackPolicy getFallbackPolicy();

    /**
     * <pre>
     * Specifies the default subset of endpoints used during fallback if
     * fallback_policy is
     * :ref:`DEFAULT_SUBSET&lt;envoy_api_enum_value_Cluster.LbSubsetConfig.LbSubsetFallbackPolicy.DEFAULT_SUBSET&gt;`.
     * Each field in default_subset is
     * compared to the matching LbEndpoint.Metadata under the *envoy.lb*
     * namespace. It is valid for no hosts to match, in which case the behavior
     * is the same as a fallback_policy of
     * :ref:`NO_FALLBACK&lt;envoy_api_enum_value_Cluster.LbSubsetConfig.LbSubsetFallbackPolicy.NO_FALLBACK&gt;`.
     * </pre>
     *
     * <code>.google.protobuf.Struct default_subset = 2;</code>
     */
    boolean hasDefaultSubset();
    /**
     * <pre>
     * Specifies the default subset of endpoints used during fallback if
     * fallback_policy is
     * :ref:`DEFAULT_SUBSET&lt;envoy_api_enum_value_Cluster.LbSubsetConfig.LbSubsetFallbackPolicy.DEFAULT_SUBSET&gt;`.
     * Each field in default_subset is
     * compared to the matching LbEndpoint.Metadata under the *envoy.lb*
     * namespace. It is valid for no hosts to match, in which case the behavior
     * is the same as a fallback_policy of
     * :ref:`NO_FALLBACK&lt;envoy_api_enum_value_Cluster.LbSubsetConfig.LbSubsetFallbackPolicy.NO_FALLBACK&gt;`.
     * </pre>
     *
     * <code>.google.protobuf.Struct default_subset = 2;</code>
     */
    com.google.protobuf.Struct getDefaultSubset();
    /**
     * <pre>
     * Specifies the default subset of endpoints used during fallback if
     * fallback_policy is
     * :ref:`DEFAULT_SUBSET&lt;envoy_api_enum_value_Cluster.LbSubsetConfig.LbSubsetFallbackPolicy.DEFAULT_SUBSET&gt;`.
     * Each field in default_subset is
     * compared to the matching LbEndpoint.Metadata under the *envoy.lb*
     * namespace. It is valid for no hosts to match, in which case the behavior
     * is the same as a fallback_policy of
     * :ref:`NO_FALLBACK&lt;envoy_api_enum_value_Cluster.LbSubsetConfig.LbSubsetFallbackPolicy.NO_FALLBACK&gt;`.
     * </pre>
     *
     * <code>.google.protobuf.Struct default_subset = 2;</code>
     */
    com.google.protobuf.StructOrBuilder getDefaultSubsetOrBuilder();

    /**
     * <pre>
     * For each entry, LbEndpoint.Metadata's
     * *envoy.lb* namespace is traversed and a subset is created for each unique
     * combination of key and value. For example:
     * .. code-block:: json
     *   { "subset_selectors": [
     *       { "keys": [ "version" ] },
     *       { "keys": [ "stage", "hardware_type" ] }
     *   ]}
     * A subset is matched when the metadata from the selected route and
     * weighted cluster contains the same keys and values as the subset's
     * metadata. The same host may appear in multiple subsets.
     * </pre>
     *
     * <code>repeated .envoy.api.v2.Cluster.LbSubsetConfig.LbSubsetSelector subset_selectors = 3;</code>
     */
    java.util.List<io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfig.LbSubsetSelector> 
        getSubsetSelectorsList();
    /**
     * <pre>
     * For each entry, LbEndpoint.Metadata's
     * *envoy.lb* namespace is traversed and a subset is created for each unique
     * combination of key and value. For example:
     * .. code-block:: json
     *   { "subset_selectors": [
     *       { "keys": [ "version" ] },
     *       { "keys": [ "stage", "hardware_type" ] }
     *   ]}
     * A subset is matched when the metadata from the selected route and
     * weighted cluster contains the same keys and values as the subset's
     * metadata. The same host may appear in multiple subsets.
     * </pre>
     *
     * <code>repeated .envoy.api.v2.Cluster.LbSubsetConfig.LbSubsetSelector subset_selectors = 3;</code>
     */
    io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfig.LbSubsetSelector getSubsetSelectors(int index);
    /**
     * <pre>
     * For each entry, LbEndpoint.Metadata's
     * *envoy.lb* namespace is traversed and a subset is created for each unique
     * combination of key and value. For example:
     * .. code-block:: json
     *   { "subset_selectors": [
     *       { "keys": [ "version" ] },
     *       { "keys": [ "stage", "hardware_type" ] }
     *   ]}
     * A subset is matched when the metadata from the selected route and
     * weighted cluster contains the same keys and values as the subset's
     * metadata. The same host may appear in multiple subsets.
     * </pre>
     *
     * <code>repeated .envoy.api.v2.Cluster.LbSubsetConfig.LbSubsetSelector subset_selectors = 3;</code>
     */
    int getSubsetSelectorsCount();
    /**
     * <pre>
     * For each entry, LbEndpoint.Metadata's
     * *envoy.lb* namespace is traversed and a subset is created for each unique
     * combination of key and value. For example:
     * .. code-block:: json
     *   { "subset_selectors": [
     *       { "keys": [ "version" ] },
     *       { "keys": [ "stage", "hardware_type" ] }
     *   ]}
     * A subset is matched when the metadata from the selected route and
     * weighted cluster contains the same keys and values as the subset's
     * metadata. The same host may appear in multiple subsets.
     * </pre>
     *
     * <code>repeated .envoy.api.v2.Cluster.LbSubsetConfig.LbSubsetSelector subset_selectors = 3;</code>
     */
    java.util.List<? extends io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfig.LbSubsetSelectorOrBuilder> 
        getSubsetSelectorsOrBuilderList();
    /**
     * <pre>
     * For each entry, LbEndpoint.Metadata's
     * *envoy.lb* namespace is traversed and a subset is created for each unique
     * combination of key and value. For example:
     * .. code-block:: json
     *   { "subset_selectors": [
     *       { "keys": [ "version" ] },
     *       { "keys": [ "stage", "hardware_type" ] }
     *   ]}
     * A subset is matched when the metadata from the selected route and
     * weighted cluster contains the same keys and values as the subset's
     * metadata. The same host may appear in multiple subsets.
     * </pre>
     *
     * <code>repeated .envoy.api.v2.Cluster.LbSubsetConfig.LbSubsetSelector subset_selectors = 3;</code>
     */
    io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfig.LbSubsetSelectorOrBuilder getSubsetSelectorsOrBuilder(
        int index);

    /**
     * <pre>
     * If true, routing to subsets will take into account the localities and locality weights of the
     * endpoints when making the routing decision.
     * There are some potential pitfalls associated with enabling this feature, as the resulting
     * traffic split after applying both a subset match and locality weights might be undesirable.
     * Consider for example a situation in which you have 50/50 split across two localities X/Y
     * which have 100 hosts each without subsetting. If the subset LB results in X having only 1
     * host selected but Y having 100, then a lot more load is being dumped on the single host in X
     * than originally anticipated in the load balancing assignment delivered via EDS.
     * </pre>
     *
     * <code>bool locality_weight_aware = 4;</code>
     */
    boolean getLocalityWeightAware();

    /**
     * <pre>
     * When used with locality_weight_aware, scales the weight of each locality by the ratio
     * of hosts in the subset vs hosts in the original subset. This aims to even out the load
     * going to an individual locality if said locality is disproportionally affected by the
     * subset predicate.
     * </pre>
     *
     * <code>bool scale_locality_weight = 5;</code>
     */
    boolean getScaleLocalityWeight();
  }
  /**
   * <pre>
   * Optionally divide the endpoints in this cluster into subsets defined by
   * endpoint metadata and selected by route and weighted cluster metadata.
   * </pre>
   *
   * Protobuf type {@code envoy.api.v2.Cluster.LbSubsetConfig}
   */
  public  static final class LbSubsetConfig extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:envoy.api.v2.Cluster.LbSubsetConfig)
      LbSubsetConfigOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use LbSubsetConfig.newBuilder() to construct.
    private LbSubsetConfig(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private LbSubsetConfig() {
      fallbackPolicy_ = 0;
      subsetSelectors_ = java.util.Collections.emptyList();
      localityWeightAware_ = false;
      scaleLocalityWeight_ = false;
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private LbSubsetConfig(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!parseUnknownFieldProto3(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
            case 8: {
              int rawValue = input.readEnum();

              fallbackPolicy_ = rawValue;
              break;
            }
            case 18: {
              com.google.protobuf.Struct.Builder subBuilder = null;
              if (defaultSubset_ != null) {
                subBuilder = defaultSubset_.toBuilder();
              }
              defaultSubset_ = input.readMessage(com.google.protobuf.Struct.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(defaultSubset_);
                defaultSubset_ = subBuilder.buildPartial();
              }

              break;
            }
            case 26: {
              if (!((mutable_bitField0_ & 0x00000004) == 0x00000004)) {
                subsetSelectors_ = new java.util.ArrayList<io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfig.LbSubsetSelector>();
                mutable_bitField0_ |= 0x00000004;
              }
              subsetSelectors_.add(
                  input.readMessage(io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfig.LbSubsetSelector.parser(), extensionRegistry));
              break;
            }
            case 32: {

              localityWeightAware_ = input.readBool();
              break;
            }
            case 40: {

              scaleLocalityWeight_ = input.readBool();
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000004) == 0x00000004)) {
          subsetSelectors_ = java.util.Collections.unmodifiableList(subsetSelectors_);
        }
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.grpc.xds.shaded.envoy.api.v2.Cds.internal_static_envoy_api_v2_Cluster_LbSubsetConfig_descriptor;
    }

    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.grpc.xds.shaded.envoy.api.v2.Cds.internal_static_envoy_api_v2_Cluster_LbSubsetConfig_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfig.class, io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfig.Builder.class);
    }

    /**
     * <pre>
     * If NO_FALLBACK is selected, a result
     * equivalent to no healthy hosts is reported. If ANY_ENDPOINT is selected,
     * any cluster endpoint may be returned (subject to policy, health checks,
     * etc). If DEFAULT_SUBSET is selected, load balancing is performed over the
     * endpoints matching the values from the default_subset field.
     * </pre>
     *
     * Protobuf enum {@code envoy.api.v2.Cluster.LbSubsetConfig.LbSubsetFallbackPolicy}
     */
    public enum LbSubsetFallbackPolicy
        implements com.google.protobuf.ProtocolMessageEnum {
      /**
       * <code>NO_FALLBACK = 0;</code>
       */
      NO_FALLBACK(0),
      /**
       * <code>ANY_ENDPOINT = 1;</code>
       */
      ANY_ENDPOINT(1),
      /**
       * <code>DEFAULT_SUBSET = 2;</code>
       */
      DEFAULT_SUBSET(2),
      UNRECOGNIZED(-1),
      ;

      /**
       * <code>NO_FALLBACK = 0;</code>
       */
      public static final int NO_FALLBACK_VALUE = 0;
      /**
       * <code>ANY_ENDPOINT = 1;</code>
       */
      public static final int ANY_ENDPOINT_VALUE = 1;
      /**
       * <code>DEFAULT_SUBSET = 2;</code>
       */
      public static final int DEFAULT_SUBSET_VALUE = 2;


      public final int getNumber() {
        if (this == UNRECOGNIZED) {
          throw new java.lang.IllegalArgumentException(
              "Can't get the number of an unknown enum value.");
        }
        return value;
      }

      /**
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static LbSubsetFallbackPolicy valueOf(int value) {
        return forNumber(value);
      }

      public static LbSubsetFallbackPolicy forNumber(int value) {
        switch (value) {
          case 0: return NO_FALLBACK;
          case 1: return ANY_ENDPOINT;
          case 2: return DEFAULT_SUBSET;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<LbSubsetFallbackPolicy>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          LbSubsetFallbackPolicy> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<LbSubsetFallbackPolicy>() {
              public LbSubsetFallbackPolicy findValueByNumber(int number) {
                return LbSubsetFallbackPolicy.forNumber(number);
              }
            };

      public final com.google.protobuf.Descriptors.EnumValueDescriptor
          getValueDescriptor() {
        return getDescriptor().getValues().get(ordinal());
      }
      public final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptorForType() {
        return getDescriptor();
      }
      public static final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptor() {
        return io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfig.getDescriptor().getEnumTypes().get(0);
      }

      private static final LbSubsetFallbackPolicy[] VALUES = values();

      public static LbSubsetFallbackPolicy valueOf(
          com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
        if (desc.getType() != getDescriptor()) {
          throw new java.lang.IllegalArgumentException(
            "EnumValueDescriptor is not for this type.");
        }
        if (desc.getIndex() == -1) {
          return UNRECOGNIZED;
        }
        return VALUES[desc.getIndex()];
      }

      private final int value;

      private LbSubsetFallbackPolicy(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:envoy.api.v2.Cluster.LbSubsetConfig.LbSubsetFallbackPolicy)
    }

    public interface LbSubsetSelectorOrBuilder extends
        // @@protoc_insertion_point(interface_extends:envoy.api.v2.Cluster.LbSubsetConfig.LbSubsetSelector)
        com.google.protobuf.MessageOrBuilder {

      /**
       * <pre>
       * List of keys to match with the weighted cluster metadata.
       * </pre>
       *
       * <code>repeated string keys = 1;</code>
       */
      java.util.List<java.lang.String>
          getKeysList();
      /**
       * <pre>
       * List of keys to match with the weighted cluster metadata.
       * </pre>
       *
       * <code>repeated string keys = 1;</code>
       */
      int getKeysCount();
      /**
       * <pre>
       * List of keys to match with the weighted cluster metadata.
       * </pre>
       *
       * <code>repeated string keys = 1;</code>
       */
      java.lang.String getKeys(int index);
      /**
       * <pre>
       * List of keys to match with the weighted cluster metadata.
       * </pre>
       *
       * <code>repeated string keys = 1;</code>
       */
      com.google.protobuf.ByteString
          getKeysBytes(int index);
    }
    /**
     * <pre>
     * Specifications for subsets.
     * </pre>
     *
     * Protobuf type {@code envoy.api.v2.Cluster.LbSubsetConfig.LbSubsetSelector}
     */
    public  static final class LbSubsetSelector extends
        com.google.protobuf.GeneratedMessageV3 implements
        // @@protoc_insertion_point(message_implements:envoy.api.v2.Cluster.LbSubsetConfig.LbSubsetSelector)
        LbSubsetSelectorOrBuilder {
    private static final long serialVersionUID = 0L;
      // Use LbSubsetSelector.newBuilder() to construct.
      private LbSubsetSelector(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
        super(builder);
      }
      private LbSubsetSelector() {
        keys_ = com.google.protobuf.LazyStringArrayList.EMPTY;
      }

      @java.lang.Override
      public final com.google.protobuf.UnknownFieldSet
      getUnknownFields() {
        return this.unknownFields;
      }
      private LbSubsetSelector(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        this();
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        int mutable_bitField0_ = 0;
        com.google.protobuf.UnknownFieldSet.Builder unknownFields =
            com.google.protobuf.UnknownFieldSet.newBuilder();
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              default: {
                if (!parseUnknownFieldProto3(
                    input, unknownFields, extensionRegistry, tag)) {
                  done = true;
                }
                break;
              }
              case 10: {
                java.lang.String s = input.readStringRequireUtf8();
                if (!((mutable_bitField0_ & 0x00000001) == 0x00000001)) {
                  keys_ = new com.google.protobuf.LazyStringArrayList();
                  mutable_bitField0_ |= 0x00000001;
                }
                keys_.add(s);
                break;
              }
            }
          }
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(this);
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(
              e).setUnfinishedMessage(this);
        } finally {
          if (((mutable_bitField0_ & 0x00000001) == 0x00000001)) {
            keys_ = keys_.getUnmodifiableView();
          }
          this.unknownFields = unknownFields.build();
          makeExtensionsImmutable();
        }
      }
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.grpc.xds.shaded.envoy.api.v2.Cds.internal_static_envoy_api_v2_Cluster_LbSubsetConfig_LbSubsetSelector_descriptor;
      }

      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.grpc.xds.shaded.envoy.api.v2.Cds.internal_static_envoy_api_v2_Cluster_LbSubsetConfig_LbSubsetSelector_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfig.LbSubsetSelector.class, io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfig.LbSubsetSelector.Builder.class);
      }

      public static final int KEYS_FIELD_NUMBER = 1;
      private com.google.protobuf.LazyStringList keys_;
      /**
       * <pre>
       * List of keys to match with the weighted cluster metadata.
       * </pre>
       *
       * <code>repeated string keys = 1;</code>
       */
      public com.google.protobuf.ProtocolStringList
          getKeysList() {
        return keys_;
      }
      /**
       * <pre>
       * List of keys to match with the weighted cluster metadata.
       * </pre>
       *
       * <code>repeated string keys = 1;</code>
       */
      public int getKeysCount() {
        return keys_.size();
      }
      /**
       * <pre>
       * List of keys to match with the weighted cluster metadata.
       * </pre>
       *
       * <code>repeated string keys = 1;</code>
       */
      public java.lang.String getKeys(int index) {
        return keys_.get(index);
      }
      /**
       * <pre>
       * List of keys to match with the weighted cluster metadata.
       * </pre>
       *
       * <code>repeated string keys = 1;</code>
       */
      public com.google.protobuf.ByteString
          getKeysBytes(int index) {
        return keys_.getByteString(index);
      }

      private byte memoizedIsInitialized = -1;
      public final boolean isInitialized() {
        byte isInitialized = memoizedIsInitialized;
        if (isInitialized == 1) return true;
        if (isInitialized == 0) return false;

        memoizedIsInitialized = 1;
        return true;
      }

      public void writeTo(com.google.protobuf.CodedOutputStream output)
                          throws java.io.IOException {
        for (int i = 0; i < keys_.size(); i++) {
          com.google.protobuf.GeneratedMessageV3.writeString(output, 1, keys_.getRaw(i));
        }
        unknownFields.writeTo(output);
      }

      public int getSerializedSize() {
        int size = memoizedSize;
        if (size != -1) return size;

        size = 0;
        {
          int dataSize = 0;
          for (int i = 0; i < keys_.size(); i++) {
            dataSize += computeStringSizeNoTag(keys_.getRaw(i));
          }
          size += dataSize;
          size += 1 * getKeysList().size();
        }
        size += unknownFields.getSerializedSize();
        memoizedSize = size;
        return size;
      }

      @java.lang.Override
      public boolean equals(final java.lang.Object obj) {
        if (obj == this) {
         return true;
        }
        if (!(obj instanceof io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfig.LbSubsetSelector)) {
          return super.equals(obj);
        }
        io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfig.LbSubsetSelector other = (io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfig.LbSubsetSelector) obj;

        boolean result = true;
        result = result && getKeysList()
            .equals(other.getKeysList());
        result = result && unknownFields.equals(other.unknownFields);
        return result;
      }

      @java.lang.Override
      public int hashCode() {
        if (memoizedHashCode != 0) {
          return memoizedHashCode;
        }
        int hash = 41;
        hash = (19 * hash) + getDescriptor().hashCode();
        if (getKeysCount() > 0) {
          hash = (37 * hash) + KEYS_FIELD_NUMBER;
          hash = (53 * hash) + getKeysList().hashCode();
        }
        hash = (29 * hash) + unknownFields.hashCode();
        memoizedHashCode = hash;
        return hash;
      }

      public static io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfig.LbSubsetSelector parseFrom(
          java.nio.ByteBuffer data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfig.LbSubsetSelector parseFrom(
          java.nio.ByteBuffer data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfig.LbSubsetSelector parseFrom(
          com.google.protobuf.ByteString data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfig.LbSubsetSelector parseFrom(
          com.google.protobuf.ByteString data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfig.LbSubsetSelector parseFrom(byte[] data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfig.LbSubsetSelector parseFrom(
          byte[] data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfig.LbSubsetSelector parseFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input);
      }
      public static io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfig.LbSubsetSelector parseFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input, extensionRegistry);
      }
      public static io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfig.LbSubsetSelector parseDelimitedFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseDelimitedWithIOException(PARSER, input);
      }
      public static io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfig.LbSubsetSelector parseDelimitedFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
      }
      public static io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfig.LbSubsetSelector parseFrom(
          com.google.protobuf.CodedInputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input);
      }
      public static io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfig.LbSubsetSelector parseFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input, extensionRegistry);
      }

      public Builder newBuilderForType() { return newBuilder(); }
      public static Builder newBuilder() {
        return DEFAULT_INSTANCE.toBuilder();
      }
      public static Builder newBuilder(io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfig.LbSubsetSelector prototype) {
        return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
      }
      public Builder toBuilder() {
        return this == DEFAULT_INSTANCE
            ? new Builder() : new Builder().mergeFrom(this);
      }

      @java.lang.Override
      protected Builder newBuilderForType(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        Builder builder = new Builder(parent);
        return builder;
      }
      /**
       * <pre>
       * Specifications for subsets.
       * </pre>
       *
       * Protobuf type {@code envoy.api.v2.Cluster.LbSubsetConfig.LbSubsetSelector}
       */
      public static final class Builder extends
          com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
          // @@protoc_insertion_point(builder_implements:envoy.api.v2.Cluster.LbSubsetConfig.LbSubsetSelector)
          io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfig.LbSubsetSelectorOrBuilder {
        public static final com.google.protobuf.Descriptors.Descriptor
            getDescriptor() {
          return io.grpc.xds.shaded.envoy.api.v2.Cds.internal_static_envoy_api_v2_Cluster_LbSubsetConfig_LbSubsetSelector_descriptor;
        }

        protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
            internalGetFieldAccessorTable() {
          return io.grpc.xds.shaded.envoy.api.v2.Cds.internal_static_envoy_api_v2_Cluster_LbSubsetConfig_LbSubsetSelector_fieldAccessorTable
              .ensureFieldAccessorsInitialized(
                  io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfig.LbSubsetSelector.class, io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfig.LbSubsetSelector.Builder.class);
        }

        // Construct using io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfig.LbSubsetSelector.newBuilder()
        private Builder() {
          maybeForceBuilderInitialization();
        }

        private Builder(
            com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
          super(parent);
          maybeForceBuilderInitialization();
        }
        private void maybeForceBuilderInitialization() {
          if (com.google.protobuf.GeneratedMessageV3
                  .alwaysUseFieldBuilders) {
          }
        }
        public Builder clear() {
          super.clear();
          keys_ = com.google.protobuf.LazyStringArrayList.EMPTY;
          bitField0_ = (bitField0_ & ~0x00000001);
          return this;
        }

        public com.google.protobuf.Descriptors.Descriptor
            getDescriptorForType() {
          return io.grpc.xds.shaded.envoy.api.v2.Cds.internal_static_envoy_api_v2_Cluster_LbSubsetConfig_LbSubsetSelector_descriptor;
        }

        public io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfig.LbSubsetSelector getDefaultInstanceForType() {
          return io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfig.LbSubsetSelector.getDefaultInstance();
        }

        public io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfig.LbSubsetSelector build() {
          io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfig.LbSubsetSelector result = buildPartial();
          if (!result.isInitialized()) {
            throw newUninitializedMessageException(result);
          }
          return result;
        }

        public io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfig.LbSubsetSelector buildPartial() {
          io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfig.LbSubsetSelector result = new io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfig.LbSubsetSelector(this);
          int from_bitField0_ = bitField0_;
          if (((bitField0_ & 0x00000001) == 0x00000001)) {
            keys_ = keys_.getUnmodifiableView();
            bitField0_ = (bitField0_ & ~0x00000001);
          }
          result.keys_ = keys_;
          onBuilt();
          return result;
        }

        public Builder clone() {
          return (Builder) super.clone();
        }
        public Builder setField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            java.lang.Object value) {
          return (Builder) super.setField(field, value);
        }
        public Builder clearField(
            com.google.protobuf.Descriptors.FieldDescriptor field) {
          return (Builder) super.clearField(field);
        }
        public Builder clearOneof(
            com.google.protobuf.Descriptors.OneofDescriptor oneof) {
          return (Builder) super.clearOneof(oneof);
        }
        public Builder setRepeatedField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            int index, java.lang.Object value) {
          return (Builder) super.setRepeatedField(field, index, value);
        }
        public Builder addRepeatedField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            java.lang.Object value) {
          return (Builder) super.addRepeatedField(field, value);
        }
        public Builder mergeFrom(com.google.protobuf.Message other) {
          if (other instanceof io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfig.LbSubsetSelector) {
            return mergeFrom((io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfig.LbSubsetSelector)other);
          } else {
            super.mergeFrom(other);
            return this;
          }
        }

        public Builder mergeFrom(io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfig.LbSubsetSelector other) {
          if (other == io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfig.LbSubsetSelector.getDefaultInstance()) return this;
          if (!other.keys_.isEmpty()) {
            if (keys_.isEmpty()) {
              keys_ = other.keys_;
              bitField0_ = (bitField0_ & ~0x00000001);
            } else {
              ensureKeysIsMutable();
              keys_.addAll(other.keys_);
            }
            onChanged();
          }
          this.mergeUnknownFields(other.unknownFields);
          onChanged();
          return this;
        }

        public final boolean isInitialized() {
          return true;
        }

        public Builder mergeFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
          io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfig.LbSubsetSelector parsedMessage = null;
          try {
            parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            parsedMessage = (io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfig.LbSubsetSelector) e.getUnfinishedMessage();
            throw e.unwrapIOException();
          } finally {
            if (parsedMessage != null) {
              mergeFrom(parsedMessage);
            }
          }
          return this;
        }
        private int bitField0_;

        private com.google.protobuf.LazyStringList keys_ = com.google.protobuf.LazyStringArrayList.EMPTY;
        private void ensureKeysIsMutable() {
          if (!((bitField0_ & 0x00000001) == 0x00000001)) {
            keys_ = new com.google.protobuf.LazyStringArrayList(keys_);
            bitField0_ |= 0x00000001;
           }
        }
        /**
         * <pre>
         * List of keys to match with the weighted cluster metadata.
         * </pre>
         *
         * <code>repeated string keys = 1;</code>
         */
        public com.google.protobuf.ProtocolStringList
            getKeysList() {
          return keys_.getUnmodifiableView();
        }
        /**
         * <pre>
         * List of keys to match with the weighted cluster metadata.
         * </pre>
         *
         * <code>repeated string keys = 1;</code>
         */
        public int getKeysCount() {
          return keys_.size();
        }
        /**
         * <pre>
         * List of keys to match with the weighted cluster metadata.
         * </pre>
         *
         * <code>repeated string keys = 1;</code>
         */
        public java.lang.String getKeys(int index) {
          return keys_.get(index);
        }
        /**
         * <pre>
         * List of keys to match with the weighted cluster metadata.
         * </pre>
         *
         * <code>repeated string keys = 1;</code>
         */
        public com.google.protobuf.ByteString
            getKeysBytes(int index) {
          return keys_.getByteString(index);
        }
        /**
         * <pre>
         * List of keys to match with the weighted cluster metadata.
         * </pre>
         *
         * <code>repeated string keys = 1;</code>
         */
        public Builder setKeys(
            int index, java.lang.String value) {
          if (value == null) {
    throw new NullPointerException();
  }
  ensureKeysIsMutable();
          keys_.set(index, value);
          onChanged();
          return this;
        }
        /**
         * <pre>
         * List of keys to match with the weighted cluster metadata.
         * </pre>
         *
         * <code>repeated string keys = 1;</code>
         */
        public Builder addKeys(
            java.lang.String value) {
          if (value == null) {
    throw new NullPointerException();
  }
  ensureKeysIsMutable();
          keys_.add(value);
          onChanged();
          return this;
        }
        /**
         * <pre>
         * List of keys to match with the weighted cluster metadata.
         * </pre>
         *
         * <code>repeated string keys = 1;</code>
         */
        public Builder addAllKeys(
            java.lang.Iterable<java.lang.String> values) {
          ensureKeysIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, keys_);
          onChanged();
          return this;
        }
        /**
         * <pre>
         * List of keys to match with the weighted cluster metadata.
         * </pre>
         *
         * <code>repeated string keys = 1;</code>
         */
        public Builder clearKeys() {
          keys_ = com.google.protobuf.LazyStringArrayList.EMPTY;
          bitField0_ = (bitField0_ & ~0x00000001);
          onChanged();
          return this;
        }
        /**
         * <pre>
         * List of keys to match with the weighted cluster metadata.
         * </pre>
         *
         * <code>repeated string keys = 1;</code>
         */
        public Builder addKeysBytes(
            com.google.protobuf.ByteString value) {
          if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
          ensureKeysIsMutable();
          keys_.add(value);
          onChanged();
          return this;
        }
        public final Builder setUnknownFields(
            final com.google.protobuf.UnknownFieldSet unknownFields) {
          return super.setUnknownFieldsProto3(unknownFields);
        }

        public final Builder mergeUnknownFields(
            final com.google.protobuf.UnknownFieldSet unknownFields) {
          return super.mergeUnknownFields(unknownFields);
        }


        // @@protoc_insertion_point(builder_scope:envoy.api.v2.Cluster.LbSubsetConfig.LbSubsetSelector)
      }

      // @@protoc_insertion_point(class_scope:envoy.api.v2.Cluster.LbSubsetConfig.LbSubsetSelector)
      private static final io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfig.LbSubsetSelector DEFAULT_INSTANCE;
      static {
        DEFAULT_INSTANCE = new io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfig.LbSubsetSelector();
      }

      public static io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfig.LbSubsetSelector getDefaultInstance() {
        return DEFAULT_INSTANCE;
      }

      private static final com.google.protobuf.Parser<LbSubsetSelector>
          PARSER = new com.google.protobuf.AbstractParser<LbSubsetSelector>() {
        public LbSubsetSelector parsePartialFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
          return new LbSubsetSelector(input, extensionRegistry);
        }
      };

      public static com.google.protobuf.Parser<LbSubsetSelector> parser() {
        return PARSER;
      }

      @java.lang.Override
      public com.google.protobuf.Parser<LbSubsetSelector> getParserForType() {
        return PARSER;
      }

      public io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfig.LbSubsetSelector getDefaultInstanceForType() {
        return DEFAULT_INSTANCE;
      }

    }

    private int bitField0_;
    public static final int FALLBACK_POLICY_FIELD_NUMBER = 1;
    private int fallbackPolicy_;
    /**
     * <pre>
     * The behavior used when no endpoint subset matches the selected route's
     * metadata. The value defaults to
     * :ref:`NO_FALLBACK&lt;envoy_api_enum_value_Cluster.LbSubsetConfig.LbSubsetFallbackPolicy.NO_FALLBACK&gt;`.
     * </pre>
     *
     * <code>.envoy.api.v2.Cluster.LbSubsetConfig.LbSubsetFallbackPolicy fallback_policy = 1 [(.validate.rules) = { ... }</code>
     */
    public int getFallbackPolicyValue() {
      return fallbackPolicy_;
    }
    /**
     * <pre>
     * The behavior used when no endpoint subset matches the selected route's
     * metadata. The value defaults to
     * :ref:`NO_FALLBACK&lt;envoy_api_enum_value_Cluster.LbSubsetConfig.LbSubsetFallbackPolicy.NO_FALLBACK&gt;`.
     * </pre>
     *
     * <code>.envoy.api.v2.Cluster.LbSubsetConfig.LbSubsetFallbackPolicy fallback_policy = 1 [(.validate.rules) = { ... }</code>
     */
    public io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfig.LbSubsetFallbackPolicy getFallbackPolicy() {
      io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfig.LbSubsetFallbackPolicy result = io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfig.LbSubsetFallbackPolicy.valueOf(fallbackPolicy_);
      return result == null ? io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfig.LbSubsetFallbackPolicy.UNRECOGNIZED : result;
    }

    public static final int DEFAULT_SUBSET_FIELD_NUMBER = 2;
    private com.google.protobuf.Struct defaultSubset_;
    /**
     * <pre>
     * Specifies the default subset of endpoints used during fallback if
     * fallback_policy is
     * :ref:`DEFAULT_SUBSET&lt;envoy_api_enum_value_Cluster.LbSubsetConfig.LbSubsetFallbackPolicy.DEFAULT_SUBSET&gt;`.
     * Each field in default_subset is
     * compared to the matching LbEndpoint.Metadata under the *envoy.lb*
     * namespace. It is valid for no hosts to match, in which case the behavior
     * is the same as a fallback_policy of
     * :ref:`NO_FALLBACK&lt;envoy_api_enum_value_Cluster.LbSubsetConfig.LbSubsetFallbackPolicy.NO_FALLBACK&gt;`.
     * </pre>
     *
     * <code>.google.protobuf.Struct default_subset = 2;</code>
     */
    public boolean hasDefaultSubset() {
      return defaultSubset_ != null;
    }
    /**
     * <pre>
     * Specifies the default subset of endpoints used during fallback if
     * fallback_policy is
     * :ref:`DEFAULT_SUBSET&lt;envoy_api_enum_value_Cluster.LbSubsetConfig.LbSubsetFallbackPolicy.DEFAULT_SUBSET&gt;`.
     * Each field in default_subset is
     * compared to the matching LbEndpoint.Metadata under the *envoy.lb*
     * namespace. It is valid for no hosts to match, in which case the behavior
     * is the same as a fallback_policy of
     * :ref:`NO_FALLBACK&lt;envoy_api_enum_value_Cluster.LbSubsetConfig.LbSubsetFallbackPolicy.NO_FALLBACK&gt;`.
     * </pre>
     *
     * <code>.google.protobuf.Struct default_subset = 2;</code>
     */
    public com.google.protobuf.Struct getDefaultSubset() {
      return defaultSubset_ == null ? com.google.protobuf.Struct.getDefaultInstance() : defaultSubset_;
    }
    /**
     * <pre>
     * Specifies the default subset of endpoints used during fallback if
     * fallback_policy is
     * :ref:`DEFAULT_SUBSET&lt;envoy_api_enum_value_Cluster.LbSubsetConfig.LbSubsetFallbackPolicy.DEFAULT_SUBSET&gt;`.
     * Each field in default_subset is
     * compared to the matching LbEndpoint.Metadata under the *envoy.lb*
     * namespace. It is valid for no hosts to match, in which case the behavior
     * is the same as a fallback_policy of
     * :ref:`NO_FALLBACK&lt;envoy_api_enum_value_Cluster.LbSubsetConfig.LbSubsetFallbackPolicy.NO_FALLBACK&gt;`.
     * </pre>
     *
     * <code>.google.protobuf.Struct default_subset = 2;</code>
     */
    public com.google.protobuf.StructOrBuilder getDefaultSubsetOrBuilder() {
      return getDefaultSubset();
    }

    public static final int SUBSET_SELECTORS_FIELD_NUMBER = 3;
    private java.util.List<io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfig.LbSubsetSelector> subsetSelectors_;
    /**
     * <pre>
     * For each entry, LbEndpoint.Metadata's
     * *envoy.lb* namespace is traversed and a subset is created for each unique
     * combination of key and value. For example:
     * .. code-block:: json
     *   { "subset_selectors": [
     *       { "keys": [ "version" ] },
     *       { "keys": [ "stage", "hardware_type" ] }
     *   ]}
     * A subset is matched when the metadata from the selected route and
     * weighted cluster contains the same keys and values as the subset's
     * metadata. The same host may appear in multiple subsets.
     * </pre>
     *
     * <code>repeated .envoy.api.v2.Cluster.LbSubsetConfig.LbSubsetSelector subset_selectors = 3;</code>
     */
    public java.util.List<io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfig.LbSubsetSelector> getSubsetSelectorsList() {
      return subsetSelectors_;
    }
    /**
     * <pre>
     * For each entry, LbEndpoint.Metadata's
     * *envoy.lb* namespace is traversed and a subset is created for each unique
     * combination of key and value. For example:
     * .. code-block:: json
     *   { "subset_selectors": [
     *       { "keys": [ "version" ] },
     *       { "keys": [ "stage", "hardware_type" ] }
     *   ]}
     * A subset is matched when the metadata from the selected route and
     * weighted cluster contains the same keys and values as the subset's
     * metadata. The same host may appear in multiple subsets.
     * </pre>
     *
     * <code>repeated .envoy.api.v2.Cluster.LbSubsetConfig.LbSubsetSelector subset_selectors = 3;</code>
     */
    public java.util.List<? extends io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfig.LbSubsetSelectorOrBuilder> 
        getSubsetSelectorsOrBuilderList() {
      return subsetSelectors_;
    }
    /**
     * <pre>
     * For each entry, LbEndpoint.Metadata's
     * *envoy.lb* namespace is traversed and a subset is created for each unique
     * combination of key and value. For example:
     * .. code-block:: json
     *   { "subset_selectors": [
     *       { "keys": [ "version" ] },
     *       { "keys": [ "stage", "hardware_type" ] }
     *   ]}
     * A subset is matched when the metadata from the selected route and
     * weighted cluster contains the same keys and values as the subset's
     * metadata. The same host may appear in multiple subsets.
     * </pre>
     *
     * <code>repeated .envoy.api.v2.Cluster.LbSubsetConfig.LbSubsetSelector subset_selectors = 3;</code>
     */
    public int getSubsetSelectorsCount() {
      return subsetSelectors_.size();
    }
    /**
     * <pre>
     * For each entry, LbEndpoint.Metadata's
     * *envoy.lb* namespace is traversed and a subset is created for each unique
     * combination of key and value. For example:
     * .. code-block:: json
     *   { "subset_selectors": [
     *       { "keys": [ "version" ] },
     *       { "keys": [ "stage", "hardware_type" ] }
     *   ]}
     * A subset is matched when the metadata from the selected route and
     * weighted cluster contains the same keys and values as the subset's
     * metadata. The same host may appear in multiple subsets.
     * </pre>
     *
     * <code>repeated .envoy.api.v2.Cluster.LbSubsetConfig.LbSubsetSelector subset_selectors = 3;</code>
     */
    public io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfig.LbSubsetSelector getSubsetSelectors(int index) {
      return subsetSelectors_.get(index);
    }
    /**
     * <pre>
     * For each entry, LbEndpoint.Metadata's
     * *envoy.lb* namespace is traversed and a subset is created for each unique
     * combination of key and value. For example:
     * .. code-block:: json
     *   { "subset_selectors": [
     *       { "keys": [ "version" ] },
     *       { "keys": [ "stage", "hardware_type" ] }
     *   ]}
     * A subset is matched when the metadata from the selected route and
     * weighted cluster contains the same keys and values as the subset's
     * metadata. The same host may appear in multiple subsets.
     * </pre>
     *
     * <code>repeated .envoy.api.v2.Cluster.LbSubsetConfig.LbSubsetSelector subset_selectors = 3;</code>
     */
    public io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfig.LbSubsetSelectorOrBuilder getSubsetSelectorsOrBuilder(
        int index) {
      return subsetSelectors_.get(index);
    }

    public static final int LOCALITY_WEIGHT_AWARE_FIELD_NUMBER = 4;
    private boolean localityWeightAware_;
    /**
     * <pre>
     * If true, routing to subsets will take into account the localities and locality weights of the
     * endpoints when making the routing decision.
     * There are some potential pitfalls associated with enabling this feature, as the resulting
     * traffic split after applying both a subset match and locality weights might be undesirable.
     * Consider for example a situation in which you have 50/50 split across two localities X/Y
     * which have 100 hosts each without subsetting. If the subset LB results in X having only 1
     * host selected but Y having 100, then a lot more load is being dumped on the single host in X
     * than originally anticipated in the load balancing assignment delivered via EDS.
     * </pre>
     *
     * <code>bool locality_weight_aware = 4;</code>
     */
    public boolean getLocalityWeightAware() {
      return localityWeightAware_;
    }

    public static final int SCALE_LOCALITY_WEIGHT_FIELD_NUMBER = 5;
    private boolean scaleLocalityWeight_;
    /**
     * <pre>
     * When used with locality_weight_aware, scales the weight of each locality by the ratio
     * of hosts in the subset vs hosts in the original subset. This aims to even out the load
     * going to an individual locality if said locality is disproportionally affected by the
     * subset predicate.
     * </pre>
     *
     * <code>bool scale_locality_weight = 5;</code>
     */
    public boolean getScaleLocalityWeight() {
      return scaleLocalityWeight_;
    }

    private byte memoizedIsInitialized = -1;
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (fallbackPolicy_ != io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfig.LbSubsetFallbackPolicy.NO_FALLBACK.getNumber()) {
        output.writeEnum(1, fallbackPolicy_);
      }
      if (defaultSubset_ != null) {
        output.writeMessage(2, getDefaultSubset());
      }
      for (int i = 0; i < subsetSelectors_.size(); i++) {
        output.writeMessage(3, subsetSelectors_.get(i));
      }
      if (localityWeightAware_ != false) {
        output.writeBool(4, localityWeightAware_);
      }
      if (scaleLocalityWeight_ != false) {
        output.writeBool(5, scaleLocalityWeight_);
      }
      unknownFields.writeTo(output);
    }

    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (fallbackPolicy_ != io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfig.LbSubsetFallbackPolicy.NO_FALLBACK.getNumber()) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(1, fallbackPolicy_);
      }
      if (defaultSubset_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, getDefaultSubset());
      }
      for (int i = 0; i < subsetSelectors_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(3, subsetSelectors_.get(i));
      }
      if (localityWeightAware_ != false) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(4, localityWeightAware_);
      }
      if (scaleLocalityWeight_ != false) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(5, scaleLocalityWeight_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfig)) {
        return super.equals(obj);
      }
      io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfig other = (io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfig) obj;

      boolean result = true;
      result = result && fallbackPolicy_ == other.fallbackPolicy_;
      result = result && (hasDefaultSubset() == other.hasDefaultSubset());
      if (hasDefaultSubset()) {
        result = result && getDefaultSubset()
            .equals(other.getDefaultSubset());
      }
      result = result && getSubsetSelectorsList()
          .equals(other.getSubsetSelectorsList());
      result = result && (getLocalityWeightAware()
          == other.getLocalityWeightAware());
      result = result && (getScaleLocalityWeight()
          == other.getScaleLocalityWeight());
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + FALLBACK_POLICY_FIELD_NUMBER;
      hash = (53 * hash) + fallbackPolicy_;
      if (hasDefaultSubset()) {
        hash = (37 * hash) + DEFAULT_SUBSET_FIELD_NUMBER;
        hash = (53 * hash) + getDefaultSubset().hashCode();
      }
      if (getSubsetSelectorsCount() > 0) {
        hash = (37 * hash) + SUBSET_SELECTORS_FIELD_NUMBER;
        hash = (53 * hash) + getSubsetSelectorsList().hashCode();
      }
      hash = (37 * hash) + LOCALITY_WEIGHT_AWARE_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
          getLocalityWeightAware());
      hash = (37 * hash) + SCALE_LOCALITY_WEIGHT_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
          getScaleLocalityWeight());
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfig parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfig parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfig parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfig parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfig parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfig parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfig parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfig parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfig parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfig parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfig parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfig parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfig prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Optionally divide the endpoints in this cluster into subsets defined by
     * endpoint metadata and selected by route and weighted cluster metadata.
     * </pre>
     *
     * Protobuf type {@code envoy.api.v2.Cluster.LbSubsetConfig}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:envoy.api.v2.Cluster.LbSubsetConfig)
        io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfigOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.grpc.xds.shaded.envoy.api.v2.Cds.internal_static_envoy_api_v2_Cluster_LbSubsetConfig_descriptor;
      }

      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.grpc.xds.shaded.envoy.api.v2.Cds.internal_static_envoy_api_v2_Cluster_LbSubsetConfig_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfig.class, io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfig.Builder.class);
      }

      // Construct using io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfig.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getSubsetSelectorsFieldBuilder();
        }
      }
      public Builder clear() {
        super.clear();
        fallbackPolicy_ = 0;

        if (defaultSubsetBuilder_ == null) {
          defaultSubset_ = null;
        } else {
          defaultSubset_ = null;
          defaultSubsetBuilder_ = null;
        }
        if (subsetSelectorsBuilder_ == null) {
          subsetSelectors_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000004);
        } else {
          subsetSelectorsBuilder_.clear();
        }
        localityWeightAware_ = false;

        scaleLocalityWeight_ = false;

        return this;
      }

      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.grpc.xds.shaded.envoy.api.v2.Cds.internal_static_envoy_api_v2_Cluster_LbSubsetConfig_descriptor;
      }

      public io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfig getDefaultInstanceForType() {
        return io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfig.getDefaultInstance();
      }

      public io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfig build() {
        io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfig result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      public io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfig buildPartial() {
        io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfig result = new io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfig(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        result.fallbackPolicy_ = fallbackPolicy_;
        if (defaultSubsetBuilder_ == null) {
          result.defaultSubset_ = defaultSubset_;
        } else {
          result.defaultSubset_ = defaultSubsetBuilder_.build();
        }
        if (subsetSelectorsBuilder_ == null) {
          if (((bitField0_ & 0x00000004) == 0x00000004)) {
            subsetSelectors_ = java.util.Collections.unmodifiableList(subsetSelectors_);
            bitField0_ = (bitField0_ & ~0x00000004);
          }
          result.subsetSelectors_ = subsetSelectors_;
        } else {
          result.subsetSelectors_ = subsetSelectorsBuilder_.build();
        }
        result.localityWeightAware_ = localityWeightAware_;
        result.scaleLocalityWeight_ = scaleLocalityWeight_;
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      public Builder clone() {
        return (Builder) super.clone();
      }
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfig) {
          return mergeFrom((io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfig)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfig other) {
        if (other == io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfig.getDefaultInstance()) return this;
        if (other.fallbackPolicy_ != 0) {
          setFallbackPolicyValue(other.getFallbackPolicyValue());
        }
        if (other.hasDefaultSubset()) {
          mergeDefaultSubset(other.getDefaultSubset());
        }
        if (subsetSelectorsBuilder_ == null) {
          if (!other.subsetSelectors_.isEmpty()) {
            if (subsetSelectors_.isEmpty()) {
              subsetSelectors_ = other.subsetSelectors_;
              bitField0_ = (bitField0_ & ~0x00000004);
            } else {
              ensureSubsetSelectorsIsMutable();
              subsetSelectors_.addAll(other.subsetSelectors_);
            }
            onChanged();
          }
        } else {
          if (!other.subsetSelectors_.isEmpty()) {
            if (subsetSelectorsBuilder_.isEmpty()) {
              subsetSelectorsBuilder_.dispose();
              subsetSelectorsBuilder_ = null;
              subsetSelectors_ = other.subsetSelectors_;
              bitField0_ = (bitField0_ & ~0x00000004);
              subsetSelectorsBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getSubsetSelectorsFieldBuilder() : null;
            } else {
              subsetSelectorsBuilder_.addAllMessages(other.subsetSelectors_);
            }
          }
        }
        if (other.getLocalityWeightAware() != false) {
          setLocalityWeightAware(other.getLocalityWeightAware());
        }
        if (other.getScaleLocalityWeight() != false) {
          setScaleLocalityWeight(other.getScaleLocalityWeight());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      public final boolean isInitialized() {
        return true;
      }

      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfig parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfig) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private int fallbackPolicy_ = 0;
      /**
       * <pre>
       * The behavior used when no endpoint subset matches the selected route's
       * metadata. The value defaults to
       * :ref:`NO_FALLBACK&lt;envoy_api_enum_value_Cluster.LbSubsetConfig.LbSubsetFallbackPolicy.NO_FALLBACK&gt;`.
       * </pre>
       *
       * <code>.envoy.api.v2.Cluster.LbSubsetConfig.LbSubsetFallbackPolicy fallback_policy = 1 [(.validate.rules) = { ... }</code>
       */
      public int getFallbackPolicyValue() {
        return fallbackPolicy_;
      }
      /**
       * <pre>
       * The behavior used when no endpoint subset matches the selected route's
       * metadata. The value defaults to
       * :ref:`NO_FALLBACK&lt;envoy_api_enum_value_Cluster.LbSubsetConfig.LbSubsetFallbackPolicy.NO_FALLBACK&gt;`.
       * </pre>
       *
       * <code>.envoy.api.v2.Cluster.LbSubsetConfig.LbSubsetFallbackPolicy fallback_policy = 1 [(.validate.rules) = { ... }</code>
       */
      public Builder setFallbackPolicyValue(int value) {
        fallbackPolicy_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The behavior used when no endpoint subset matches the selected route's
       * metadata. The value defaults to
       * :ref:`NO_FALLBACK&lt;envoy_api_enum_value_Cluster.LbSubsetConfig.LbSubsetFallbackPolicy.NO_FALLBACK&gt;`.
       * </pre>
       *
       * <code>.envoy.api.v2.Cluster.LbSubsetConfig.LbSubsetFallbackPolicy fallback_policy = 1 [(.validate.rules) = { ... }</code>
       */
      public io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfig.LbSubsetFallbackPolicy getFallbackPolicy() {
        io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfig.LbSubsetFallbackPolicy result = io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfig.LbSubsetFallbackPolicy.valueOf(fallbackPolicy_);
        return result == null ? io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfig.LbSubsetFallbackPolicy.UNRECOGNIZED : result;
      }
      /**
       * <pre>
       * The behavior used when no endpoint subset matches the selected route's
       * metadata. The value defaults to
       * :ref:`NO_FALLBACK&lt;envoy_api_enum_value_Cluster.LbSubsetConfig.LbSubsetFallbackPolicy.NO_FALLBACK&gt;`.
       * </pre>
       *
       * <code>.envoy.api.v2.Cluster.LbSubsetConfig.LbSubsetFallbackPolicy fallback_policy = 1 [(.validate.rules) = { ... }</code>
       */
      public Builder setFallbackPolicy(io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfig.LbSubsetFallbackPolicy value) {
        if (value == null) {
          throw new NullPointerException();
        }
        
        fallbackPolicy_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The behavior used when no endpoint subset matches the selected route's
       * metadata. The value defaults to
       * :ref:`NO_FALLBACK&lt;envoy_api_enum_value_Cluster.LbSubsetConfig.LbSubsetFallbackPolicy.NO_FALLBACK&gt;`.
       * </pre>
       *
       * <code>.envoy.api.v2.Cluster.LbSubsetConfig.LbSubsetFallbackPolicy fallback_policy = 1 [(.validate.rules) = { ... }</code>
       */
      public Builder clearFallbackPolicy() {
        
        fallbackPolicy_ = 0;
        onChanged();
        return this;
      }

      private com.google.protobuf.Struct defaultSubset_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          com.google.protobuf.Struct, com.google.protobuf.Struct.Builder, com.google.protobuf.StructOrBuilder> defaultSubsetBuilder_;
      /**
       * <pre>
       * Specifies the default subset of endpoints used during fallback if
       * fallback_policy is
       * :ref:`DEFAULT_SUBSET&lt;envoy_api_enum_value_Cluster.LbSubsetConfig.LbSubsetFallbackPolicy.DEFAULT_SUBSET&gt;`.
       * Each field in default_subset is
       * compared to the matching LbEndpoint.Metadata under the *envoy.lb*
       * namespace. It is valid for no hosts to match, in which case the behavior
       * is the same as a fallback_policy of
       * :ref:`NO_FALLBACK&lt;envoy_api_enum_value_Cluster.LbSubsetConfig.LbSubsetFallbackPolicy.NO_FALLBACK&gt;`.
       * </pre>
       *
       * <code>.google.protobuf.Struct default_subset = 2;</code>
       */
      public boolean hasDefaultSubset() {
        return defaultSubsetBuilder_ != null || defaultSubset_ != null;
      }
      /**
       * <pre>
       * Specifies the default subset of endpoints used during fallback if
       * fallback_policy is
       * :ref:`DEFAULT_SUBSET&lt;envoy_api_enum_value_Cluster.LbSubsetConfig.LbSubsetFallbackPolicy.DEFAULT_SUBSET&gt;`.
       * Each field in default_subset is
       * compared to the matching LbEndpoint.Metadata under the *envoy.lb*
       * namespace. It is valid for no hosts to match, in which case the behavior
       * is the same as a fallback_policy of
       * :ref:`NO_FALLBACK&lt;envoy_api_enum_value_Cluster.LbSubsetConfig.LbSubsetFallbackPolicy.NO_FALLBACK&gt;`.
       * </pre>
       *
       * <code>.google.protobuf.Struct default_subset = 2;</code>
       */
      public com.google.protobuf.Struct getDefaultSubset() {
        if (defaultSubsetBuilder_ == null) {
          return defaultSubset_ == null ? com.google.protobuf.Struct.getDefaultInstance() : defaultSubset_;
        } else {
          return defaultSubsetBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Specifies the default subset of endpoints used during fallback if
       * fallback_policy is
       * :ref:`DEFAULT_SUBSET&lt;envoy_api_enum_value_Cluster.LbSubsetConfig.LbSubsetFallbackPolicy.DEFAULT_SUBSET&gt;`.
       * Each field in default_subset is
       * compared to the matching LbEndpoint.Metadata under the *envoy.lb*
       * namespace. It is valid for no hosts to match, in which case the behavior
       * is the same as a fallback_policy of
       * :ref:`NO_FALLBACK&lt;envoy_api_enum_value_Cluster.LbSubsetConfig.LbSubsetFallbackPolicy.NO_FALLBACK&gt;`.
       * </pre>
       *
       * <code>.google.protobuf.Struct default_subset = 2;</code>
       */
      public Builder setDefaultSubset(com.google.protobuf.Struct value) {
        if (defaultSubsetBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          defaultSubset_ = value;
          onChanged();
        } else {
          defaultSubsetBuilder_.setMessage(value);
        }

        return this;
      }
      /**
       * <pre>
       * Specifies the default subset of endpoints used during fallback if
       * fallback_policy is
       * :ref:`DEFAULT_SUBSET&lt;envoy_api_enum_value_Cluster.LbSubsetConfig.LbSubsetFallbackPolicy.DEFAULT_SUBSET&gt;`.
       * Each field in default_subset is
       * compared to the matching LbEndpoint.Metadata under the *envoy.lb*
       * namespace. It is valid for no hosts to match, in which case the behavior
       * is the same as a fallback_policy of
       * :ref:`NO_FALLBACK&lt;envoy_api_enum_value_Cluster.LbSubsetConfig.LbSubsetFallbackPolicy.NO_FALLBACK&gt;`.
       * </pre>
       *
       * <code>.google.protobuf.Struct default_subset = 2;</code>
       */
      public Builder setDefaultSubset(
          com.google.protobuf.Struct.Builder builderForValue) {
        if (defaultSubsetBuilder_ == null) {
          defaultSubset_ = builderForValue.build();
          onChanged();
        } else {
          defaultSubsetBuilder_.setMessage(builderForValue.build());
        }

        return this;
      }
      /**
       * <pre>
       * Specifies the default subset of endpoints used during fallback if
       * fallback_policy is
       * :ref:`DEFAULT_SUBSET&lt;envoy_api_enum_value_Cluster.LbSubsetConfig.LbSubsetFallbackPolicy.DEFAULT_SUBSET&gt;`.
       * Each field in default_subset is
       * compared to the matching LbEndpoint.Metadata under the *envoy.lb*
       * namespace. It is valid for no hosts to match, in which case the behavior
       * is the same as a fallback_policy of
       * :ref:`NO_FALLBACK&lt;envoy_api_enum_value_Cluster.LbSubsetConfig.LbSubsetFallbackPolicy.NO_FALLBACK&gt;`.
       * </pre>
       *
       * <code>.google.protobuf.Struct default_subset = 2;</code>
       */
      public Builder mergeDefaultSubset(com.google.protobuf.Struct value) {
        if (defaultSubsetBuilder_ == null) {
          if (defaultSubset_ != null) {
            defaultSubset_ =
              com.google.protobuf.Struct.newBuilder(defaultSubset_).mergeFrom(value).buildPartial();
          } else {
            defaultSubset_ = value;
          }
          onChanged();
        } else {
          defaultSubsetBuilder_.mergeFrom(value);
        }

        return this;
      }
      /**
       * <pre>
       * Specifies the default subset of endpoints used during fallback if
       * fallback_policy is
       * :ref:`DEFAULT_SUBSET&lt;envoy_api_enum_value_Cluster.LbSubsetConfig.LbSubsetFallbackPolicy.DEFAULT_SUBSET&gt;`.
       * Each field in default_subset is
       * compared to the matching LbEndpoint.Metadata under the *envoy.lb*
       * namespace. It is valid for no hosts to match, in which case the behavior
       * is the same as a fallback_policy of
       * :ref:`NO_FALLBACK&lt;envoy_api_enum_value_Cluster.LbSubsetConfig.LbSubsetFallbackPolicy.NO_FALLBACK&gt;`.
       * </pre>
       *
       * <code>.google.protobuf.Struct default_subset = 2;</code>
       */
      public Builder clearDefaultSubset() {
        if (defaultSubsetBuilder_ == null) {
          defaultSubset_ = null;
          onChanged();
        } else {
          defaultSubset_ = null;
          defaultSubsetBuilder_ = null;
        }

        return this;
      }
      /**
       * <pre>
       * Specifies the default subset of endpoints used during fallback if
       * fallback_policy is
       * :ref:`DEFAULT_SUBSET&lt;envoy_api_enum_value_Cluster.LbSubsetConfig.LbSubsetFallbackPolicy.DEFAULT_SUBSET&gt;`.
       * Each field in default_subset is
       * compared to the matching LbEndpoint.Metadata under the *envoy.lb*
       * namespace. It is valid for no hosts to match, in which case the behavior
       * is the same as a fallback_policy of
       * :ref:`NO_FALLBACK&lt;envoy_api_enum_value_Cluster.LbSubsetConfig.LbSubsetFallbackPolicy.NO_FALLBACK&gt;`.
       * </pre>
       *
       * <code>.google.protobuf.Struct default_subset = 2;</code>
       */
      public com.google.protobuf.Struct.Builder getDefaultSubsetBuilder() {
        
        onChanged();
        return getDefaultSubsetFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Specifies the default subset of endpoints used during fallback if
       * fallback_policy is
       * :ref:`DEFAULT_SUBSET&lt;envoy_api_enum_value_Cluster.LbSubsetConfig.LbSubsetFallbackPolicy.DEFAULT_SUBSET&gt;`.
       * Each field in default_subset is
       * compared to the matching LbEndpoint.Metadata under the *envoy.lb*
       * namespace. It is valid for no hosts to match, in which case the behavior
       * is the same as a fallback_policy of
       * :ref:`NO_FALLBACK&lt;envoy_api_enum_value_Cluster.LbSubsetConfig.LbSubsetFallbackPolicy.NO_FALLBACK&gt;`.
       * </pre>
       *
       * <code>.google.protobuf.Struct default_subset = 2;</code>
       */
      public com.google.protobuf.StructOrBuilder getDefaultSubsetOrBuilder() {
        if (defaultSubsetBuilder_ != null) {
          return defaultSubsetBuilder_.getMessageOrBuilder();
        } else {
          return defaultSubset_ == null ?
              com.google.protobuf.Struct.getDefaultInstance() : defaultSubset_;
        }
      }
      /**
       * <pre>
       * Specifies the default subset of endpoints used during fallback if
       * fallback_policy is
       * :ref:`DEFAULT_SUBSET&lt;envoy_api_enum_value_Cluster.LbSubsetConfig.LbSubsetFallbackPolicy.DEFAULT_SUBSET&gt;`.
       * Each field in default_subset is
       * compared to the matching LbEndpoint.Metadata under the *envoy.lb*
       * namespace. It is valid for no hosts to match, in which case the behavior
       * is the same as a fallback_policy of
       * :ref:`NO_FALLBACK&lt;envoy_api_enum_value_Cluster.LbSubsetConfig.LbSubsetFallbackPolicy.NO_FALLBACK&gt;`.
       * </pre>
       *
       * <code>.google.protobuf.Struct default_subset = 2;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          com.google.protobuf.Struct, com.google.protobuf.Struct.Builder, com.google.protobuf.StructOrBuilder> 
          getDefaultSubsetFieldBuilder() {
        if (defaultSubsetBuilder_ == null) {
          defaultSubsetBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              com.google.protobuf.Struct, com.google.protobuf.Struct.Builder, com.google.protobuf.StructOrBuilder>(
                  getDefaultSubset(),
                  getParentForChildren(),
                  isClean());
          defaultSubset_ = null;
        }
        return defaultSubsetBuilder_;
      }

      private java.util.List<io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfig.LbSubsetSelector> subsetSelectors_ =
        java.util.Collections.emptyList();
      private void ensureSubsetSelectorsIsMutable() {
        if (!((bitField0_ & 0x00000004) == 0x00000004)) {
          subsetSelectors_ = new java.util.ArrayList<io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfig.LbSubsetSelector>(subsetSelectors_);
          bitField0_ |= 0x00000004;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfig.LbSubsetSelector, io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfig.LbSubsetSelector.Builder, io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfig.LbSubsetSelectorOrBuilder> subsetSelectorsBuilder_;

      /**
       * <pre>
       * For each entry, LbEndpoint.Metadata's
       * *envoy.lb* namespace is traversed and a subset is created for each unique
       * combination of key and value. For example:
       * .. code-block:: json
       *   { "subset_selectors": [
       *       { "keys": [ "version" ] },
       *       { "keys": [ "stage", "hardware_type" ] }
       *   ]}
       * A subset is matched when the metadata from the selected route and
       * weighted cluster contains the same keys and values as the subset's
       * metadata. The same host may appear in multiple subsets.
       * </pre>
       *
       * <code>repeated .envoy.api.v2.Cluster.LbSubsetConfig.LbSubsetSelector subset_selectors = 3;</code>
       */
      public java.util.List<io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfig.LbSubsetSelector> getSubsetSelectorsList() {
        if (subsetSelectorsBuilder_ == null) {
          return java.util.Collections.unmodifiableList(subsetSelectors_);
        } else {
          return subsetSelectorsBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * For each entry, LbEndpoint.Metadata's
       * *envoy.lb* namespace is traversed and a subset is created for each unique
       * combination of key and value. For example:
       * .. code-block:: json
       *   { "subset_selectors": [
       *       { "keys": [ "version" ] },
       *       { "keys": [ "stage", "hardware_type" ] }
       *   ]}
       * A subset is matched when the metadata from the selected route and
       * weighted cluster contains the same keys and values as the subset's
       * metadata. The same host may appear in multiple subsets.
       * </pre>
       *
       * <code>repeated .envoy.api.v2.Cluster.LbSubsetConfig.LbSubsetSelector subset_selectors = 3;</code>
       */
      public int getSubsetSelectorsCount() {
        if (subsetSelectorsBuilder_ == null) {
          return subsetSelectors_.size();
        } else {
          return subsetSelectorsBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * For each entry, LbEndpoint.Metadata's
       * *envoy.lb* namespace is traversed and a subset is created for each unique
       * combination of key and value. For example:
       * .. code-block:: json
       *   { "subset_selectors": [
       *       { "keys": [ "version" ] },
       *       { "keys": [ "stage", "hardware_type" ] }
       *   ]}
       * A subset is matched when the metadata from the selected route and
       * weighted cluster contains the same keys and values as the subset's
       * metadata. The same host may appear in multiple subsets.
       * </pre>
       *
       * <code>repeated .envoy.api.v2.Cluster.LbSubsetConfig.LbSubsetSelector subset_selectors = 3;</code>
       */
      public io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfig.LbSubsetSelector getSubsetSelectors(int index) {
        if (subsetSelectorsBuilder_ == null) {
          return subsetSelectors_.get(index);
        } else {
          return subsetSelectorsBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * For each entry, LbEndpoint.Metadata's
       * *envoy.lb* namespace is traversed and a subset is created for each unique
       * combination of key and value. For example:
       * .. code-block:: json
       *   { "subset_selectors": [
       *       { "keys": [ "version" ] },
       *       { "keys": [ "stage", "hardware_type" ] }
       *   ]}
       * A subset is matched when the metadata from the selected route and
       * weighted cluster contains the same keys and values as the subset's
       * metadata. The same host may appear in multiple subsets.
       * </pre>
       *
       * <code>repeated .envoy.api.v2.Cluster.LbSubsetConfig.LbSubsetSelector subset_selectors = 3;</code>
       */
      public Builder setSubsetSelectors(
          int index, io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfig.LbSubsetSelector value) {
        if (subsetSelectorsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureSubsetSelectorsIsMutable();
          subsetSelectors_.set(index, value);
          onChanged();
        } else {
          subsetSelectorsBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * For each entry, LbEndpoint.Metadata's
       * *envoy.lb* namespace is traversed and a subset is created for each unique
       * combination of key and value. For example:
       * .. code-block:: json
       *   { "subset_selectors": [
       *       { "keys": [ "version" ] },
       *       { "keys": [ "stage", "hardware_type" ] }
       *   ]}
       * A subset is matched when the metadata from the selected route and
       * weighted cluster contains the same keys and values as the subset's
       * metadata. The same host may appear in multiple subsets.
       * </pre>
       *
       * <code>repeated .envoy.api.v2.Cluster.LbSubsetConfig.LbSubsetSelector subset_selectors = 3;</code>
       */
      public Builder setSubsetSelectors(
          int index, io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfig.LbSubsetSelector.Builder builderForValue) {
        if (subsetSelectorsBuilder_ == null) {
          ensureSubsetSelectorsIsMutable();
          subsetSelectors_.set(index, builderForValue.build());
          onChanged();
        } else {
          subsetSelectorsBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * For each entry, LbEndpoint.Metadata's
       * *envoy.lb* namespace is traversed and a subset is created for each unique
       * combination of key and value. For example:
       * .. code-block:: json
       *   { "subset_selectors": [
       *       { "keys": [ "version" ] },
       *       { "keys": [ "stage", "hardware_type" ] }
       *   ]}
       * A subset is matched when the metadata from the selected route and
       * weighted cluster contains the same keys and values as the subset's
       * metadata. The same host may appear in multiple subsets.
       * </pre>
       *
       * <code>repeated .envoy.api.v2.Cluster.LbSubsetConfig.LbSubsetSelector subset_selectors = 3;</code>
       */
      public Builder addSubsetSelectors(io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfig.LbSubsetSelector value) {
        if (subsetSelectorsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureSubsetSelectorsIsMutable();
          subsetSelectors_.add(value);
          onChanged();
        } else {
          subsetSelectorsBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * For each entry, LbEndpoint.Metadata's
       * *envoy.lb* namespace is traversed and a subset is created for each unique
       * combination of key and value. For example:
       * .. code-block:: json
       *   { "subset_selectors": [
       *       { "keys": [ "version" ] },
       *       { "keys": [ "stage", "hardware_type" ] }
       *   ]}
       * A subset is matched when the metadata from the selected route and
       * weighted cluster contains the same keys and values as the subset's
       * metadata. The same host may appear in multiple subsets.
       * </pre>
       *
       * <code>repeated .envoy.api.v2.Cluster.LbSubsetConfig.LbSubsetSelector subset_selectors = 3;</code>
       */
      public Builder addSubsetSelectors(
          int index, io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfig.LbSubsetSelector value) {
        if (subsetSelectorsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureSubsetSelectorsIsMutable();
          subsetSelectors_.add(index, value);
          onChanged();
        } else {
          subsetSelectorsBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * For each entry, LbEndpoint.Metadata's
       * *envoy.lb* namespace is traversed and a subset is created for each unique
       * combination of key and value. For example:
       * .. code-block:: json
       *   { "subset_selectors": [
       *       { "keys": [ "version" ] },
       *       { "keys": [ "stage", "hardware_type" ] }
       *   ]}
       * A subset is matched when the metadata from the selected route and
       * weighted cluster contains the same keys and values as the subset's
       * metadata. The same host may appear in multiple subsets.
       * </pre>
       *
       * <code>repeated .envoy.api.v2.Cluster.LbSubsetConfig.LbSubsetSelector subset_selectors = 3;</code>
       */
      public Builder addSubsetSelectors(
          io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfig.LbSubsetSelector.Builder builderForValue) {
        if (subsetSelectorsBuilder_ == null) {
          ensureSubsetSelectorsIsMutable();
          subsetSelectors_.add(builderForValue.build());
          onChanged();
        } else {
          subsetSelectorsBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * For each entry, LbEndpoint.Metadata's
       * *envoy.lb* namespace is traversed and a subset is created for each unique
       * combination of key and value. For example:
       * .. code-block:: json
       *   { "subset_selectors": [
       *       { "keys": [ "version" ] },
       *       { "keys": [ "stage", "hardware_type" ] }
       *   ]}
       * A subset is matched when the metadata from the selected route and
       * weighted cluster contains the same keys and values as the subset's
       * metadata. The same host may appear in multiple subsets.
       * </pre>
       *
       * <code>repeated .envoy.api.v2.Cluster.LbSubsetConfig.LbSubsetSelector subset_selectors = 3;</code>
       */
      public Builder addSubsetSelectors(
          int index, io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfig.LbSubsetSelector.Builder builderForValue) {
        if (subsetSelectorsBuilder_ == null) {
          ensureSubsetSelectorsIsMutable();
          subsetSelectors_.add(index, builderForValue.build());
          onChanged();
        } else {
          subsetSelectorsBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * For each entry, LbEndpoint.Metadata's
       * *envoy.lb* namespace is traversed and a subset is created for each unique
       * combination of key and value. For example:
       * .. code-block:: json
       *   { "subset_selectors": [
       *       { "keys": [ "version" ] },
       *       { "keys": [ "stage", "hardware_type" ] }
       *   ]}
       * A subset is matched when the metadata from the selected route and
       * weighted cluster contains the same keys and values as the subset's
       * metadata. The same host may appear in multiple subsets.
       * </pre>
       *
       * <code>repeated .envoy.api.v2.Cluster.LbSubsetConfig.LbSubsetSelector subset_selectors = 3;</code>
       */
      public Builder addAllSubsetSelectors(
          java.lang.Iterable<? extends io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfig.LbSubsetSelector> values) {
        if (subsetSelectorsBuilder_ == null) {
          ensureSubsetSelectorsIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, subsetSelectors_);
          onChanged();
        } else {
          subsetSelectorsBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * For each entry, LbEndpoint.Metadata's
       * *envoy.lb* namespace is traversed and a subset is created for each unique
       * combination of key and value. For example:
       * .. code-block:: json
       *   { "subset_selectors": [
       *       { "keys": [ "version" ] },
       *       { "keys": [ "stage", "hardware_type" ] }
       *   ]}
       * A subset is matched when the metadata from the selected route and
       * weighted cluster contains the same keys and values as the subset's
       * metadata. The same host may appear in multiple subsets.
       * </pre>
       *
       * <code>repeated .envoy.api.v2.Cluster.LbSubsetConfig.LbSubsetSelector subset_selectors = 3;</code>
       */
      public Builder clearSubsetSelectors() {
        if (subsetSelectorsBuilder_ == null) {
          subsetSelectors_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000004);
          onChanged();
        } else {
          subsetSelectorsBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * For each entry, LbEndpoint.Metadata's
       * *envoy.lb* namespace is traversed and a subset is created for each unique
       * combination of key and value. For example:
       * .. code-block:: json
       *   { "subset_selectors": [
       *       { "keys": [ "version" ] },
       *       { "keys": [ "stage", "hardware_type" ] }
       *   ]}
       * A subset is matched when the metadata from the selected route and
       * weighted cluster contains the same keys and values as the subset's
       * metadata. The same host may appear in multiple subsets.
       * </pre>
       *
       * <code>repeated .envoy.api.v2.Cluster.LbSubsetConfig.LbSubsetSelector subset_selectors = 3;</code>
       */
      public Builder removeSubsetSelectors(int index) {
        if (subsetSelectorsBuilder_ == null) {
          ensureSubsetSelectorsIsMutable();
          subsetSelectors_.remove(index);
          onChanged();
        } else {
          subsetSelectorsBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * For each entry, LbEndpoint.Metadata's
       * *envoy.lb* namespace is traversed and a subset is created for each unique
       * combination of key and value. For example:
       * .. code-block:: json
       *   { "subset_selectors": [
       *       { "keys": [ "version" ] },
       *       { "keys": [ "stage", "hardware_type" ] }
       *   ]}
       * A subset is matched when the metadata from the selected route and
       * weighted cluster contains the same keys and values as the subset's
       * metadata. The same host may appear in multiple subsets.
       * </pre>
       *
       * <code>repeated .envoy.api.v2.Cluster.LbSubsetConfig.LbSubsetSelector subset_selectors = 3;</code>
       */
      public io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfig.LbSubsetSelector.Builder getSubsetSelectorsBuilder(
          int index) {
        return getSubsetSelectorsFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * For each entry, LbEndpoint.Metadata's
       * *envoy.lb* namespace is traversed and a subset is created for each unique
       * combination of key and value. For example:
       * .. code-block:: json
       *   { "subset_selectors": [
       *       { "keys": [ "version" ] },
       *       { "keys": [ "stage", "hardware_type" ] }
       *   ]}
       * A subset is matched when the metadata from the selected route and
       * weighted cluster contains the same keys and values as the subset's
       * metadata. The same host may appear in multiple subsets.
       * </pre>
       *
       * <code>repeated .envoy.api.v2.Cluster.LbSubsetConfig.LbSubsetSelector subset_selectors = 3;</code>
       */
      public io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfig.LbSubsetSelectorOrBuilder getSubsetSelectorsOrBuilder(
          int index) {
        if (subsetSelectorsBuilder_ == null) {
          return subsetSelectors_.get(index);  } else {
          return subsetSelectorsBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * For each entry, LbEndpoint.Metadata's
       * *envoy.lb* namespace is traversed and a subset is created for each unique
       * combination of key and value. For example:
       * .. code-block:: json
       *   { "subset_selectors": [
       *       { "keys": [ "version" ] },
       *       { "keys": [ "stage", "hardware_type" ] }
       *   ]}
       * A subset is matched when the metadata from the selected route and
       * weighted cluster contains the same keys and values as the subset's
       * metadata. The same host may appear in multiple subsets.
       * </pre>
       *
       * <code>repeated .envoy.api.v2.Cluster.LbSubsetConfig.LbSubsetSelector subset_selectors = 3;</code>
       */
      public java.util.List<? extends io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfig.LbSubsetSelectorOrBuilder> 
           getSubsetSelectorsOrBuilderList() {
        if (subsetSelectorsBuilder_ != null) {
          return subsetSelectorsBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(subsetSelectors_);
        }
      }
      /**
       * <pre>
       * For each entry, LbEndpoint.Metadata's
       * *envoy.lb* namespace is traversed and a subset is created for each unique
       * combination of key and value. For example:
       * .. code-block:: json
       *   { "subset_selectors": [
       *       { "keys": [ "version" ] },
       *       { "keys": [ "stage", "hardware_type" ] }
       *   ]}
       * A subset is matched when the metadata from the selected route and
       * weighted cluster contains the same keys and values as the subset's
       * metadata. The same host may appear in multiple subsets.
       * </pre>
       *
       * <code>repeated .envoy.api.v2.Cluster.LbSubsetConfig.LbSubsetSelector subset_selectors = 3;</code>
       */
      public io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfig.LbSubsetSelector.Builder addSubsetSelectorsBuilder() {
        return getSubsetSelectorsFieldBuilder().addBuilder(
            io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfig.LbSubsetSelector.getDefaultInstance());
      }
      /**
       * <pre>
       * For each entry, LbEndpoint.Metadata's
       * *envoy.lb* namespace is traversed and a subset is created for each unique
       * combination of key and value. For example:
       * .. code-block:: json
       *   { "subset_selectors": [
       *       { "keys": [ "version" ] },
       *       { "keys": [ "stage", "hardware_type" ] }
       *   ]}
       * A subset is matched when the metadata from the selected route and
       * weighted cluster contains the same keys and values as the subset's
       * metadata. The same host may appear in multiple subsets.
       * </pre>
       *
       * <code>repeated .envoy.api.v2.Cluster.LbSubsetConfig.LbSubsetSelector subset_selectors = 3;</code>
       */
      public io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfig.LbSubsetSelector.Builder addSubsetSelectorsBuilder(
          int index) {
        return getSubsetSelectorsFieldBuilder().addBuilder(
            index, io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfig.LbSubsetSelector.getDefaultInstance());
      }
      /**
       * <pre>
       * For each entry, LbEndpoint.Metadata's
       * *envoy.lb* namespace is traversed and a subset is created for each unique
       * combination of key and value. For example:
       * .. code-block:: json
       *   { "subset_selectors": [
       *       { "keys": [ "version" ] },
       *       { "keys": [ "stage", "hardware_type" ] }
       *   ]}
       * A subset is matched when the metadata from the selected route and
       * weighted cluster contains the same keys and values as the subset's
       * metadata. The same host may appear in multiple subsets.
       * </pre>
       *
       * <code>repeated .envoy.api.v2.Cluster.LbSubsetConfig.LbSubsetSelector subset_selectors = 3;</code>
       */
      public java.util.List<io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfig.LbSubsetSelector.Builder> 
           getSubsetSelectorsBuilderList() {
        return getSubsetSelectorsFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfig.LbSubsetSelector, io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfig.LbSubsetSelector.Builder, io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfig.LbSubsetSelectorOrBuilder> 
          getSubsetSelectorsFieldBuilder() {
        if (subsetSelectorsBuilder_ == null) {
          subsetSelectorsBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfig.LbSubsetSelector, io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfig.LbSubsetSelector.Builder, io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfig.LbSubsetSelectorOrBuilder>(
                  subsetSelectors_,
                  ((bitField0_ & 0x00000004) == 0x00000004),
                  getParentForChildren(),
                  isClean());
          subsetSelectors_ = null;
        }
        return subsetSelectorsBuilder_;
      }

      private boolean localityWeightAware_ ;
      /**
       * <pre>
       * If true, routing to subsets will take into account the localities and locality weights of the
       * endpoints when making the routing decision.
       * There are some potential pitfalls associated with enabling this feature, as the resulting
       * traffic split after applying both a subset match and locality weights might be undesirable.
       * Consider for example a situation in which you have 50/50 split across two localities X/Y
       * which have 100 hosts each without subsetting. If the subset LB results in X having only 1
       * host selected but Y having 100, then a lot more load is being dumped on the single host in X
       * than originally anticipated in the load balancing assignment delivered via EDS.
       * </pre>
       *
       * <code>bool locality_weight_aware = 4;</code>
       */
      public boolean getLocalityWeightAware() {
        return localityWeightAware_;
      }
      /**
       * <pre>
       * If true, routing to subsets will take into account the localities and locality weights of the
       * endpoints when making the routing decision.
       * There are some potential pitfalls associated with enabling this feature, as the resulting
       * traffic split after applying both a subset match and locality weights might be undesirable.
       * Consider for example a situation in which you have 50/50 split across two localities X/Y
       * which have 100 hosts each without subsetting. If the subset LB results in X having only 1
       * host selected but Y having 100, then a lot more load is being dumped on the single host in X
       * than originally anticipated in the load balancing assignment delivered via EDS.
       * </pre>
       *
       * <code>bool locality_weight_aware = 4;</code>
       */
      public Builder setLocalityWeightAware(boolean value) {
        
        localityWeightAware_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * If true, routing to subsets will take into account the localities and locality weights of the
       * endpoints when making the routing decision.
       * There are some potential pitfalls associated with enabling this feature, as the resulting
       * traffic split after applying both a subset match and locality weights might be undesirable.
       * Consider for example a situation in which you have 50/50 split across two localities X/Y
       * which have 100 hosts each without subsetting. If the subset LB results in X having only 1
       * host selected but Y having 100, then a lot more load is being dumped on the single host in X
       * than originally anticipated in the load balancing assignment delivered via EDS.
       * </pre>
       *
       * <code>bool locality_weight_aware = 4;</code>
       */
      public Builder clearLocalityWeightAware() {
        
        localityWeightAware_ = false;
        onChanged();
        return this;
      }

      private boolean scaleLocalityWeight_ ;
      /**
       * <pre>
       * When used with locality_weight_aware, scales the weight of each locality by the ratio
       * of hosts in the subset vs hosts in the original subset. This aims to even out the load
       * going to an individual locality if said locality is disproportionally affected by the
       * subset predicate.
       * </pre>
       *
       * <code>bool scale_locality_weight = 5;</code>
       */
      public boolean getScaleLocalityWeight() {
        return scaleLocalityWeight_;
      }
      /**
       * <pre>
       * When used with locality_weight_aware, scales the weight of each locality by the ratio
       * of hosts in the subset vs hosts in the original subset. This aims to even out the load
       * going to an individual locality if said locality is disproportionally affected by the
       * subset predicate.
       * </pre>
       *
       * <code>bool scale_locality_weight = 5;</code>
       */
      public Builder setScaleLocalityWeight(boolean value) {
        
        scaleLocalityWeight_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * When used with locality_weight_aware, scales the weight of each locality by the ratio
       * of hosts in the subset vs hosts in the original subset. This aims to even out the load
       * going to an individual locality if said locality is disproportionally affected by the
       * subset predicate.
       * </pre>
       *
       * <code>bool scale_locality_weight = 5;</code>
       */
      public Builder clearScaleLocalityWeight() {
        
        scaleLocalityWeight_ = false;
        onChanged();
        return this;
      }
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFieldsProto3(unknownFields);
      }

      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:envoy.api.v2.Cluster.LbSubsetConfig)
    }

    // @@protoc_insertion_point(class_scope:envoy.api.v2.Cluster.LbSubsetConfig)
    private static final io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfig DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfig();
    }

    public static io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfig getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<LbSubsetConfig>
        PARSER = new com.google.protobuf.AbstractParser<LbSubsetConfig>() {
      public LbSubsetConfig parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new LbSubsetConfig(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<LbSubsetConfig> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<LbSubsetConfig> getParserForType() {
      return PARSER;
    }

    public io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfig getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface LeastRequestLbConfigOrBuilder extends
      // @@protoc_insertion_point(interface_extends:envoy.api.v2.Cluster.LeastRequestLbConfig)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * The number of random healthy hosts from which the host with the fewest active requests will
     * be chosen. Defaults to 2 so that we perform two-choice selection if the field is not set.
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value choice_count = 1 [(.validate.rules) = { ... }</code>
     */
    boolean hasChoiceCount();
    /**
     * <pre>
     * The number of random healthy hosts from which the host with the fewest active requests will
     * be chosen. Defaults to 2 so that we perform two-choice selection if the field is not set.
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value choice_count = 1 [(.validate.rules) = { ... }</code>
     */
    com.google.protobuf.UInt32Value getChoiceCount();
    /**
     * <pre>
     * The number of random healthy hosts from which the host with the fewest active requests will
     * be chosen. Defaults to 2 so that we perform two-choice selection if the field is not set.
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value choice_count = 1 [(.validate.rules) = { ... }</code>
     */
    com.google.protobuf.UInt32ValueOrBuilder getChoiceCountOrBuilder();
  }
  /**
   * <pre>
   * Specific configuration for the LeastRequest load balancing policy.
   * </pre>
   *
   * Protobuf type {@code envoy.api.v2.Cluster.LeastRequestLbConfig}
   */
  public  static final class LeastRequestLbConfig extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:envoy.api.v2.Cluster.LeastRequestLbConfig)
      LeastRequestLbConfigOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use LeastRequestLbConfig.newBuilder() to construct.
    private LeastRequestLbConfig(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private LeastRequestLbConfig() {
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private LeastRequestLbConfig(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!parseUnknownFieldProto3(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
            case 10: {
              com.google.protobuf.UInt32Value.Builder subBuilder = null;
              if (choiceCount_ != null) {
                subBuilder = choiceCount_.toBuilder();
              }
              choiceCount_ = input.readMessage(com.google.protobuf.UInt32Value.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(choiceCount_);
                choiceCount_ = subBuilder.buildPartial();
              }

              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.grpc.xds.shaded.envoy.api.v2.Cds.internal_static_envoy_api_v2_Cluster_LeastRequestLbConfig_descriptor;
    }

    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.grpc.xds.shaded.envoy.api.v2.Cds.internal_static_envoy_api_v2_Cluster_LeastRequestLbConfig_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.grpc.xds.shaded.envoy.api.v2.Cluster.LeastRequestLbConfig.class, io.grpc.xds.shaded.envoy.api.v2.Cluster.LeastRequestLbConfig.Builder.class);
    }

    public static final int CHOICE_COUNT_FIELD_NUMBER = 1;
    private com.google.protobuf.UInt32Value choiceCount_;
    /**
     * <pre>
     * The number of random healthy hosts from which the host with the fewest active requests will
     * be chosen. Defaults to 2 so that we perform two-choice selection if the field is not set.
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value choice_count = 1 [(.validate.rules) = { ... }</code>
     */
    public boolean hasChoiceCount() {
      return choiceCount_ != null;
    }
    /**
     * <pre>
     * The number of random healthy hosts from which the host with the fewest active requests will
     * be chosen. Defaults to 2 so that we perform two-choice selection if the field is not set.
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value choice_count = 1 [(.validate.rules) = { ... }</code>
     */
    public com.google.protobuf.UInt32Value getChoiceCount() {
      return choiceCount_ == null ? com.google.protobuf.UInt32Value.getDefaultInstance() : choiceCount_;
    }
    /**
     * <pre>
     * The number of random healthy hosts from which the host with the fewest active requests will
     * be chosen. Defaults to 2 so that we perform two-choice selection if the field is not set.
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value choice_count = 1 [(.validate.rules) = { ... }</code>
     */
    public com.google.protobuf.UInt32ValueOrBuilder getChoiceCountOrBuilder() {
      return getChoiceCount();
    }

    private byte memoizedIsInitialized = -1;
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (choiceCount_ != null) {
        output.writeMessage(1, getChoiceCount());
      }
      unknownFields.writeTo(output);
    }

    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (choiceCount_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, getChoiceCount());
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.grpc.xds.shaded.envoy.api.v2.Cluster.LeastRequestLbConfig)) {
        return super.equals(obj);
      }
      io.grpc.xds.shaded.envoy.api.v2.Cluster.LeastRequestLbConfig other = (io.grpc.xds.shaded.envoy.api.v2.Cluster.LeastRequestLbConfig) obj;

      boolean result = true;
      result = result && (hasChoiceCount() == other.hasChoiceCount());
      if (hasChoiceCount()) {
        result = result && getChoiceCount()
            .equals(other.getChoiceCount());
      }
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasChoiceCount()) {
        hash = (37 * hash) + CHOICE_COUNT_FIELD_NUMBER;
        hash = (53 * hash) + getChoiceCount().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.grpc.xds.shaded.envoy.api.v2.Cluster.LeastRequestLbConfig parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.grpc.xds.shaded.envoy.api.v2.Cluster.LeastRequestLbConfig parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.grpc.xds.shaded.envoy.api.v2.Cluster.LeastRequestLbConfig parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.grpc.xds.shaded.envoy.api.v2.Cluster.LeastRequestLbConfig parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.grpc.xds.shaded.envoy.api.v2.Cluster.LeastRequestLbConfig parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.grpc.xds.shaded.envoy.api.v2.Cluster.LeastRequestLbConfig parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.grpc.xds.shaded.envoy.api.v2.Cluster.LeastRequestLbConfig parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.grpc.xds.shaded.envoy.api.v2.Cluster.LeastRequestLbConfig parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.grpc.xds.shaded.envoy.api.v2.Cluster.LeastRequestLbConfig parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static io.grpc.xds.shaded.envoy.api.v2.Cluster.LeastRequestLbConfig parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.grpc.xds.shaded.envoy.api.v2.Cluster.LeastRequestLbConfig parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.grpc.xds.shaded.envoy.api.v2.Cluster.LeastRequestLbConfig parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.grpc.xds.shaded.envoy.api.v2.Cluster.LeastRequestLbConfig prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Specific configuration for the LeastRequest load balancing policy.
     * </pre>
     *
     * Protobuf type {@code envoy.api.v2.Cluster.LeastRequestLbConfig}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:envoy.api.v2.Cluster.LeastRequestLbConfig)
        io.grpc.xds.shaded.envoy.api.v2.Cluster.LeastRequestLbConfigOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.grpc.xds.shaded.envoy.api.v2.Cds.internal_static_envoy_api_v2_Cluster_LeastRequestLbConfig_descriptor;
      }

      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.grpc.xds.shaded.envoy.api.v2.Cds.internal_static_envoy_api_v2_Cluster_LeastRequestLbConfig_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.grpc.xds.shaded.envoy.api.v2.Cluster.LeastRequestLbConfig.class, io.grpc.xds.shaded.envoy.api.v2.Cluster.LeastRequestLbConfig.Builder.class);
      }

      // Construct using io.grpc.xds.shaded.envoy.api.v2.Cluster.LeastRequestLbConfig.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      public Builder clear() {
        super.clear();
        if (choiceCountBuilder_ == null) {
          choiceCount_ = null;
        } else {
          choiceCount_ = null;
          choiceCountBuilder_ = null;
        }
        return this;
      }

      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.grpc.xds.shaded.envoy.api.v2.Cds.internal_static_envoy_api_v2_Cluster_LeastRequestLbConfig_descriptor;
      }

      public io.grpc.xds.shaded.envoy.api.v2.Cluster.LeastRequestLbConfig getDefaultInstanceForType() {
        return io.grpc.xds.shaded.envoy.api.v2.Cluster.LeastRequestLbConfig.getDefaultInstance();
      }

      public io.grpc.xds.shaded.envoy.api.v2.Cluster.LeastRequestLbConfig build() {
        io.grpc.xds.shaded.envoy.api.v2.Cluster.LeastRequestLbConfig result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      public io.grpc.xds.shaded.envoy.api.v2.Cluster.LeastRequestLbConfig buildPartial() {
        io.grpc.xds.shaded.envoy.api.v2.Cluster.LeastRequestLbConfig result = new io.grpc.xds.shaded.envoy.api.v2.Cluster.LeastRequestLbConfig(this);
        if (choiceCountBuilder_ == null) {
          result.choiceCount_ = choiceCount_;
        } else {
          result.choiceCount_ = choiceCountBuilder_.build();
        }
        onBuilt();
        return result;
      }

      public Builder clone() {
        return (Builder) super.clone();
      }
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.grpc.xds.shaded.envoy.api.v2.Cluster.LeastRequestLbConfig) {
          return mergeFrom((io.grpc.xds.shaded.envoy.api.v2.Cluster.LeastRequestLbConfig)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.grpc.xds.shaded.envoy.api.v2.Cluster.LeastRequestLbConfig other) {
        if (other == io.grpc.xds.shaded.envoy.api.v2.Cluster.LeastRequestLbConfig.getDefaultInstance()) return this;
        if (other.hasChoiceCount()) {
          mergeChoiceCount(other.getChoiceCount());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      public final boolean isInitialized() {
        return true;
      }

      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.grpc.xds.shaded.envoy.api.v2.Cluster.LeastRequestLbConfig parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (io.grpc.xds.shaded.envoy.api.v2.Cluster.LeastRequestLbConfig) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }

      private com.google.protobuf.UInt32Value choiceCount_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          com.google.protobuf.UInt32Value, com.google.protobuf.UInt32Value.Builder, com.google.protobuf.UInt32ValueOrBuilder> choiceCountBuilder_;
      /**
       * <pre>
       * The number of random healthy hosts from which the host with the fewest active requests will
       * be chosen. Defaults to 2 so that we perform two-choice selection if the field is not set.
       * </pre>
       *
       * <code>.google.protobuf.UInt32Value choice_count = 1 [(.validate.rules) = { ... }</code>
       */
      public boolean hasChoiceCount() {
        return choiceCountBuilder_ != null || choiceCount_ != null;
      }
      /**
       * <pre>
       * The number of random healthy hosts from which the host with the fewest active requests will
       * be chosen. Defaults to 2 so that we perform two-choice selection if the field is not set.
       * </pre>
       *
       * <code>.google.protobuf.UInt32Value choice_count = 1 [(.validate.rules) = { ... }</code>
       */
      public com.google.protobuf.UInt32Value getChoiceCount() {
        if (choiceCountBuilder_ == null) {
          return choiceCount_ == null ? com.google.protobuf.UInt32Value.getDefaultInstance() : choiceCount_;
        } else {
          return choiceCountBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * The number of random healthy hosts from which the host with the fewest active requests will
       * be chosen. Defaults to 2 so that we perform two-choice selection if the field is not set.
       * </pre>
       *
       * <code>.google.protobuf.UInt32Value choice_count = 1 [(.validate.rules) = { ... }</code>
       */
      public Builder setChoiceCount(com.google.protobuf.UInt32Value value) {
        if (choiceCountBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          choiceCount_ = value;
          onChanged();
        } else {
          choiceCountBuilder_.setMessage(value);
        }

        return this;
      }
      /**
       * <pre>
       * The number of random healthy hosts from which the host with the fewest active requests will
       * be chosen. Defaults to 2 so that we perform two-choice selection if the field is not set.
       * </pre>
       *
       * <code>.google.protobuf.UInt32Value choice_count = 1 [(.validate.rules) = { ... }</code>
       */
      public Builder setChoiceCount(
          com.google.protobuf.UInt32Value.Builder builderForValue) {
        if (choiceCountBuilder_ == null) {
          choiceCount_ = builderForValue.build();
          onChanged();
        } else {
          choiceCountBuilder_.setMessage(builderForValue.build());
        }

        return this;
      }
      /**
       * <pre>
       * The number of random healthy hosts from which the host with the fewest active requests will
       * be chosen. Defaults to 2 so that we perform two-choice selection if the field is not set.
       * </pre>
       *
       * <code>.google.protobuf.UInt32Value choice_count = 1 [(.validate.rules) = { ... }</code>
       */
      public Builder mergeChoiceCount(com.google.protobuf.UInt32Value value) {
        if (choiceCountBuilder_ == null) {
          if (choiceCount_ != null) {
            choiceCount_ =
              com.google.protobuf.UInt32Value.newBuilder(choiceCount_).mergeFrom(value).buildPartial();
          } else {
            choiceCount_ = value;
          }
          onChanged();
        } else {
          choiceCountBuilder_.mergeFrom(value);
        }

        return this;
      }
      /**
       * <pre>
       * The number of random healthy hosts from which the host with the fewest active requests will
       * be chosen. Defaults to 2 so that we perform two-choice selection if the field is not set.
       * </pre>
       *
       * <code>.google.protobuf.UInt32Value choice_count = 1 [(.validate.rules) = { ... }</code>
       */
      public Builder clearChoiceCount() {
        if (choiceCountBuilder_ == null) {
          choiceCount_ = null;
          onChanged();
        } else {
          choiceCount_ = null;
          choiceCountBuilder_ = null;
        }

        return this;
      }
      /**
       * <pre>
       * The number of random healthy hosts from which the host with the fewest active requests will
       * be chosen. Defaults to 2 so that we perform two-choice selection if the field is not set.
       * </pre>
       *
       * <code>.google.protobuf.UInt32Value choice_count = 1 [(.validate.rules) = { ... }</code>
       */
      public com.google.protobuf.UInt32Value.Builder getChoiceCountBuilder() {
        
        onChanged();
        return getChoiceCountFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * The number of random healthy hosts from which the host with the fewest active requests will
       * be chosen. Defaults to 2 so that we perform two-choice selection if the field is not set.
       * </pre>
       *
       * <code>.google.protobuf.UInt32Value choice_count = 1 [(.validate.rules) = { ... }</code>
       */
      public com.google.protobuf.UInt32ValueOrBuilder getChoiceCountOrBuilder() {
        if (choiceCountBuilder_ != null) {
          return choiceCountBuilder_.getMessageOrBuilder();
        } else {
          return choiceCount_ == null ?
              com.google.protobuf.UInt32Value.getDefaultInstance() : choiceCount_;
        }
      }
      /**
       * <pre>
       * The number of random healthy hosts from which the host with the fewest active requests will
       * be chosen. Defaults to 2 so that we perform two-choice selection if the field is not set.
       * </pre>
       *
       * <code>.google.protobuf.UInt32Value choice_count = 1 [(.validate.rules) = { ... }</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          com.google.protobuf.UInt32Value, com.google.protobuf.UInt32Value.Builder, com.google.protobuf.UInt32ValueOrBuilder> 
          getChoiceCountFieldBuilder() {
        if (choiceCountBuilder_ == null) {
          choiceCountBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              com.google.protobuf.UInt32Value, com.google.protobuf.UInt32Value.Builder, com.google.protobuf.UInt32ValueOrBuilder>(
                  getChoiceCount(),
                  getParentForChildren(),
                  isClean());
          choiceCount_ = null;
        }
        return choiceCountBuilder_;
      }
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFieldsProto3(unknownFields);
      }

      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:envoy.api.v2.Cluster.LeastRequestLbConfig)
    }

    // @@protoc_insertion_point(class_scope:envoy.api.v2.Cluster.LeastRequestLbConfig)
    private static final io.grpc.xds.shaded.envoy.api.v2.Cluster.LeastRequestLbConfig DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.grpc.xds.shaded.envoy.api.v2.Cluster.LeastRequestLbConfig();
    }

    public static io.grpc.xds.shaded.envoy.api.v2.Cluster.LeastRequestLbConfig getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<LeastRequestLbConfig>
        PARSER = new com.google.protobuf.AbstractParser<LeastRequestLbConfig>() {
      public LeastRequestLbConfig parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new LeastRequestLbConfig(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<LeastRequestLbConfig> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<LeastRequestLbConfig> getParserForType() {
      return PARSER;
    }

    public io.grpc.xds.shaded.envoy.api.v2.Cluster.LeastRequestLbConfig getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface RingHashLbConfigOrBuilder extends
      // @@protoc_insertion_point(interface_extends:envoy.api.v2.Cluster.RingHashLbConfig)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Minimum hash ring size, i.e. total virtual nodes. A larger size
     * will provide better request distribution since each host in the
     * cluster will have more virtual nodes. Defaults to 1024. In the case
     * that total number of hosts is greater than the minimum, each host will
     * be allocated a single virtual node. This field is limited to 8M to bound
     * resource use.
     * </pre>
     *
     * <code>.google.protobuf.UInt64Value minimum_ring_size = 1 [(.validate.rules) = { ... }</code>
     */
    boolean hasMinimumRingSize();
    /**
     * <pre>
     * Minimum hash ring size, i.e. total virtual nodes. A larger size
     * will provide better request distribution since each host in the
     * cluster will have more virtual nodes. Defaults to 1024. In the case
     * that total number of hosts is greater than the minimum, each host will
     * be allocated a single virtual node. This field is limited to 8M to bound
     * resource use.
     * </pre>
     *
     * <code>.google.protobuf.UInt64Value minimum_ring_size = 1 [(.validate.rules) = { ... }</code>
     */
    com.google.protobuf.UInt64Value getMinimumRingSize();
    /**
     * <pre>
     * Minimum hash ring size, i.e. total virtual nodes. A larger size
     * will provide better request distribution since each host in the
     * cluster will have more virtual nodes. Defaults to 1024. In the case
     * that total number of hosts is greater than the minimum, each host will
     * be allocated a single virtual node. This field is limited to 8M to bound
     * resource use.
     * </pre>
     *
     * <code>.google.protobuf.UInt64Value minimum_ring_size = 1 [(.validate.rules) = { ... }</code>
     */
    com.google.protobuf.UInt64ValueOrBuilder getMinimumRingSizeOrBuilder();

    /**
     * <pre>
     * Deprecated settings from v1 config.
     * [#not-implemented-hide:] Hide from docs.
     * </pre>
     *
     * <code>.envoy.api.v2.Cluster.RingHashLbConfig.DeprecatedV1 deprecated_v1 = 2 [deprecated = true];</code>
     */
    @java.lang.Deprecated boolean hasDeprecatedV1();
    /**
     * <pre>
     * Deprecated settings from v1 config.
     * [#not-implemented-hide:] Hide from docs.
     * </pre>
     *
     * <code>.envoy.api.v2.Cluster.RingHashLbConfig.DeprecatedV1 deprecated_v1 = 2 [deprecated = true];</code>
     */
    @java.lang.Deprecated io.grpc.xds.shaded.envoy.api.v2.Cluster.RingHashLbConfig.DeprecatedV1 getDeprecatedV1();
    /**
     * <pre>
     * Deprecated settings from v1 config.
     * [#not-implemented-hide:] Hide from docs.
     * </pre>
     *
     * <code>.envoy.api.v2.Cluster.RingHashLbConfig.DeprecatedV1 deprecated_v1 = 2 [deprecated = true];</code>
     */
    @java.lang.Deprecated io.grpc.xds.shaded.envoy.api.v2.Cluster.RingHashLbConfig.DeprecatedV1OrBuilder getDeprecatedV1OrBuilder();
  }
  /**
   * <pre>
   * Specific configuration for the :ref:`RingHash&lt;arch_overview_load_balancing_types_ring_hash&gt;`
   * load balancing policy.
   * </pre>
   *
   * Protobuf type {@code envoy.api.v2.Cluster.RingHashLbConfig}
   */
  public  static final class RingHashLbConfig extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:envoy.api.v2.Cluster.RingHashLbConfig)
      RingHashLbConfigOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use RingHashLbConfig.newBuilder() to construct.
    private RingHashLbConfig(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private RingHashLbConfig() {
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private RingHashLbConfig(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!parseUnknownFieldProto3(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
            case 10: {
              com.google.protobuf.UInt64Value.Builder subBuilder = null;
              if (minimumRingSize_ != null) {
                subBuilder = minimumRingSize_.toBuilder();
              }
              minimumRingSize_ = input.readMessage(com.google.protobuf.UInt64Value.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(minimumRingSize_);
                minimumRingSize_ = subBuilder.buildPartial();
              }

              break;
            }
            case 18: {
              io.grpc.xds.shaded.envoy.api.v2.Cluster.RingHashLbConfig.DeprecatedV1.Builder subBuilder = null;
              if (deprecatedV1_ != null) {
                subBuilder = deprecatedV1_.toBuilder();
              }
              deprecatedV1_ = input.readMessage(io.grpc.xds.shaded.envoy.api.v2.Cluster.RingHashLbConfig.DeprecatedV1.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(deprecatedV1_);
                deprecatedV1_ = subBuilder.buildPartial();
              }

              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.grpc.xds.shaded.envoy.api.v2.Cds.internal_static_envoy_api_v2_Cluster_RingHashLbConfig_descriptor;
    }

    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.grpc.xds.shaded.envoy.api.v2.Cds.internal_static_envoy_api_v2_Cluster_RingHashLbConfig_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.grpc.xds.shaded.envoy.api.v2.Cluster.RingHashLbConfig.class, io.grpc.xds.shaded.envoy.api.v2.Cluster.RingHashLbConfig.Builder.class);
    }

    public interface DeprecatedV1OrBuilder extends
        // @@protoc_insertion_point(interface_extends:envoy.api.v2.Cluster.RingHashLbConfig.DeprecatedV1)
        com.google.protobuf.MessageOrBuilder {

      /**
       * <pre>
       * Defaults to false, meaning that `xxHash &lt;https://github.com/Cyan4973/xxHash&gt;`_
       * is to hash hosts onto the ketama ring.
       * </pre>
       *
       * <code>.google.protobuf.BoolValue use_std_hash = 1;</code>
       */
      boolean hasUseStdHash();
      /**
       * <pre>
       * Defaults to false, meaning that `xxHash &lt;https://github.com/Cyan4973/xxHash&gt;`_
       * is to hash hosts onto the ketama ring.
       * </pre>
       *
       * <code>.google.protobuf.BoolValue use_std_hash = 1;</code>
       */
      com.google.protobuf.BoolValue getUseStdHash();
      /**
       * <pre>
       * Defaults to false, meaning that `xxHash &lt;https://github.com/Cyan4973/xxHash&gt;`_
       * is to hash hosts onto the ketama ring.
       * </pre>
       *
       * <code>.google.protobuf.BoolValue use_std_hash = 1;</code>
       */
      com.google.protobuf.BoolValueOrBuilder getUseStdHashOrBuilder();
    }
    /**
     * <pre>
     * [#not-implemented-hide:] Hide from docs.
     * </pre>
     *
     * Protobuf type {@code envoy.api.v2.Cluster.RingHashLbConfig.DeprecatedV1}
     */
    public  static final class DeprecatedV1 extends
        com.google.protobuf.GeneratedMessageV3 implements
        // @@protoc_insertion_point(message_implements:envoy.api.v2.Cluster.RingHashLbConfig.DeprecatedV1)
        DeprecatedV1OrBuilder {
    private static final long serialVersionUID = 0L;
      // Use DeprecatedV1.newBuilder() to construct.
      private DeprecatedV1(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
        super(builder);
      }
      private DeprecatedV1() {
      }

      @java.lang.Override
      public final com.google.protobuf.UnknownFieldSet
      getUnknownFields() {
        return this.unknownFields;
      }
      private DeprecatedV1(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        this();
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        int mutable_bitField0_ = 0;
        com.google.protobuf.UnknownFieldSet.Builder unknownFields =
            com.google.protobuf.UnknownFieldSet.newBuilder();
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              default: {
                if (!parseUnknownFieldProto3(
                    input, unknownFields, extensionRegistry, tag)) {
                  done = true;
                }
                break;
              }
              case 10: {
                com.google.protobuf.BoolValue.Builder subBuilder = null;
                if (useStdHash_ != null) {
                  subBuilder = useStdHash_.toBuilder();
                }
                useStdHash_ = input.readMessage(com.google.protobuf.BoolValue.parser(), extensionRegistry);
                if (subBuilder != null) {
                  subBuilder.mergeFrom(useStdHash_);
                  useStdHash_ = subBuilder.buildPartial();
                }

                break;
              }
            }
          }
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(this);
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(
              e).setUnfinishedMessage(this);
        } finally {
          this.unknownFields = unknownFields.build();
          makeExtensionsImmutable();
        }
      }
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.grpc.xds.shaded.envoy.api.v2.Cds.internal_static_envoy_api_v2_Cluster_RingHashLbConfig_DeprecatedV1_descriptor;
      }

      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.grpc.xds.shaded.envoy.api.v2.Cds.internal_static_envoy_api_v2_Cluster_RingHashLbConfig_DeprecatedV1_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.grpc.xds.shaded.envoy.api.v2.Cluster.RingHashLbConfig.DeprecatedV1.class, io.grpc.xds.shaded.envoy.api.v2.Cluster.RingHashLbConfig.DeprecatedV1.Builder.class);
      }

      public static final int USE_STD_HASH_FIELD_NUMBER = 1;
      private com.google.protobuf.BoolValue useStdHash_;
      /**
       * <pre>
       * Defaults to false, meaning that `xxHash &lt;https://github.com/Cyan4973/xxHash&gt;`_
       * is to hash hosts onto the ketama ring.
       * </pre>
       *
       * <code>.google.protobuf.BoolValue use_std_hash = 1;</code>
       */
      public boolean hasUseStdHash() {
        return useStdHash_ != null;
      }
      /**
       * <pre>
       * Defaults to false, meaning that `xxHash &lt;https://github.com/Cyan4973/xxHash&gt;`_
       * is to hash hosts onto the ketama ring.
       * </pre>
       *
       * <code>.google.protobuf.BoolValue use_std_hash = 1;</code>
       */
      public com.google.protobuf.BoolValue getUseStdHash() {
        return useStdHash_ == null ? com.google.protobuf.BoolValue.getDefaultInstance() : useStdHash_;
      }
      /**
       * <pre>
       * Defaults to false, meaning that `xxHash &lt;https://github.com/Cyan4973/xxHash&gt;`_
       * is to hash hosts onto the ketama ring.
       * </pre>
       *
       * <code>.google.protobuf.BoolValue use_std_hash = 1;</code>
       */
      public com.google.protobuf.BoolValueOrBuilder getUseStdHashOrBuilder() {
        return getUseStdHash();
      }

      private byte memoizedIsInitialized = -1;
      public final boolean isInitialized() {
        byte isInitialized = memoizedIsInitialized;
        if (isInitialized == 1) return true;
        if (isInitialized == 0) return false;

        memoizedIsInitialized = 1;
        return true;
      }

      public void writeTo(com.google.protobuf.CodedOutputStream output)
                          throws java.io.IOException {
        if (useStdHash_ != null) {
          output.writeMessage(1, getUseStdHash());
        }
        unknownFields.writeTo(output);
      }

      public int getSerializedSize() {
        int size = memoizedSize;
        if (size != -1) return size;

        size = 0;
        if (useStdHash_ != null) {
          size += com.google.protobuf.CodedOutputStream
            .computeMessageSize(1, getUseStdHash());
        }
        size += unknownFields.getSerializedSize();
        memoizedSize = size;
        return size;
      }

      @java.lang.Override
      public boolean equals(final java.lang.Object obj) {
        if (obj == this) {
         return true;
        }
        if (!(obj instanceof io.grpc.xds.shaded.envoy.api.v2.Cluster.RingHashLbConfig.DeprecatedV1)) {
          return super.equals(obj);
        }
        io.grpc.xds.shaded.envoy.api.v2.Cluster.RingHashLbConfig.DeprecatedV1 other = (io.grpc.xds.shaded.envoy.api.v2.Cluster.RingHashLbConfig.DeprecatedV1) obj;

        boolean result = true;
        result = result && (hasUseStdHash() == other.hasUseStdHash());
        if (hasUseStdHash()) {
          result = result && getUseStdHash()
              .equals(other.getUseStdHash());
        }
        result = result && unknownFields.equals(other.unknownFields);
        return result;
      }

      @java.lang.Override
      public int hashCode() {
        if (memoizedHashCode != 0) {
          return memoizedHashCode;
        }
        int hash = 41;
        hash = (19 * hash) + getDescriptor().hashCode();
        if (hasUseStdHash()) {
          hash = (37 * hash) + USE_STD_HASH_FIELD_NUMBER;
          hash = (53 * hash) + getUseStdHash().hashCode();
        }
        hash = (29 * hash) + unknownFields.hashCode();
        memoizedHashCode = hash;
        return hash;
      }

      public static io.grpc.xds.shaded.envoy.api.v2.Cluster.RingHashLbConfig.DeprecatedV1 parseFrom(
          java.nio.ByteBuffer data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static io.grpc.xds.shaded.envoy.api.v2.Cluster.RingHashLbConfig.DeprecatedV1 parseFrom(
          java.nio.ByteBuffer data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static io.grpc.xds.shaded.envoy.api.v2.Cluster.RingHashLbConfig.DeprecatedV1 parseFrom(
          com.google.protobuf.ByteString data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static io.grpc.xds.shaded.envoy.api.v2.Cluster.RingHashLbConfig.DeprecatedV1 parseFrom(
          com.google.protobuf.ByteString data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static io.grpc.xds.shaded.envoy.api.v2.Cluster.RingHashLbConfig.DeprecatedV1 parseFrom(byte[] data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static io.grpc.xds.shaded.envoy.api.v2.Cluster.RingHashLbConfig.DeprecatedV1 parseFrom(
          byte[] data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static io.grpc.xds.shaded.envoy.api.v2.Cluster.RingHashLbConfig.DeprecatedV1 parseFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input);
      }
      public static io.grpc.xds.shaded.envoy.api.v2.Cluster.RingHashLbConfig.DeprecatedV1 parseFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input, extensionRegistry);
      }
      public static io.grpc.xds.shaded.envoy.api.v2.Cluster.RingHashLbConfig.DeprecatedV1 parseDelimitedFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseDelimitedWithIOException(PARSER, input);
      }
      public static io.grpc.xds.shaded.envoy.api.v2.Cluster.RingHashLbConfig.DeprecatedV1 parseDelimitedFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
      }
      public static io.grpc.xds.shaded.envoy.api.v2.Cluster.RingHashLbConfig.DeprecatedV1 parseFrom(
          com.google.protobuf.CodedInputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input);
      }
      public static io.grpc.xds.shaded.envoy.api.v2.Cluster.RingHashLbConfig.DeprecatedV1 parseFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input, extensionRegistry);
      }

      public Builder newBuilderForType() { return newBuilder(); }
      public static Builder newBuilder() {
        return DEFAULT_INSTANCE.toBuilder();
      }
      public static Builder newBuilder(io.grpc.xds.shaded.envoy.api.v2.Cluster.RingHashLbConfig.DeprecatedV1 prototype) {
        return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
      }
      public Builder toBuilder() {
        return this == DEFAULT_INSTANCE
            ? new Builder() : new Builder().mergeFrom(this);
      }

      @java.lang.Override
      protected Builder newBuilderForType(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        Builder builder = new Builder(parent);
        return builder;
      }
      /**
       * <pre>
       * [#not-implemented-hide:] Hide from docs.
       * </pre>
       *
       * Protobuf type {@code envoy.api.v2.Cluster.RingHashLbConfig.DeprecatedV1}
       */
      public static final class Builder extends
          com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
          // @@protoc_insertion_point(builder_implements:envoy.api.v2.Cluster.RingHashLbConfig.DeprecatedV1)
          io.grpc.xds.shaded.envoy.api.v2.Cluster.RingHashLbConfig.DeprecatedV1OrBuilder {
        public static final com.google.protobuf.Descriptors.Descriptor
            getDescriptor() {
          return io.grpc.xds.shaded.envoy.api.v2.Cds.internal_static_envoy_api_v2_Cluster_RingHashLbConfig_DeprecatedV1_descriptor;
        }

        protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
            internalGetFieldAccessorTable() {
          return io.grpc.xds.shaded.envoy.api.v2.Cds.internal_static_envoy_api_v2_Cluster_RingHashLbConfig_DeprecatedV1_fieldAccessorTable
              .ensureFieldAccessorsInitialized(
                  io.grpc.xds.shaded.envoy.api.v2.Cluster.RingHashLbConfig.DeprecatedV1.class, io.grpc.xds.shaded.envoy.api.v2.Cluster.RingHashLbConfig.DeprecatedV1.Builder.class);
        }

        // Construct using io.grpc.xds.shaded.envoy.api.v2.Cluster.RingHashLbConfig.DeprecatedV1.newBuilder()
        private Builder() {
          maybeForceBuilderInitialization();
        }

        private Builder(
            com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
          super(parent);
          maybeForceBuilderInitialization();
        }
        private void maybeForceBuilderInitialization() {
          if (com.google.protobuf.GeneratedMessageV3
                  .alwaysUseFieldBuilders) {
          }
        }
        public Builder clear() {
          super.clear();
          if (useStdHashBuilder_ == null) {
            useStdHash_ = null;
          } else {
            useStdHash_ = null;
            useStdHashBuilder_ = null;
          }
          return this;
        }

        public com.google.protobuf.Descriptors.Descriptor
            getDescriptorForType() {
          return io.grpc.xds.shaded.envoy.api.v2.Cds.internal_static_envoy_api_v2_Cluster_RingHashLbConfig_DeprecatedV1_descriptor;
        }

        public io.grpc.xds.shaded.envoy.api.v2.Cluster.RingHashLbConfig.DeprecatedV1 getDefaultInstanceForType() {
          return io.grpc.xds.shaded.envoy.api.v2.Cluster.RingHashLbConfig.DeprecatedV1.getDefaultInstance();
        }

        public io.grpc.xds.shaded.envoy.api.v2.Cluster.RingHashLbConfig.DeprecatedV1 build() {
          io.grpc.xds.shaded.envoy.api.v2.Cluster.RingHashLbConfig.DeprecatedV1 result = buildPartial();
          if (!result.isInitialized()) {
            throw newUninitializedMessageException(result);
          }
          return result;
        }

        public io.grpc.xds.shaded.envoy.api.v2.Cluster.RingHashLbConfig.DeprecatedV1 buildPartial() {
          io.grpc.xds.shaded.envoy.api.v2.Cluster.RingHashLbConfig.DeprecatedV1 result = new io.grpc.xds.shaded.envoy.api.v2.Cluster.RingHashLbConfig.DeprecatedV1(this);
          if (useStdHashBuilder_ == null) {
            result.useStdHash_ = useStdHash_;
          } else {
            result.useStdHash_ = useStdHashBuilder_.build();
          }
          onBuilt();
          return result;
        }

        public Builder clone() {
          return (Builder) super.clone();
        }
        public Builder setField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            java.lang.Object value) {
          return (Builder) super.setField(field, value);
        }
        public Builder clearField(
            com.google.protobuf.Descriptors.FieldDescriptor field) {
          return (Builder) super.clearField(field);
        }
        public Builder clearOneof(
            com.google.protobuf.Descriptors.OneofDescriptor oneof) {
          return (Builder) super.clearOneof(oneof);
        }
        public Builder setRepeatedField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            int index, java.lang.Object value) {
          return (Builder) super.setRepeatedField(field, index, value);
        }
        public Builder addRepeatedField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            java.lang.Object value) {
          return (Builder) super.addRepeatedField(field, value);
        }
        public Builder mergeFrom(com.google.protobuf.Message other) {
          if (other instanceof io.grpc.xds.shaded.envoy.api.v2.Cluster.RingHashLbConfig.DeprecatedV1) {
            return mergeFrom((io.grpc.xds.shaded.envoy.api.v2.Cluster.RingHashLbConfig.DeprecatedV1)other);
          } else {
            super.mergeFrom(other);
            return this;
          }
        }

        public Builder mergeFrom(io.grpc.xds.shaded.envoy.api.v2.Cluster.RingHashLbConfig.DeprecatedV1 other) {
          if (other == io.grpc.xds.shaded.envoy.api.v2.Cluster.RingHashLbConfig.DeprecatedV1.getDefaultInstance()) return this;
          if (other.hasUseStdHash()) {
            mergeUseStdHash(other.getUseStdHash());
          }
          this.mergeUnknownFields(other.unknownFields);
          onChanged();
          return this;
        }

        public final boolean isInitialized() {
          return true;
        }

        public Builder mergeFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
          io.grpc.xds.shaded.envoy.api.v2.Cluster.RingHashLbConfig.DeprecatedV1 parsedMessage = null;
          try {
            parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            parsedMessage = (io.grpc.xds.shaded.envoy.api.v2.Cluster.RingHashLbConfig.DeprecatedV1) e.getUnfinishedMessage();
            throw e.unwrapIOException();
          } finally {
            if (parsedMessage != null) {
              mergeFrom(parsedMessage);
            }
          }
          return this;
        }

        private com.google.protobuf.BoolValue useStdHash_ = null;
        private com.google.protobuf.SingleFieldBuilderV3<
            com.google.protobuf.BoolValue, com.google.protobuf.BoolValue.Builder, com.google.protobuf.BoolValueOrBuilder> useStdHashBuilder_;
        /**
         * <pre>
         * Defaults to false, meaning that `xxHash &lt;https://github.com/Cyan4973/xxHash&gt;`_
         * is to hash hosts onto the ketama ring.
         * </pre>
         *
         * <code>.google.protobuf.BoolValue use_std_hash = 1;</code>
         */
        public boolean hasUseStdHash() {
          return useStdHashBuilder_ != null || useStdHash_ != null;
        }
        /**
         * <pre>
         * Defaults to false, meaning that `xxHash &lt;https://github.com/Cyan4973/xxHash&gt;`_
         * is to hash hosts onto the ketama ring.
         * </pre>
         *
         * <code>.google.protobuf.BoolValue use_std_hash = 1;</code>
         */
        public com.google.protobuf.BoolValue getUseStdHash() {
          if (useStdHashBuilder_ == null) {
            return useStdHash_ == null ? com.google.protobuf.BoolValue.getDefaultInstance() : useStdHash_;
          } else {
            return useStdHashBuilder_.getMessage();
          }
        }
        /**
         * <pre>
         * Defaults to false, meaning that `xxHash &lt;https://github.com/Cyan4973/xxHash&gt;`_
         * is to hash hosts onto the ketama ring.
         * </pre>
         *
         * <code>.google.protobuf.BoolValue use_std_hash = 1;</code>
         */
        public Builder setUseStdHash(com.google.protobuf.BoolValue value) {
          if (useStdHashBuilder_ == null) {
            if (value == null) {
              throw new NullPointerException();
            }
            useStdHash_ = value;
            onChanged();
          } else {
            useStdHashBuilder_.setMessage(value);
          }

          return this;
        }
        /**
         * <pre>
         * Defaults to false, meaning that `xxHash &lt;https://github.com/Cyan4973/xxHash&gt;`_
         * is to hash hosts onto the ketama ring.
         * </pre>
         *
         * <code>.google.protobuf.BoolValue use_std_hash = 1;</code>
         */
        public Builder setUseStdHash(
            com.google.protobuf.BoolValue.Builder builderForValue) {
          if (useStdHashBuilder_ == null) {
            useStdHash_ = builderForValue.build();
            onChanged();
          } else {
            useStdHashBuilder_.setMessage(builderForValue.build());
          }

          return this;
        }
        /**
         * <pre>
         * Defaults to false, meaning that `xxHash &lt;https://github.com/Cyan4973/xxHash&gt;`_
         * is to hash hosts onto the ketama ring.
         * </pre>
         *
         * <code>.google.protobuf.BoolValue use_std_hash = 1;</code>
         */
        public Builder mergeUseStdHash(com.google.protobuf.BoolValue value) {
          if (useStdHashBuilder_ == null) {
            if (useStdHash_ != null) {
              useStdHash_ =
                com.google.protobuf.BoolValue.newBuilder(useStdHash_).mergeFrom(value).buildPartial();
            } else {
              useStdHash_ = value;
            }
            onChanged();
          } else {
            useStdHashBuilder_.mergeFrom(value);
          }

          return this;
        }
        /**
         * <pre>
         * Defaults to false, meaning that `xxHash &lt;https://github.com/Cyan4973/xxHash&gt;`_
         * is to hash hosts onto the ketama ring.
         * </pre>
         *
         * <code>.google.protobuf.BoolValue use_std_hash = 1;</code>
         */
        public Builder clearUseStdHash() {
          if (useStdHashBuilder_ == null) {
            useStdHash_ = null;
            onChanged();
          } else {
            useStdHash_ = null;
            useStdHashBuilder_ = null;
          }

          return this;
        }
        /**
         * <pre>
         * Defaults to false, meaning that `xxHash &lt;https://github.com/Cyan4973/xxHash&gt;`_
         * is to hash hosts onto the ketama ring.
         * </pre>
         *
         * <code>.google.protobuf.BoolValue use_std_hash = 1;</code>
         */
        public com.google.protobuf.BoolValue.Builder getUseStdHashBuilder() {
          
          onChanged();
          return getUseStdHashFieldBuilder().getBuilder();
        }
        /**
         * <pre>
         * Defaults to false, meaning that `xxHash &lt;https://github.com/Cyan4973/xxHash&gt;`_
         * is to hash hosts onto the ketama ring.
         * </pre>
         *
         * <code>.google.protobuf.BoolValue use_std_hash = 1;</code>
         */
        public com.google.protobuf.BoolValueOrBuilder getUseStdHashOrBuilder() {
          if (useStdHashBuilder_ != null) {
            return useStdHashBuilder_.getMessageOrBuilder();
          } else {
            return useStdHash_ == null ?
                com.google.protobuf.BoolValue.getDefaultInstance() : useStdHash_;
          }
        }
        /**
         * <pre>
         * Defaults to false, meaning that `xxHash &lt;https://github.com/Cyan4973/xxHash&gt;`_
         * is to hash hosts onto the ketama ring.
         * </pre>
         *
         * <code>.google.protobuf.BoolValue use_std_hash = 1;</code>
         */
        private com.google.protobuf.SingleFieldBuilderV3<
            com.google.protobuf.BoolValue, com.google.protobuf.BoolValue.Builder, com.google.protobuf.BoolValueOrBuilder> 
            getUseStdHashFieldBuilder() {
          if (useStdHashBuilder_ == null) {
            useStdHashBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
                com.google.protobuf.BoolValue, com.google.protobuf.BoolValue.Builder, com.google.protobuf.BoolValueOrBuilder>(
                    getUseStdHash(),
                    getParentForChildren(),
                    isClean());
            useStdHash_ = null;
          }
          return useStdHashBuilder_;
        }
        public final Builder setUnknownFields(
            final com.google.protobuf.UnknownFieldSet unknownFields) {
          return super.setUnknownFieldsProto3(unknownFields);
        }

        public final Builder mergeUnknownFields(
            final com.google.protobuf.UnknownFieldSet unknownFields) {
          return super.mergeUnknownFields(unknownFields);
        }


        // @@protoc_insertion_point(builder_scope:envoy.api.v2.Cluster.RingHashLbConfig.DeprecatedV1)
      }

      // @@protoc_insertion_point(class_scope:envoy.api.v2.Cluster.RingHashLbConfig.DeprecatedV1)
      private static final io.grpc.xds.shaded.envoy.api.v2.Cluster.RingHashLbConfig.DeprecatedV1 DEFAULT_INSTANCE;
      static {
        DEFAULT_INSTANCE = new io.grpc.xds.shaded.envoy.api.v2.Cluster.RingHashLbConfig.DeprecatedV1();
      }

      public static io.grpc.xds.shaded.envoy.api.v2.Cluster.RingHashLbConfig.DeprecatedV1 getDefaultInstance() {
        return DEFAULT_INSTANCE;
      }

      private static final com.google.protobuf.Parser<DeprecatedV1>
          PARSER = new com.google.protobuf.AbstractParser<DeprecatedV1>() {
        public DeprecatedV1 parsePartialFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
          return new DeprecatedV1(input, extensionRegistry);
        }
      };

      public static com.google.protobuf.Parser<DeprecatedV1> parser() {
        return PARSER;
      }

      @java.lang.Override
      public com.google.protobuf.Parser<DeprecatedV1> getParserForType() {
        return PARSER;
      }

      public io.grpc.xds.shaded.envoy.api.v2.Cluster.RingHashLbConfig.DeprecatedV1 getDefaultInstanceForType() {
        return DEFAULT_INSTANCE;
      }

    }

    public static final int MINIMUM_RING_SIZE_FIELD_NUMBER = 1;
    private com.google.protobuf.UInt64Value minimumRingSize_;
    /**
     * <pre>
     * Minimum hash ring size, i.e. total virtual nodes. A larger size
     * will provide better request distribution since each host in the
     * cluster will have more virtual nodes. Defaults to 1024. In the case
     * that total number of hosts is greater than the minimum, each host will
     * be allocated a single virtual node. This field is limited to 8M to bound
     * resource use.
     * </pre>
     *
     * <code>.google.protobuf.UInt64Value minimum_ring_size = 1 [(.validate.rules) = { ... }</code>
     */
    public boolean hasMinimumRingSize() {
      return minimumRingSize_ != null;
    }
    /**
     * <pre>
     * Minimum hash ring size, i.e. total virtual nodes. A larger size
     * will provide better request distribution since each host in the
     * cluster will have more virtual nodes. Defaults to 1024. In the case
     * that total number of hosts is greater than the minimum, each host will
     * be allocated a single virtual node. This field is limited to 8M to bound
     * resource use.
     * </pre>
     *
     * <code>.google.protobuf.UInt64Value minimum_ring_size = 1 [(.validate.rules) = { ... }</code>
     */
    public com.google.protobuf.UInt64Value getMinimumRingSize() {
      return minimumRingSize_ == null ? com.google.protobuf.UInt64Value.getDefaultInstance() : minimumRingSize_;
    }
    /**
     * <pre>
     * Minimum hash ring size, i.e. total virtual nodes. A larger size
     * will provide better request distribution since each host in the
     * cluster will have more virtual nodes. Defaults to 1024. In the case
     * that total number of hosts is greater than the minimum, each host will
     * be allocated a single virtual node. This field is limited to 8M to bound
     * resource use.
     * </pre>
     *
     * <code>.google.protobuf.UInt64Value minimum_ring_size = 1 [(.validate.rules) = { ... }</code>
     */
    public com.google.protobuf.UInt64ValueOrBuilder getMinimumRingSizeOrBuilder() {
      return getMinimumRingSize();
    }

    public static final int DEPRECATED_V1_FIELD_NUMBER = 2;
    private io.grpc.xds.shaded.envoy.api.v2.Cluster.RingHashLbConfig.DeprecatedV1 deprecatedV1_;
    /**
     * <pre>
     * Deprecated settings from v1 config.
     * [#not-implemented-hide:] Hide from docs.
     * </pre>
     *
     * <code>.envoy.api.v2.Cluster.RingHashLbConfig.DeprecatedV1 deprecated_v1 = 2 [deprecated = true];</code>
     */
    @java.lang.Deprecated public boolean hasDeprecatedV1() {
      return deprecatedV1_ != null;
    }
    /**
     * <pre>
     * Deprecated settings from v1 config.
     * [#not-implemented-hide:] Hide from docs.
     * </pre>
     *
     * <code>.envoy.api.v2.Cluster.RingHashLbConfig.DeprecatedV1 deprecated_v1 = 2 [deprecated = true];</code>
     */
    @java.lang.Deprecated public io.grpc.xds.shaded.envoy.api.v2.Cluster.RingHashLbConfig.DeprecatedV1 getDeprecatedV1() {
      return deprecatedV1_ == null ? io.grpc.xds.shaded.envoy.api.v2.Cluster.RingHashLbConfig.DeprecatedV1.getDefaultInstance() : deprecatedV1_;
    }
    /**
     * <pre>
     * Deprecated settings from v1 config.
     * [#not-implemented-hide:] Hide from docs.
     * </pre>
     *
     * <code>.envoy.api.v2.Cluster.RingHashLbConfig.DeprecatedV1 deprecated_v1 = 2 [deprecated = true];</code>
     */
    @java.lang.Deprecated public io.grpc.xds.shaded.envoy.api.v2.Cluster.RingHashLbConfig.DeprecatedV1OrBuilder getDeprecatedV1OrBuilder() {
      return getDeprecatedV1();
    }

    private byte memoizedIsInitialized = -1;
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (minimumRingSize_ != null) {
        output.writeMessage(1, getMinimumRingSize());
      }
      if (deprecatedV1_ != null) {
        output.writeMessage(2, getDeprecatedV1());
      }
      unknownFields.writeTo(output);
    }

    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (minimumRingSize_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, getMinimumRingSize());
      }
      if (deprecatedV1_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, getDeprecatedV1());
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.grpc.xds.shaded.envoy.api.v2.Cluster.RingHashLbConfig)) {
        return super.equals(obj);
      }
      io.grpc.xds.shaded.envoy.api.v2.Cluster.RingHashLbConfig other = (io.grpc.xds.shaded.envoy.api.v2.Cluster.RingHashLbConfig) obj;

      boolean result = true;
      result = result && (hasMinimumRingSize() == other.hasMinimumRingSize());
      if (hasMinimumRingSize()) {
        result = result && getMinimumRingSize()
            .equals(other.getMinimumRingSize());
      }
      result = result && (hasDeprecatedV1() == other.hasDeprecatedV1());
      if (hasDeprecatedV1()) {
        result = result && getDeprecatedV1()
            .equals(other.getDeprecatedV1());
      }
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasMinimumRingSize()) {
        hash = (37 * hash) + MINIMUM_RING_SIZE_FIELD_NUMBER;
        hash = (53 * hash) + getMinimumRingSize().hashCode();
      }
      if (hasDeprecatedV1()) {
        hash = (37 * hash) + DEPRECATED_V1_FIELD_NUMBER;
        hash = (53 * hash) + getDeprecatedV1().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.grpc.xds.shaded.envoy.api.v2.Cluster.RingHashLbConfig parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.grpc.xds.shaded.envoy.api.v2.Cluster.RingHashLbConfig parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.grpc.xds.shaded.envoy.api.v2.Cluster.RingHashLbConfig parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.grpc.xds.shaded.envoy.api.v2.Cluster.RingHashLbConfig parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.grpc.xds.shaded.envoy.api.v2.Cluster.RingHashLbConfig parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.grpc.xds.shaded.envoy.api.v2.Cluster.RingHashLbConfig parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.grpc.xds.shaded.envoy.api.v2.Cluster.RingHashLbConfig parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.grpc.xds.shaded.envoy.api.v2.Cluster.RingHashLbConfig parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.grpc.xds.shaded.envoy.api.v2.Cluster.RingHashLbConfig parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static io.grpc.xds.shaded.envoy.api.v2.Cluster.RingHashLbConfig parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.grpc.xds.shaded.envoy.api.v2.Cluster.RingHashLbConfig parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.grpc.xds.shaded.envoy.api.v2.Cluster.RingHashLbConfig parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.grpc.xds.shaded.envoy.api.v2.Cluster.RingHashLbConfig prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Specific configuration for the :ref:`RingHash&lt;arch_overview_load_balancing_types_ring_hash&gt;`
     * load balancing policy.
     * </pre>
     *
     * Protobuf type {@code envoy.api.v2.Cluster.RingHashLbConfig}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:envoy.api.v2.Cluster.RingHashLbConfig)
        io.grpc.xds.shaded.envoy.api.v2.Cluster.RingHashLbConfigOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.grpc.xds.shaded.envoy.api.v2.Cds.internal_static_envoy_api_v2_Cluster_RingHashLbConfig_descriptor;
      }

      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.grpc.xds.shaded.envoy.api.v2.Cds.internal_static_envoy_api_v2_Cluster_RingHashLbConfig_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.grpc.xds.shaded.envoy.api.v2.Cluster.RingHashLbConfig.class, io.grpc.xds.shaded.envoy.api.v2.Cluster.RingHashLbConfig.Builder.class);
      }

      // Construct using io.grpc.xds.shaded.envoy.api.v2.Cluster.RingHashLbConfig.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      public Builder clear() {
        super.clear();
        if (minimumRingSizeBuilder_ == null) {
          minimumRingSize_ = null;
        } else {
          minimumRingSize_ = null;
          minimumRingSizeBuilder_ = null;
        }
        if (deprecatedV1Builder_ == null) {
          deprecatedV1_ = null;
        } else {
          deprecatedV1_ = null;
          deprecatedV1Builder_ = null;
        }
        return this;
      }

      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.grpc.xds.shaded.envoy.api.v2.Cds.internal_static_envoy_api_v2_Cluster_RingHashLbConfig_descriptor;
      }

      public io.grpc.xds.shaded.envoy.api.v2.Cluster.RingHashLbConfig getDefaultInstanceForType() {
        return io.grpc.xds.shaded.envoy.api.v2.Cluster.RingHashLbConfig.getDefaultInstance();
      }

      public io.grpc.xds.shaded.envoy.api.v2.Cluster.RingHashLbConfig build() {
        io.grpc.xds.shaded.envoy.api.v2.Cluster.RingHashLbConfig result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      public io.grpc.xds.shaded.envoy.api.v2.Cluster.RingHashLbConfig buildPartial() {
        io.grpc.xds.shaded.envoy.api.v2.Cluster.RingHashLbConfig result = new io.grpc.xds.shaded.envoy.api.v2.Cluster.RingHashLbConfig(this);
        if (minimumRingSizeBuilder_ == null) {
          result.minimumRingSize_ = minimumRingSize_;
        } else {
          result.minimumRingSize_ = minimumRingSizeBuilder_.build();
        }
        if (deprecatedV1Builder_ == null) {
          result.deprecatedV1_ = deprecatedV1_;
        } else {
          result.deprecatedV1_ = deprecatedV1Builder_.build();
        }
        onBuilt();
        return result;
      }

      public Builder clone() {
        return (Builder) super.clone();
      }
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.grpc.xds.shaded.envoy.api.v2.Cluster.RingHashLbConfig) {
          return mergeFrom((io.grpc.xds.shaded.envoy.api.v2.Cluster.RingHashLbConfig)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.grpc.xds.shaded.envoy.api.v2.Cluster.RingHashLbConfig other) {
        if (other == io.grpc.xds.shaded.envoy.api.v2.Cluster.RingHashLbConfig.getDefaultInstance()) return this;
        if (other.hasMinimumRingSize()) {
          mergeMinimumRingSize(other.getMinimumRingSize());
        }
        if (other.hasDeprecatedV1()) {
          mergeDeprecatedV1(other.getDeprecatedV1());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      public final boolean isInitialized() {
        return true;
      }

      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.grpc.xds.shaded.envoy.api.v2.Cluster.RingHashLbConfig parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (io.grpc.xds.shaded.envoy.api.v2.Cluster.RingHashLbConfig) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }

      private com.google.protobuf.UInt64Value minimumRingSize_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          com.google.protobuf.UInt64Value, com.google.protobuf.UInt64Value.Builder, com.google.protobuf.UInt64ValueOrBuilder> minimumRingSizeBuilder_;
      /**
       * <pre>
       * Minimum hash ring size, i.e. total virtual nodes. A larger size
       * will provide better request distribution since each host in the
       * cluster will have more virtual nodes. Defaults to 1024. In the case
       * that total number of hosts is greater than the minimum, each host will
       * be allocated a single virtual node. This field is limited to 8M to bound
       * resource use.
       * </pre>
       *
       * <code>.google.protobuf.UInt64Value minimum_ring_size = 1 [(.validate.rules) = { ... }</code>
       */
      public boolean hasMinimumRingSize() {
        return minimumRingSizeBuilder_ != null || minimumRingSize_ != null;
      }
      /**
       * <pre>
       * Minimum hash ring size, i.e. total virtual nodes. A larger size
       * will provide better request distribution since each host in the
       * cluster will have more virtual nodes. Defaults to 1024. In the case
       * that total number of hosts is greater than the minimum, each host will
       * be allocated a single virtual node. This field is limited to 8M to bound
       * resource use.
       * </pre>
       *
       * <code>.google.protobuf.UInt64Value minimum_ring_size = 1 [(.validate.rules) = { ... }</code>
       */
      public com.google.protobuf.UInt64Value getMinimumRingSize() {
        if (minimumRingSizeBuilder_ == null) {
          return minimumRingSize_ == null ? com.google.protobuf.UInt64Value.getDefaultInstance() : minimumRingSize_;
        } else {
          return minimumRingSizeBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Minimum hash ring size, i.e. total virtual nodes. A larger size
       * will provide better request distribution since each host in the
       * cluster will have more virtual nodes. Defaults to 1024. In the case
       * that total number of hosts is greater than the minimum, each host will
       * be allocated a single virtual node. This field is limited to 8M to bound
       * resource use.
       * </pre>
       *
       * <code>.google.protobuf.UInt64Value minimum_ring_size = 1 [(.validate.rules) = { ... }</code>
       */
      public Builder setMinimumRingSize(com.google.protobuf.UInt64Value value) {
        if (minimumRingSizeBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          minimumRingSize_ = value;
          onChanged();
        } else {
          minimumRingSizeBuilder_.setMessage(value);
        }

        return this;
      }
      /**
       * <pre>
       * Minimum hash ring size, i.e. total virtual nodes. A larger size
       * will provide better request distribution since each host in the
       * cluster will have more virtual nodes. Defaults to 1024. In the case
       * that total number of hosts is greater than the minimum, each host will
       * be allocated a single virtual node. This field is limited to 8M to bound
       * resource use.
       * </pre>
       *
       * <code>.google.protobuf.UInt64Value minimum_ring_size = 1 [(.validate.rules) = { ... }</code>
       */
      public Builder setMinimumRingSize(
          com.google.protobuf.UInt64Value.Builder builderForValue) {
        if (minimumRingSizeBuilder_ == null) {
          minimumRingSize_ = builderForValue.build();
          onChanged();
        } else {
          minimumRingSizeBuilder_.setMessage(builderForValue.build());
        }

        return this;
      }
      /**
       * <pre>
       * Minimum hash ring size, i.e. total virtual nodes. A larger size
       * will provide better request distribution since each host in the
       * cluster will have more virtual nodes. Defaults to 1024. In the case
       * that total number of hosts is greater than the minimum, each host will
       * be allocated a single virtual node. This field is limited to 8M to bound
       * resource use.
       * </pre>
       *
       * <code>.google.protobuf.UInt64Value minimum_ring_size = 1 [(.validate.rules) = { ... }</code>
       */
      public Builder mergeMinimumRingSize(com.google.protobuf.UInt64Value value) {
        if (minimumRingSizeBuilder_ == null) {
          if (minimumRingSize_ != null) {
            minimumRingSize_ =
              com.google.protobuf.UInt64Value.newBuilder(minimumRingSize_).mergeFrom(value).buildPartial();
          } else {
            minimumRingSize_ = value;
          }
          onChanged();
        } else {
          minimumRingSizeBuilder_.mergeFrom(value);
        }

        return this;
      }
      /**
       * <pre>
       * Minimum hash ring size, i.e. total virtual nodes. A larger size
       * will provide better request distribution since each host in the
       * cluster will have more virtual nodes. Defaults to 1024. In the case
       * that total number of hosts is greater than the minimum, each host will
       * be allocated a single virtual node. This field is limited to 8M to bound
       * resource use.
       * </pre>
       *
       * <code>.google.protobuf.UInt64Value minimum_ring_size = 1 [(.validate.rules) = { ... }</code>
       */
      public Builder clearMinimumRingSize() {
        if (minimumRingSizeBuilder_ == null) {
          minimumRingSize_ = null;
          onChanged();
        } else {
          minimumRingSize_ = null;
          minimumRingSizeBuilder_ = null;
        }

        return this;
      }
      /**
       * <pre>
       * Minimum hash ring size, i.e. total virtual nodes. A larger size
       * will provide better request distribution since each host in the
       * cluster will have more virtual nodes. Defaults to 1024. In the case
       * that total number of hosts is greater than the minimum, each host will
       * be allocated a single virtual node. This field is limited to 8M to bound
       * resource use.
       * </pre>
       *
       * <code>.google.protobuf.UInt64Value minimum_ring_size = 1 [(.validate.rules) = { ... }</code>
       */
      public com.google.protobuf.UInt64Value.Builder getMinimumRingSizeBuilder() {
        
        onChanged();
        return getMinimumRingSizeFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Minimum hash ring size, i.e. total virtual nodes. A larger size
       * will provide better request distribution since each host in the
       * cluster will have more virtual nodes. Defaults to 1024. In the case
       * that total number of hosts is greater than the minimum, each host will
       * be allocated a single virtual node. This field is limited to 8M to bound
       * resource use.
       * </pre>
       *
       * <code>.google.protobuf.UInt64Value minimum_ring_size = 1 [(.validate.rules) = { ... }</code>
       */
      public com.google.protobuf.UInt64ValueOrBuilder getMinimumRingSizeOrBuilder() {
        if (minimumRingSizeBuilder_ != null) {
          return minimumRingSizeBuilder_.getMessageOrBuilder();
        } else {
          return minimumRingSize_ == null ?
              com.google.protobuf.UInt64Value.getDefaultInstance() : minimumRingSize_;
        }
      }
      /**
       * <pre>
       * Minimum hash ring size, i.e. total virtual nodes. A larger size
       * will provide better request distribution since each host in the
       * cluster will have more virtual nodes. Defaults to 1024. In the case
       * that total number of hosts is greater than the minimum, each host will
       * be allocated a single virtual node. This field is limited to 8M to bound
       * resource use.
       * </pre>
       *
       * <code>.google.protobuf.UInt64Value minimum_ring_size = 1 [(.validate.rules) = { ... }</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          com.google.protobuf.UInt64Value, com.google.protobuf.UInt64Value.Builder, com.google.protobuf.UInt64ValueOrBuilder> 
          getMinimumRingSizeFieldBuilder() {
        if (minimumRingSizeBuilder_ == null) {
          minimumRingSizeBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              com.google.protobuf.UInt64Value, com.google.protobuf.UInt64Value.Builder, com.google.protobuf.UInt64ValueOrBuilder>(
                  getMinimumRingSize(),
                  getParentForChildren(),
                  isClean());
          minimumRingSize_ = null;
        }
        return minimumRingSizeBuilder_;
      }

      private io.grpc.xds.shaded.envoy.api.v2.Cluster.RingHashLbConfig.DeprecatedV1 deprecatedV1_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          io.grpc.xds.shaded.envoy.api.v2.Cluster.RingHashLbConfig.DeprecatedV1, io.grpc.xds.shaded.envoy.api.v2.Cluster.RingHashLbConfig.DeprecatedV1.Builder, io.grpc.xds.shaded.envoy.api.v2.Cluster.RingHashLbConfig.DeprecatedV1OrBuilder> deprecatedV1Builder_;
      /**
       * <pre>
       * Deprecated settings from v1 config.
       * [#not-implemented-hide:] Hide from docs.
       * </pre>
       *
       * <code>.envoy.api.v2.Cluster.RingHashLbConfig.DeprecatedV1 deprecated_v1 = 2 [deprecated = true];</code>
       */
      @java.lang.Deprecated public boolean hasDeprecatedV1() {
        return deprecatedV1Builder_ != null || deprecatedV1_ != null;
      }
      /**
       * <pre>
       * Deprecated settings from v1 config.
       * [#not-implemented-hide:] Hide from docs.
       * </pre>
       *
       * <code>.envoy.api.v2.Cluster.RingHashLbConfig.DeprecatedV1 deprecated_v1 = 2 [deprecated = true];</code>
       */
      @java.lang.Deprecated public io.grpc.xds.shaded.envoy.api.v2.Cluster.RingHashLbConfig.DeprecatedV1 getDeprecatedV1() {
        if (deprecatedV1Builder_ == null) {
          return deprecatedV1_ == null ? io.grpc.xds.shaded.envoy.api.v2.Cluster.RingHashLbConfig.DeprecatedV1.getDefaultInstance() : deprecatedV1_;
        } else {
          return deprecatedV1Builder_.getMessage();
        }
      }
      /**
       * <pre>
       * Deprecated settings from v1 config.
       * [#not-implemented-hide:] Hide from docs.
       * </pre>
       *
       * <code>.envoy.api.v2.Cluster.RingHashLbConfig.DeprecatedV1 deprecated_v1 = 2 [deprecated = true];</code>
       */
      @java.lang.Deprecated public Builder setDeprecatedV1(io.grpc.xds.shaded.envoy.api.v2.Cluster.RingHashLbConfig.DeprecatedV1 value) {
        if (deprecatedV1Builder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          deprecatedV1_ = value;
          onChanged();
        } else {
          deprecatedV1Builder_.setMessage(value);
        }

        return this;
      }
      /**
       * <pre>
       * Deprecated settings from v1 config.
       * [#not-implemented-hide:] Hide from docs.
       * </pre>
       *
       * <code>.envoy.api.v2.Cluster.RingHashLbConfig.DeprecatedV1 deprecated_v1 = 2 [deprecated = true];</code>
       */
      @java.lang.Deprecated public Builder setDeprecatedV1(
          io.grpc.xds.shaded.envoy.api.v2.Cluster.RingHashLbConfig.DeprecatedV1.Builder builderForValue) {
        if (deprecatedV1Builder_ == null) {
          deprecatedV1_ = builderForValue.build();
          onChanged();
        } else {
          deprecatedV1Builder_.setMessage(builderForValue.build());
        }

        return this;
      }
      /**
       * <pre>
       * Deprecated settings from v1 config.
       * [#not-implemented-hide:] Hide from docs.
       * </pre>
       *
       * <code>.envoy.api.v2.Cluster.RingHashLbConfig.DeprecatedV1 deprecated_v1 = 2 [deprecated = true];</code>
       */
      @java.lang.Deprecated public Builder mergeDeprecatedV1(io.grpc.xds.shaded.envoy.api.v2.Cluster.RingHashLbConfig.DeprecatedV1 value) {
        if (deprecatedV1Builder_ == null) {
          if (deprecatedV1_ != null) {
            deprecatedV1_ =
              io.grpc.xds.shaded.envoy.api.v2.Cluster.RingHashLbConfig.DeprecatedV1.newBuilder(deprecatedV1_).mergeFrom(value).buildPartial();
          } else {
            deprecatedV1_ = value;
          }
          onChanged();
        } else {
          deprecatedV1Builder_.mergeFrom(value);
        }

        return this;
      }
      /**
       * <pre>
       * Deprecated settings from v1 config.
       * [#not-implemented-hide:] Hide from docs.
       * </pre>
       *
       * <code>.envoy.api.v2.Cluster.RingHashLbConfig.DeprecatedV1 deprecated_v1 = 2 [deprecated = true];</code>
       */
      @java.lang.Deprecated public Builder clearDeprecatedV1() {
        if (deprecatedV1Builder_ == null) {
          deprecatedV1_ = null;
          onChanged();
        } else {
          deprecatedV1_ = null;
          deprecatedV1Builder_ = null;
        }

        return this;
      }
      /**
       * <pre>
       * Deprecated settings from v1 config.
       * [#not-implemented-hide:] Hide from docs.
       * </pre>
       *
       * <code>.envoy.api.v2.Cluster.RingHashLbConfig.DeprecatedV1 deprecated_v1 = 2 [deprecated = true];</code>
       */
      @java.lang.Deprecated public io.grpc.xds.shaded.envoy.api.v2.Cluster.RingHashLbConfig.DeprecatedV1.Builder getDeprecatedV1Builder() {
        
        onChanged();
        return getDeprecatedV1FieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Deprecated settings from v1 config.
       * [#not-implemented-hide:] Hide from docs.
       * </pre>
       *
       * <code>.envoy.api.v2.Cluster.RingHashLbConfig.DeprecatedV1 deprecated_v1 = 2 [deprecated = true];</code>
       */
      @java.lang.Deprecated public io.grpc.xds.shaded.envoy.api.v2.Cluster.RingHashLbConfig.DeprecatedV1OrBuilder getDeprecatedV1OrBuilder() {
        if (deprecatedV1Builder_ != null) {
          return deprecatedV1Builder_.getMessageOrBuilder();
        } else {
          return deprecatedV1_ == null ?
              io.grpc.xds.shaded.envoy.api.v2.Cluster.RingHashLbConfig.DeprecatedV1.getDefaultInstance() : deprecatedV1_;
        }
      }
      /**
       * <pre>
       * Deprecated settings from v1 config.
       * [#not-implemented-hide:] Hide from docs.
       * </pre>
       *
       * <code>.envoy.api.v2.Cluster.RingHashLbConfig.DeprecatedV1 deprecated_v1 = 2 [deprecated = true];</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          io.grpc.xds.shaded.envoy.api.v2.Cluster.RingHashLbConfig.DeprecatedV1, io.grpc.xds.shaded.envoy.api.v2.Cluster.RingHashLbConfig.DeprecatedV1.Builder, io.grpc.xds.shaded.envoy.api.v2.Cluster.RingHashLbConfig.DeprecatedV1OrBuilder> 
          getDeprecatedV1FieldBuilder() {
        if (deprecatedV1Builder_ == null) {
          deprecatedV1Builder_ = new com.google.protobuf.SingleFieldBuilderV3<
              io.grpc.xds.shaded.envoy.api.v2.Cluster.RingHashLbConfig.DeprecatedV1, io.grpc.xds.shaded.envoy.api.v2.Cluster.RingHashLbConfig.DeprecatedV1.Builder, io.grpc.xds.shaded.envoy.api.v2.Cluster.RingHashLbConfig.DeprecatedV1OrBuilder>(
                  getDeprecatedV1(),
                  getParentForChildren(),
                  isClean());
          deprecatedV1_ = null;
        }
        return deprecatedV1Builder_;
      }
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFieldsProto3(unknownFields);
      }

      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:envoy.api.v2.Cluster.RingHashLbConfig)
    }

    // @@protoc_insertion_point(class_scope:envoy.api.v2.Cluster.RingHashLbConfig)
    private static final io.grpc.xds.shaded.envoy.api.v2.Cluster.RingHashLbConfig DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.grpc.xds.shaded.envoy.api.v2.Cluster.RingHashLbConfig();
    }

    public static io.grpc.xds.shaded.envoy.api.v2.Cluster.RingHashLbConfig getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<RingHashLbConfig>
        PARSER = new com.google.protobuf.AbstractParser<RingHashLbConfig>() {
      public RingHashLbConfig parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new RingHashLbConfig(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<RingHashLbConfig> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<RingHashLbConfig> getParserForType() {
      return PARSER;
    }

    public io.grpc.xds.shaded.envoy.api.v2.Cluster.RingHashLbConfig getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface OriginalDstLbConfigOrBuilder extends
      // @@protoc_insertion_point(interface_extends:envoy.api.v2.Cluster.OriginalDstLbConfig)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * When true, :ref:`x-envoy-orignal-dst-host
     * &lt;config_http_conn_man_headers_x-envoy-original-dst-host&gt;` can be used to override destination
     * address.
     * .. attention::
     *   This header isn't sanitized by default, so enabling this feature allows HTTP clients to
     *   route traffic to arbitrary hosts and/or ports, which may have serious security
     *   consequences.
     * </pre>
     *
     * <code>bool use_http_header = 1;</code>
     */
    boolean getUseHttpHeader();
  }
  /**
   * <pre>
   * Specific configuration for the
   * :ref:`Original Destination &lt;arch_overview_load_balancing_types_original_destination&gt;`
   * load balancing policy.
   * </pre>
   *
   * Protobuf type {@code envoy.api.v2.Cluster.OriginalDstLbConfig}
   */
  public  static final class OriginalDstLbConfig extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:envoy.api.v2.Cluster.OriginalDstLbConfig)
      OriginalDstLbConfigOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use OriginalDstLbConfig.newBuilder() to construct.
    private OriginalDstLbConfig(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private OriginalDstLbConfig() {
      useHttpHeader_ = false;
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private OriginalDstLbConfig(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!parseUnknownFieldProto3(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
            case 8: {

              useHttpHeader_ = input.readBool();
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.grpc.xds.shaded.envoy.api.v2.Cds.internal_static_envoy_api_v2_Cluster_OriginalDstLbConfig_descriptor;
    }

    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.grpc.xds.shaded.envoy.api.v2.Cds.internal_static_envoy_api_v2_Cluster_OriginalDstLbConfig_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.grpc.xds.shaded.envoy.api.v2.Cluster.OriginalDstLbConfig.class, io.grpc.xds.shaded.envoy.api.v2.Cluster.OriginalDstLbConfig.Builder.class);
    }

    public static final int USE_HTTP_HEADER_FIELD_NUMBER = 1;
    private boolean useHttpHeader_;
    /**
     * <pre>
     * When true, :ref:`x-envoy-orignal-dst-host
     * &lt;config_http_conn_man_headers_x-envoy-original-dst-host&gt;` can be used to override destination
     * address.
     * .. attention::
     *   This header isn't sanitized by default, so enabling this feature allows HTTP clients to
     *   route traffic to arbitrary hosts and/or ports, which may have serious security
     *   consequences.
     * </pre>
     *
     * <code>bool use_http_header = 1;</code>
     */
    public boolean getUseHttpHeader() {
      return useHttpHeader_;
    }

    private byte memoizedIsInitialized = -1;
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (useHttpHeader_ != false) {
        output.writeBool(1, useHttpHeader_);
      }
      unknownFields.writeTo(output);
    }

    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (useHttpHeader_ != false) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(1, useHttpHeader_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.grpc.xds.shaded.envoy.api.v2.Cluster.OriginalDstLbConfig)) {
        return super.equals(obj);
      }
      io.grpc.xds.shaded.envoy.api.v2.Cluster.OriginalDstLbConfig other = (io.grpc.xds.shaded.envoy.api.v2.Cluster.OriginalDstLbConfig) obj;

      boolean result = true;
      result = result && (getUseHttpHeader()
          == other.getUseHttpHeader());
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + USE_HTTP_HEADER_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
          getUseHttpHeader());
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.grpc.xds.shaded.envoy.api.v2.Cluster.OriginalDstLbConfig parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.grpc.xds.shaded.envoy.api.v2.Cluster.OriginalDstLbConfig parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.grpc.xds.shaded.envoy.api.v2.Cluster.OriginalDstLbConfig parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.grpc.xds.shaded.envoy.api.v2.Cluster.OriginalDstLbConfig parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.grpc.xds.shaded.envoy.api.v2.Cluster.OriginalDstLbConfig parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.grpc.xds.shaded.envoy.api.v2.Cluster.OriginalDstLbConfig parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.grpc.xds.shaded.envoy.api.v2.Cluster.OriginalDstLbConfig parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.grpc.xds.shaded.envoy.api.v2.Cluster.OriginalDstLbConfig parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.grpc.xds.shaded.envoy.api.v2.Cluster.OriginalDstLbConfig parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static io.grpc.xds.shaded.envoy.api.v2.Cluster.OriginalDstLbConfig parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.grpc.xds.shaded.envoy.api.v2.Cluster.OriginalDstLbConfig parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.grpc.xds.shaded.envoy.api.v2.Cluster.OriginalDstLbConfig parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.grpc.xds.shaded.envoy.api.v2.Cluster.OriginalDstLbConfig prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Specific configuration for the
     * :ref:`Original Destination &lt;arch_overview_load_balancing_types_original_destination&gt;`
     * load balancing policy.
     * </pre>
     *
     * Protobuf type {@code envoy.api.v2.Cluster.OriginalDstLbConfig}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:envoy.api.v2.Cluster.OriginalDstLbConfig)
        io.grpc.xds.shaded.envoy.api.v2.Cluster.OriginalDstLbConfigOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.grpc.xds.shaded.envoy.api.v2.Cds.internal_static_envoy_api_v2_Cluster_OriginalDstLbConfig_descriptor;
      }

      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.grpc.xds.shaded.envoy.api.v2.Cds.internal_static_envoy_api_v2_Cluster_OriginalDstLbConfig_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.grpc.xds.shaded.envoy.api.v2.Cluster.OriginalDstLbConfig.class, io.grpc.xds.shaded.envoy.api.v2.Cluster.OriginalDstLbConfig.Builder.class);
      }

      // Construct using io.grpc.xds.shaded.envoy.api.v2.Cluster.OriginalDstLbConfig.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      public Builder clear() {
        super.clear();
        useHttpHeader_ = false;

        return this;
      }

      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.grpc.xds.shaded.envoy.api.v2.Cds.internal_static_envoy_api_v2_Cluster_OriginalDstLbConfig_descriptor;
      }

      public io.grpc.xds.shaded.envoy.api.v2.Cluster.OriginalDstLbConfig getDefaultInstanceForType() {
        return io.grpc.xds.shaded.envoy.api.v2.Cluster.OriginalDstLbConfig.getDefaultInstance();
      }

      public io.grpc.xds.shaded.envoy.api.v2.Cluster.OriginalDstLbConfig build() {
        io.grpc.xds.shaded.envoy.api.v2.Cluster.OriginalDstLbConfig result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      public io.grpc.xds.shaded.envoy.api.v2.Cluster.OriginalDstLbConfig buildPartial() {
        io.grpc.xds.shaded.envoy.api.v2.Cluster.OriginalDstLbConfig result = new io.grpc.xds.shaded.envoy.api.v2.Cluster.OriginalDstLbConfig(this);
        result.useHttpHeader_ = useHttpHeader_;
        onBuilt();
        return result;
      }

      public Builder clone() {
        return (Builder) super.clone();
      }
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.grpc.xds.shaded.envoy.api.v2.Cluster.OriginalDstLbConfig) {
          return mergeFrom((io.grpc.xds.shaded.envoy.api.v2.Cluster.OriginalDstLbConfig)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.grpc.xds.shaded.envoy.api.v2.Cluster.OriginalDstLbConfig other) {
        if (other == io.grpc.xds.shaded.envoy.api.v2.Cluster.OriginalDstLbConfig.getDefaultInstance()) return this;
        if (other.getUseHttpHeader() != false) {
          setUseHttpHeader(other.getUseHttpHeader());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      public final boolean isInitialized() {
        return true;
      }

      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.grpc.xds.shaded.envoy.api.v2.Cluster.OriginalDstLbConfig parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (io.grpc.xds.shaded.envoy.api.v2.Cluster.OriginalDstLbConfig) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }

      private boolean useHttpHeader_ ;
      /**
       * <pre>
       * When true, :ref:`x-envoy-orignal-dst-host
       * &lt;config_http_conn_man_headers_x-envoy-original-dst-host&gt;` can be used to override destination
       * address.
       * .. attention::
       *   This header isn't sanitized by default, so enabling this feature allows HTTP clients to
       *   route traffic to arbitrary hosts and/or ports, which may have serious security
       *   consequences.
       * </pre>
       *
       * <code>bool use_http_header = 1;</code>
       */
      public boolean getUseHttpHeader() {
        return useHttpHeader_;
      }
      /**
       * <pre>
       * When true, :ref:`x-envoy-orignal-dst-host
       * &lt;config_http_conn_man_headers_x-envoy-original-dst-host&gt;` can be used to override destination
       * address.
       * .. attention::
       *   This header isn't sanitized by default, so enabling this feature allows HTTP clients to
       *   route traffic to arbitrary hosts and/or ports, which may have serious security
       *   consequences.
       * </pre>
       *
       * <code>bool use_http_header = 1;</code>
       */
      public Builder setUseHttpHeader(boolean value) {
        
        useHttpHeader_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * When true, :ref:`x-envoy-orignal-dst-host
       * &lt;config_http_conn_man_headers_x-envoy-original-dst-host&gt;` can be used to override destination
       * address.
       * .. attention::
       *   This header isn't sanitized by default, so enabling this feature allows HTTP clients to
       *   route traffic to arbitrary hosts and/or ports, which may have serious security
       *   consequences.
       * </pre>
       *
       * <code>bool use_http_header = 1;</code>
       */
      public Builder clearUseHttpHeader() {
        
        useHttpHeader_ = false;
        onChanged();
        return this;
      }
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFieldsProto3(unknownFields);
      }

      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:envoy.api.v2.Cluster.OriginalDstLbConfig)
    }

    // @@protoc_insertion_point(class_scope:envoy.api.v2.Cluster.OriginalDstLbConfig)
    private static final io.grpc.xds.shaded.envoy.api.v2.Cluster.OriginalDstLbConfig DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.grpc.xds.shaded.envoy.api.v2.Cluster.OriginalDstLbConfig();
    }

    public static io.grpc.xds.shaded.envoy.api.v2.Cluster.OriginalDstLbConfig getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<OriginalDstLbConfig>
        PARSER = new com.google.protobuf.AbstractParser<OriginalDstLbConfig>() {
      public OriginalDstLbConfig parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new OriginalDstLbConfig(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<OriginalDstLbConfig> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<OriginalDstLbConfig> getParserForType() {
      return PARSER;
    }

    public io.grpc.xds.shaded.envoy.api.v2.Cluster.OriginalDstLbConfig getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface CommonLbConfigOrBuilder extends
      // @@protoc_insertion_point(interface_extends:envoy.api.v2.Cluster.CommonLbConfig)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Configures the :ref:`healthy panic threshold &lt;arch_overview_load_balancing_panic_threshold&gt;`.
     * If not specified, the default is 50%.
     * .. note::
     *   The specified percent will be truncated to the nearest 1%.
     * </pre>
     *
     * <code>.envoy.type.Percent healthy_panic_threshold = 1;</code>
     */
    boolean hasHealthyPanicThreshold();
    /**
     * <pre>
     * Configures the :ref:`healthy panic threshold &lt;arch_overview_load_balancing_panic_threshold&gt;`.
     * If not specified, the default is 50%.
     * .. note::
     *   The specified percent will be truncated to the nearest 1%.
     * </pre>
     *
     * <code>.envoy.type.Percent healthy_panic_threshold = 1;</code>
     */
    io.grpc.xds.shaded.envoy.type.Percent getHealthyPanicThreshold();
    /**
     * <pre>
     * Configures the :ref:`healthy panic threshold &lt;arch_overview_load_balancing_panic_threshold&gt;`.
     * If not specified, the default is 50%.
     * .. note::
     *   The specified percent will be truncated to the nearest 1%.
     * </pre>
     *
     * <code>.envoy.type.Percent healthy_panic_threshold = 1;</code>
     */
    io.grpc.xds.shaded.envoy.type.PercentOrBuilder getHealthyPanicThresholdOrBuilder();

    /**
     * <code>.envoy.api.v2.Cluster.CommonLbConfig.ZoneAwareLbConfig zone_aware_lb_config = 2;</code>
     */
    boolean hasZoneAwareLbConfig();
    /**
     * <code>.envoy.api.v2.Cluster.CommonLbConfig.ZoneAwareLbConfig zone_aware_lb_config = 2;</code>
     */
    io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.ZoneAwareLbConfig getZoneAwareLbConfig();
    /**
     * <code>.envoy.api.v2.Cluster.CommonLbConfig.ZoneAwareLbConfig zone_aware_lb_config = 2;</code>
     */
    io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.ZoneAwareLbConfigOrBuilder getZoneAwareLbConfigOrBuilder();

    /**
     * <code>.envoy.api.v2.Cluster.CommonLbConfig.LocalityWeightedLbConfig locality_weighted_lb_config = 3;</code>
     */
    boolean hasLocalityWeightedLbConfig();
    /**
     * <code>.envoy.api.v2.Cluster.CommonLbConfig.LocalityWeightedLbConfig locality_weighted_lb_config = 3;</code>
     */
    io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.LocalityWeightedLbConfig getLocalityWeightedLbConfig();
    /**
     * <code>.envoy.api.v2.Cluster.CommonLbConfig.LocalityWeightedLbConfig locality_weighted_lb_config = 3;</code>
     */
    io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.LocalityWeightedLbConfigOrBuilder getLocalityWeightedLbConfigOrBuilder();

    /**
     * <pre>
     * If set, all health check/weight/metadata updates that happen within this duration will be
     * merged and delivered in one shot when the duration expires. The start of the duration is when
     * the first update happens. This is useful for big clusters, with potentially noisy deploys
     * that might trigger excessive CPU usage due to a constant stream of healthcheck state changes
     * or metadata updates. The first set of updates to be seen apply immediately (e.g.: a new
     * cluster).
     * If this is not set, we default to a merge window of 1000ms. To disable it, set the merge
     * window to 0.
     * Note: merging does not apply to cluster membership changes (e.g.: adds/removes); this is
     * because merging those updates isn't currently safe. See
     * https://github.com/envoyproxy/envoy/pull/3941.
     * </pre>
     *
     * <code>.google.protobuf.Duration update_merge_window = 4;</code>
     */
    boolean hasUpdateMergeWindow();
    /**
     * <pre>
     * If set, all health check/weight/metadata updates that happen within this duration will be
     * merged and delivered in one shot when the duration expires. The start of the duration is when
     * the first update happens. This is useful for big clusters, with potentially noisy deploys
     * that might trigger excessive CPU usage due to a constant stream of healthcheck state changes
     * or metadata updates. The first set of updates to be seen apply immediately (e.g.: a new
     * cluster).
     * If this is not set, we default to a merge window of 1000ms. To disable it, set the merge
     * window to 0.
     * Note: merging does not apply to cluster membership changes (e.g.: adds/removes); this is
     * because merging those updates isn't currently safe. See
     * https://github.com/envoyproxy/envoy/pull/3941.
     * </pre>
     *
     * <code>.google.protobuf.Duration update_merge_window = 4;</code>
     */
    com.google.protobuf.Duration getUpdateMergeWindow();
    /**
     * <pre>
     * If set, all health check/weight/metadata updates that happen within this duration will be
     * merged and delivered in one shot when the duration expires. The start of the duration is when
     * the first update happens. This is useful for big clusters, with potentially noisy deploys
     * that might trigger excessive CPU usage due to a constant stream of healthcheck state changes
     * or metadata updates. The first set of updates to be seen apply immediately (e.g.: a new
     * cluster).
     * If this is not set, we default to a merge window of 1000ms. To disable it, set the merge
     * window to 0.
     * Note: merging does not apply to cluster membership changes (e.g.: adds/removes); this is
     * because merging those updates isn't currently safe. See
     * https://github.com/envoyproxy/envoy/pull/3941.
     * </pre>
     *
     * <code>.google.protobuf.Duration update_merge_window = 4;</code>
     */
    com.google.protobuf.DurationOrBuilder getUpdateMergeWindowOrBuilder();

    public io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.LocalityConfigSpecifierCase getLocalityConfigSpecifierCase();
  }
  /**
   * <pre>
   * Common configuration for all load balancer implementations.
   * </pre>
   *
   * Protobuf type {@code envoy.api.v2.Cluster.CommonLbConfig}
   */
  public  static final class CommonLbConfig extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:envoy.api.v2.Cluster.CommonLbConfig)
      CommonLbConfigOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use CommonLbConfig.newBuilder() to construct.
    private CommonLbConfig(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private CommonLbConfig() {
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private CommonLbConfig(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!parseUnknownFieldProto3(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
            case 10: {
              io.grpc.xds.shaded.envoy.type.Percent.Builder subBuilder = null;
              if (healthyPanicThreshold_ != null) {
                subBuilder = healthyPanicThreshold_.toBuilder();
              }
              healthyPanicThreshold_ = input.readMessage(io.grpc.xds.shaded.envoy.type.Percent.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(healthyPanicThreshold_);
                healthyPanicThreshold_ = subBuilder.buildPartial();
              }

              break;
            }
            case 18: {
              io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.ZoneAwareLbConfig.Builder subBuilder = null;
              if (localityConfigSpecifierCase_ == 2) {
                subBuilder = ((io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.ZoneAwareLbConfig) localityConfigSpecifier_).toBuilder();
              }
              localityConfigSpecifier_ =
                  input.readMessage(io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.ZoneAwareLbConfig.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom((io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.ZoneAwareLbConfig) localityConfigSpecifier_);
                localityConfigSpecifier_ = subBuilder.buildPartial();
              }
              localityConfigSpecifierCase_ = 2;
              break;
            }
            case 26: {
              io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.LocalityWeightedLbConfig.Builder subBuilder = null;
              if (localityConfigSpecifierCase_ == 3) {
                subBuilder = ((io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.LocalityWeightedLbConfig) localityConfigSpecifier_).toBuilder();
              }
              localityConfigSpecifier_ =
                  input.readMessage(io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.LocalityWeightedLbConfig.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom((io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.LocalityWeightedLbConfig) localityConfigSpecifier_);
                localityConfigSpecifier_ = subBuilder.buildPartial();
              }
              localityConfigSpecifierCase_ = 3;
              break;
            }
            case 34: {
              com.google.protobuf.Duration.Builder subBuilder = null;
              if (updateMergeWindow_ != null) {
                subBuilder = updateMergeWindow_.toBuilder();
              }
              updateMergeWindow_ = input.readMessage(com.google.protobuf.Duration.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(updateMergeWindow_);
                updateMergeWindow_ = subBuilder.buildPartial();
              }

              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.grpc.xds.shaded.envoy.api.v2.Cds.internal_static_envoy_api_v2_Cluster_CommonLbConfig_descriptor;
    }

    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.grpc.xds.shaded.envoy.api.v2.Cds.internal_static_envoy_api_v2_Cluster_CommonLbConfig_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.class, io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.Builder.class);
    }

    public interface ZoneAwareLbConfigOrBuilder extends
        // @@protoc_insertion_point(interface_extends:envoy.api.v2.Cluster.CommonLbConfig.ZoneAwareLbConfig)
        com.google.protobuf.MessageOrBuilder {

      /**
       * <pre>
       * Configures percentage of requests that will be considered for zone aware routing
       * if zone aware routing is configured. If not specified, the default is 100%.
       * * :ref:`runtime values &lt;config_cluster_manager_cluster_runtime_zone_routing&gt;`.
       * * :ref:`Zone aware routing support &lt;arch_overview_load_balancing_zone_aware_routing&gt;`.
       * </pre>
       *
       * <code>.envoy.type.Percent routing_enabled = 1;</code>
       */
      boolean hasRoutingEnabled();
      /**
       * <pre>
       * Configures percentage of requests that will be considered for zone aware routing
       * if zone aware routing is configured. If not specified, the default is 100%.
       * * :ref:`runtime values &lt;config_cluster_manager_cluster_runtime_zone_routing&gt;`.
       * * :ref:`Zone aware routing support &lt;arch_overview_load_balancing_zone_aware_routing&gt;`.
       * </pre>
       *
       * <code>.envoy.type.Percent routing_enabled = 1;</code>
       */
      io.grpc.xds.shaded.envoy.type.Percent getRoutingEnabled();
      /**
       * <pre>
       * Configures percentage of requests that will be considered for zone aware routing
       * if zone aware routing is configured. If not specified, the default is 100%.
       * * :ref:`runtime values &lt;config_cluster_manager_cluster_runtime_zone_routing&gt;`.
       * * :ref:`Zone aware routing support &lt;arch_overview_load_balancing_zone_aware_routing&gt;`.
       * </pre>
       *
       * <code>.envoy.type.Percent routing_enabled = 1;</code>
       */
      io.grpc.xds.shaded.envoy.type.PercentOrBuilder getRoutingEnabledOrBuilder();

      /**
       * <pre>
       * Configures minimum upstream cluster size required for zone aware routing
       * If upstream cluster size is less than specified, zone aware routing is not performed
       * even if zone aware routing is configured. If not specified, the default is 6.
       * * :ref:`runtime values &lt;config_cluster_manager_cluster_runtime_zone_routing&gt;`.
       * * :ref:`Zone aware routing support &lt;arch_overview_load_balancing_zone_aware_routing&gt;`.
       * </pre>
       *
       * <code>.google.protobuf.UInt64Value min_cluster_size = 2;</code>
       */
      boolean hasMinClusterSize();
      /**
       * <pre>
       * Configures minimum upstream cluster size required for zone aware routing
       * If upstream cluster size is less than specified, zone aware routing is not performed
       * even if zone aware routing is configured. If not specified, the default is 6.
       * * :ref:`runtime values &lt;config_cluster_manager_cluster_runtime_zone_routing&gt;`.
       * * :ref:`Zone aware routing support &lt;arch_overview_load_balancing_zone_aware_routing&gt;`.
       * </pre>
       *
       * <code>.google.protobuf.UInt64Value min_cluster_size = 2;</code>
       */
      com.google.protobuf.UInt64Value getMinClusterSize();
      /**
       * <pre>
       * Configures minimum upstream cluster size required for zone aware routing
       * If upstream cluster size is less than specified, zone aware routing is not performed
       * even if zone aware routing is configured. If not specified, the default is 6.
       * * :ref:`runtime values &lt;config_cluster_manager_cluster_runtime_zone_routing&gt;`.
       * * :ref:`Zone aware routing support &lt;arch_overview_load_balancing_zone_aware_routing&gt;`.
       * </pre>
       *
       * <code>.google.protobuf.UInt64Value min_cluster_size = 2;</code>
       */
      com.google.protobuf.UInt64ValueOrBuilder getMinClusterSizeOrBuilder();
    }
    /**
     * <pre>
     * Configuration for :ref:`zone aware routing
     * &lt;arch_overview_load_balancing_zone_aware_routing&gt;`.
     * </pre>
     *
     * Protobuf type {@code envoy.api.v2.Cluster.CommonLbConfig.ZoneAwareLbConfig}
     */
    public  static final class ZoneAwareLbConfig extends
        com.google.protobuf.GeneratedMessageV3 implements
        // @@protoc_insertion_point(message_implements:envoy.api.v2.Cluster.CommonLbConfig.ZoneAwareLbConfig)
        ZoneAwareLbConfigOrBuilder {
    private static final long serialVersionUID = 0L;
      // Use ZoneAwareLbConfig.newBuilder() to construct.
      private ZoneAwareLbConfig(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
        super(builder);
      }
      private ZoneAwareLbConfig() {
      }

      @java.lang.Override
      public final com.google.protobuf.UnknownFieldSet
      getUnknownFields() {
        return this.unknownFields;
      }
      private ZoneAwareLbConfig(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        this();
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        int mutable_bitField0_ = 0;
        com.google.protobuf.UnknownFieldSet.Builder unknownFields =
            com.google.protobuf.UnknownFieldSet.newBuilder();
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              default: {
                if (!parseUnknownFieldProto3(
                    input, unknownFields, extensionRegistry, tag)) {
                  done = true;
                }
                break;
              }
              case 10: {
                io.grpc.xds.shaded.envoy.type.Percent.Builder subBuilder = null;
                if (routingEnabled_ != null) {
                  subBuilder = routingEnabled_.toBuilder();
                }
                routingEnabled_ = input.readMessage(io.grpc.xds.shaded.envoy.type.Percent.parser(), extensionRegistry);
                if (subBuilder != null) {
                  subBuilder.mergeFrom(routingEnabled_);
                  routingEnabled_ = subBuilder.buildPartial();
                }

                break;
              }
              case 18: {
                com.google.protobuf.UInt64Value.Builder subBuilder = null;
                if (minClusterSize_ != null) {
                  subBuilder = minClusterSize_.toBuilder();
                }
                minClusterSize_ = input.readMessage(com.google.protobuf.UInt64Value.parser(), extensionRegistry);
                if (subBuilder != null) {
                  subBuilder.mergeFrom(minClusterSize_);
                  minClusterSize_ = subBuilder.buildPartial();
                }

                break;
              }
            }
          }
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(this);
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(
              e).setUnfinishedMessage(this);
        } finally {
          this.unknownFields = unknownFields.build();
          makeExtensionsImmutable();
        }
      }
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.grpc.xds.shaded.envoy.api.v2.Cds.internal_static_envoy_api_v2_Cluster_CommonLbConfig_ZoneAwareLbConfig_descriptor;
      }

      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.grpc.xds.shaded.envoy.api.v2.Cds.internal_static_envoy_api_v2_Cluster_CommonLbConfig_ZoneAwareLbConfig_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.ZoneAwareLbConfig.class, io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.ZoneAwareLbConfig.Builder.class);
      }

      public static final int ROUTING_ENABLED_FIELD_NUMBER = 1;
      private io.grpc.xds.shaded.envoy.type.Percent routingEnabled_;
      /**
       * <pre>
       * Configures percentage of requests that will be considered for zone aware routing
       * if zone aware routing is configured. If not specified, the default is 100%.
       * * :ref:`runtime values &lt;config_cluster_manager_cluster_runtime_zone_routing&gt;`.
       * * :ref:`Zone aware routing support &lt;arch_overview_load_balancing_zone_aware_routing&gt;`.
       * </pre>
       *
       * <code>.envoy.type.Percent routing_enabled = 1;</code>
       */
      public boolean hasRoutingEnabled() {
        return routingEnabled_ != null;
      }
      /**
       * <pre>
       * Configures percentage of requests that will be considered for zone aware routing
       * if zone aware routing is configured. If not specified, the default is 100%.
       * * :ref:`runtime values &lt;config_cluster_manager_cluster_runtime_zone_routing&gt;`.
       * * :ref:`Zone aware routing support &lt;arch_overview_load_balancing_zone_aware_routing&gt;`.
       * </pre>
       *
       * <code>.envoy.type.Percent routing_enabled = 1;</code>
       */
      public io.grpc.xds.shaded.envoy.type.Percent getRoutingEnabled() {
        return routingEnabled_ == null ? io.grpc.xds.shaded.envoy.type.Percent.getDefaultInstance() : routingEnabled_;
      }
      /**
       * <pre>
       * Configures percentage of requests that will be considered for zone aware routing
       * if zone aware routing is configured. If not specified, the default is 100%.
       * * :ref:`runtime values &lt;config_cluster_manager_cluster_runtime_zone_routing&gt;`.
       * * :ref:`Zone aware routing support &lt;arch_overview_load_balancing_zone_aware_routing&gt;`.
       * </pre>
       *
       * <code>.envoy.type.Percent routing_enabled = 1;</code>
       */
      public io.grpc.xds.shaded.envoy.type.PercentOrBuilder getRoutingEnabledOrBuilder() {
        return getRoutingEnabled();
      }

      public static final int MIN_CLUSTER_SIZE_FIELD_NUMBER = 2;
      private com.google.protobuf.UInt64Value minClusterSize_;
      /**
       * <pre>
       * Configures minimum upstream cluster size required for zone aware routing
       * If upstream cluster size is less than specified, zone aware routing is not performed
       * even if zone aware routing is configured. If not specified, the default is 6.
       * * :ref:`runtime values &lt;config_cluster_manager_cluster_runtime_zone_routing&gt;`.
       * * :ref:`Zone aware routing support &lt;arch_overview_load_balancing_zone_aware_routing&gt;`.
       * </pre>
       *
       * <code>.google.protobuf.UInt64Value min_cluster_size = 2;</code>
       */
      public boolean hasMinClusterSize() {
        return minClusterSize_ != null;
      }
      /**
       * <pre>
       * Configures minimum upstream cluster size required for zone aware routing
       * If upstream cluster size is less than specified, zone aware routing is not performed
       * even if zone aware routing is configured. If not specified, the default is 6.
       * * :ref:`runtime values &lt;config_cluster_manager_cluster_runtime_zone_routing&gt;`.
       * * :ref:`Zone aware routing support &lt;arch_overview_load_balancing_zone_aware_routing&gt;`.
       * </pre>
       *
       * <code>.google.protobuf.UInt64Value min_cluster_size = 2;</code>
       */
      public com.google.protobuf.UInt64Value getMinClusterSize() {
        return minClusterSize_ == null ? com.google.protobuf.UInt64Value.getDefaultInstance() : minClusterSize_;
      }
      /**
       * <pre>
       * Configures minimum upstream cluster size required for zone aware routing
       * If upstream cluster size is less than specified, zone aware routing is not performed
       * even if zone aware routing is configured. If not specified, the default is 6.
       * * :ref:`runtime values &lt;config_cluster_manager_cluster_runtime_zone_routing&gt;`.
       * * :ref:`Zone aware routing support &lt;arch_overview_load_balancing_zone_aware_routing&gt;`.
       * </pre>
       *
       * <code>.google.protobuf.UInt64Value min_cluster_size = 2;</code>
       */
      public com.google.protobuf.UInt64ValueOrBuilder getMinClusterSizeOrBuilder() {
        return getMinClusterSize();
      }

      private byte memoizedIsInitialized = -1;
      public final boolean isInitialized() {
        byte isInitialized = memoizedIsInitialized;
        if (isInitialized == 1) return true;
        if (isInitialized == 0) return false;

        memoizedIsInitialized = 1;
        return true;
      }

      public void writeTo(com.google.protobuf.CodedOutputStream output)
                          throws java.io.IOException {
        if (routingEnabled_ != null) {
          output.writeMessage(1, getRoutingEnabled());
        }
        if (minClusterSize_ != null) {
          output.writeMessage(2, getMinClusterSize());
        }
        unknownFields.writeTo(output);
      }

      public int getSerializedSize() {
        int size = memoizedSize;
        if (size != -1) return size;

        size = 0;
        if (routingEnabled_ != null) {
          size += com.google.protobuf.CodedOutputStream
            .computeMessageSize(1, getRoutingEnabled());
        }
        if (minClusterSize_ != null) {
          size += com.google.protobuf.CodedOutputStream
            .computeMessageSize(2, getMinClusterSize());
        }
        size += unknownFields.getSerializedSize();
        memoizedSize = size;
        return size;
      }

      @java.lang.Override
      public boolean equals(final java.lang.Object obj) {
        if (obj == this) {
         return true;
        }
        if (!(obj instanceof io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.ZoneAwareLbConfig)) {
          return super.equals(obj);
        }
        io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.ZoneAwareLbConfig other = (io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.ZoneAwareLbConfig) obj;

        boolean result = true;
        result = result && (hasRoutingEnabled() == other.hasRoutingEnabled());
        if (hasRoutingEnabled()) {
          result = result && getRoutingEnabled()
              .equals(other.getRoutingEnabled());
        }
        result = result && (hasMinClusterSize() == other.hasMinClusterSize());
        if (hasMinClusterSize()) {
          result = result && getMinClusterSize()
              .equals(other.getMinClusterSize());
        }
        result = result && unknownFields.equals(other.unknownFields);
        return result;
      }

      @java.lang.Override
      public int hashCode() {
        if (memoizedHashCode != 0) {
          return memoizedHashCode;
        }
        int hash = 41;
        hash = (19 * hash) + getDescriptor().hashCode();
        if (hasRoutingEnabled()) {
          hash = (37 * hash) + ROUTING_ENABLED_FIELD_NUMBER;
          hash = (53 * hash) + getRoutingEnabled().hashCode();
        }
        if (hasMinClusterSize()) {
          hash = (37 * hash) + MIN_CLUSTER_SIZE_FIELD_NUMBER;
          hash = (53 * hash) + getMinClusterSize().hashCode();
        }
        hash = (29 * hash) + unknownFields.hashCode();
        memoizedHashCode = hash;
        return hash;
      }

      public static io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.ZoneAwareLbConfig parseFrom(
          java.nio.ByteBuffer data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.ZoneAwareLbConfig parseFrom(
          java.nio.ByteBuffer data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.ZoneAwareLbConfig parseFrom(
          com.google.protobuf.ByteString data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.ZoneAwareLbConfig parseFrom(
          com.google.protobuf.ByteString data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.ZoneAwareLbConfig parseFrom(byte[] data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.ZoneAwareLbConfig parseFrom(
          byte[] data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.ZoneAwareLbConfig parseFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input);
      }
      public static io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.ZoneAwareLbConfig parseFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input, extensionRegistry);
      }
      public static io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.ZoneAwareLbConfig parseDelimitedFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseDelimitedWithIOException(PARSER, input);
      }
      public static io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.ZoneAwareLbConfig parseDelimitedFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
      }
      public static io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.ZoneAwareLbConfig parseFrom(
          com.google.protobuf.CodedInputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input);
      }
      public static io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.ZoneAwareLbConfig parseFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input, extensionRegistry);
      }

      public Builder newBuilderForType() { return newBuilder(); }
      public static Builder newBuilder() {
        return DEFAULT_INSTANCE.toBuilder();
      }
      public static Builder newBuilder(io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.ZoneAwareLbConfig prototype) {
        return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
      }
      public Builder toBuilder() {
        return this == DEFAULT_INSTANCE
            ? new Builder() : new Builder().mergeFrom(this);
      }

      @java.lang.Override
      protected Builder newBuilderForType(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        Builder builder = new Builder(parent);
        return builder;
      }
      /**
       * <pre>
       * Configuration for :ref:`zone aware routing
       * &lt;arch_overview_load_balancing_zone_aware_routing&gt;`.
       * </pre>
       *
       * Protobuf type {@code envoy.api.v2.Cluster.CommonLbConfig.ZoneAwareLbConfig}
       */
      public static final class Builder extends
          com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
          // @@protoc_insertion_point(builder_implements:envoy.api.v2.Cluster.CommonLbConfig.ZoneAwareLbConfig)
          io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.ZoneAwareLbConfigOrBuilder {
        public static final com.google.protobuf.Descriptors.Descriptor
            getDescriptor() {
          return io.grpc.xds.shaded.envoy.api.v2.Cds.internal_static_envoy_api_v2_Cluster_CommonLbConfig_ZoneAwareLbConfig_descriptor;
        }

        protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
            internalGetFieldAccessorTable() {
          return io.grpc.xds.shaded.envoy.api.v2.Cds.internal_static_envoy_api_v2_Cluster_CommonLbConfig_ZoneAwareLbConfig_fieldAccessorTable
              .ensureFieldAccessorsInitialized(
                  io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.ZoneAwareLbConfig.class, io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.ZoneAwareLbConfig.Builder.class);
        }

        // Construct using io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.ZoneAwareLbConfig.newBuilder()
        private Builder() {
          maybeForceBuilderInitialization();
        }

        private Builder(
            com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
          super(parent);
          maybeForceBuilderInitialization();
        }
        private void maybeForceBuilderInitialization() {
          if (com.google.protobuf.GeneratedMessageV3
                  .alwaysUseFieldBuilders) {
          }
        }
        public Builder clear() {
          super.clear();
          if (routingEnabledBuilder_ == null) {
            routingEnabled_ = null;
          } else {
            routingEnabled_ = null;
            routingEnabledBuilder_ = null;
          }
          if (minClusterSizeBuilder_ == null) {
            minClusterSize_ = null;
          } else {
            minClusterSize_ = null;
            minClusterSizeBuilder_ = null;
          }
          return this;
        }

        public com.google.protobuf.Descriptors.Descriptor
            getDescriptorForType() {
          return io.grpc.xds.shaded.envoy.api.v2.Cds.internal_static_envoy_api_v2_Cluster_CommonLbConfig_ZoneAwareLbConfig_descriptor;
        }

        public io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.ZoneAwareLbConfig getDefaultInstanceForType() {
          return io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.ZoneAwareLbConfig.getDefaultInstance();
        }

        public io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.ZoneAwareLbConfig build() {
          io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.ZoneAwareLbConfig result = buildPartial();
          if (!result.isInitialized()) {
            throw newUninitializedMessageException(result);
          }
          return result;
        }

        public io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.ZoneAwareLbConfig buildPartial() {
          io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.ZoneAwareLbConfig result = new io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.ZoneAwareLbConfig(this);
          if (routingEnabledBuilder_ == null) {
            result.routingEnabled_ = routingEnabled_;
          } else {
            result.routingEnabled_ = routingEnabledBuilder_.build();
          }
          if (minClusterSizeBuilder_ == null) {
            result.minClusterSize_ = minClusterSize_;
          } else {
            result.minClusterSize_ = minClusterSizeBuilder_.build();
          }
          onBuilt();
          return result;
        }

        public Builder clone() {
          return (Builder) super.clone();
        }
        public Builder setField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            java.lang.Object value) {
          return (Builder) super.setField(field, value);
        }
        public Builder clearField(
            com.google.protobuf.Descriptors.FieldDescriptor field) {
          return (Builder) super.clearField(field);
        }
        public Builder clearOneof(
            com.google.protobuf.Descriptors.OneofDescriptor oneof) {
          return (Builder) super.clearOneof(oneof);
        }
        public Builder setRepeatedField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            int index, java.lang.Object value) {
          return (Builder) super.setRepeatedField(field, index, value);
        }
        public Builder addRepeatedField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            java.lang.Object value) {
          return (Builder) super.addRepeatedField(field, value);
        }
        public Builder mergeFrom(com.google.protobuf.Message other) {
          if (other instanceof io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.ZoneAwareLbConfig) {
            return mergeFrom((io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.ZoneAwareLbConfig)other);
          } else {
            super.mergeFrom(other);
            return this;
          }
        }

        public Builder mergeFrom(io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.ZoneAwareLbConfig other) {
          if (other == io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.ZoneAwareLbConfig.getDefaultInstance()) return this;
          if (other.hasRoutingEnabled()) {
            mergeRoutingEnabled(other.getRoutingEnabled());
          }
          if (other.hasMinClusterSize()) {
            mergeMinClusterSize(other.getMinClusterSize());
          }
          this.mergeUnknownFields(other.unknownFields);
          onChanged();
          return this;
        }

        public final boolean isInitialized() {
          return true;
        }

        public Builder mergeFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
          io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.ZoneAwareLbConfig parsedMessage = null;
          try {
            parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            parsedMessage = (io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.ZoneAwareLbConfig) e.getUnfinishedMessage();
            throw e.unwrapIOException();
          } finally {
            if (parsedMessage != null) {
              mergeFrom(parsedMessage);
            }
          }
          return this;
        }

        private io.grpc.xds.shaded.envoy.type.Percent routingEnabled_ = null;
        private com.google.protobuf.SingleFieldBuilderV3<
            io.grpc.xds.shaded.envoy.type.Percent, io.grpc.xds.shaded.envoy.type.Percent.Builder, io.grpc.xds.shaded.envoy.type.PercentOrBuilder> routingEnabledBuilder_;
        /**
         * <pre>
         * Configures percentage of requests that will be considered for zone aware routing
         * if zone aware routing is configured. If not specified, the default is 100%.
         * * :ref:`runtime values &lt;config_cluster_manager_cluster_runtime_zone_routing&gt;`.
         * * :ref:`Zone aware routing support &lt;arch_overview_load_balancing_zone_aware_routing&gt;`.
         * </pre>
         *
         * <code>.envoy.type.Percent routing_enabled = 1;</code>
         */
        public boolean hasRoutingEnabled() {
          return routingEnabledBuilder_ != null || routingEnabled_ != null;
        }
        /**
         * <pre>
         * Configures percentage of requests that will be considered for zone aware routing
         * if zone aware routing is configured. If not specified, the default is 100%.
         * * :ref:`runtime values &lt;config_cluster_manager_cluster_runtime_zone_routing&gt;`.
         * * :ref:`Zone aware routing support &lt;arch_overview_load_balancing_zone_aware_routing&gt;`.
         * </pre>
         *
         * <code>.envoy.type.Percent routing_enabled = 1;</code>
         */
        public io.grpc.xds.shaded.envoy.type.Percent getRoutingEnabled() {
          if (routingEnabledBuilder_ == null) {
            return routingEnabled_ == null ? io.grpc.xds.shaded.envoy.type.Percent.getDefaultInstance() : routingEnabled_;
          } else {
            return routingEnabledBuilder_.getMessage();
          }
        }
        /**
         * <pre>
         * Configures percentage of requests that will be considered for zone aware routing
         * if zone aware routing is configured. If not specified, the default is 100%.
         * * :ref:`runtime values &lt;config_cluster_manager_cluster_runtime_zone_routing&gt;`.
         * * :ref:`Zone aware routing support &lt;arch_overview_load_balancing_zone_aware_routing&gt;`.
         * </pre>
         *
         * <code>.envoy.type.Percent routing_enabled = 1;</code>
         */
        public Builder setRoutingEnabled(io.grpc.xds.shaded.envoy.type.Percent value) {
          if (routingEnabledBuilder_ == null) {
            if (value == null) {
              throw new NullPointerException();
            }
            routingEnabled_ = value;
            onChanged();
          } else {
            routingEnabledBuilder_.setMessage(value);
          }

          return this;
        }
        /**
         * <pre>
         * Configures percentage of requests that will be considered for zone aware routing
         * if zone aware routing is configured. If not specified, the default is 100%.
         * * :ref:`runtime values &lt;config_cluster_manager_cluster_runtime_zone_routing&gt;`.
         * * :ref:`Zone aware routing support &lt;arch_overview_load_balancing_zone_aware_routing&gt;`.
         * </pre>
         *
         * <code>.envoy.type.Percent routing_enabled = 1;</code>
         */
        public Builder setRoutingEnabled(
            io.grpc.xds.shaded.envoy.type.Percent.Builder builderForValue) {
          if (routingEnabledBuilder_ == null) {
            routingEnabled_ = builderForValue.build();
            onChanged();
          } else {
            routingEnabledBuilder_.setMessage(builderForValue.build());
          }

          return this;
        }
        /**
         * <pre>
         * Configures percentage of requests that will be considered for zone aware routing
         * if zone aware routing is configured. If not specified, the default is 100%.
         * * :ref:`runtime values &lt;config_cluster_manager_cluster_runtime_zone_routing&gt;`.
         * * :ref:`Zone aware routing support &lt;arch_overview_load_balancing_zone_aware_routing&gt;`.
         * </pre>
         *
         * <code>.envoy.type.Percent routing_enabled = 1;</code>
         */
        public Builder mergeRoutingEnabled(io.grpc.xds.shaded.envoy.type.Percent value) {
          if (routingEnabledBuilder_ == null) {
            if (routingEnabled_ != null) {
              routingEnabled_ =
                io.grpc.xds.shaded.envoy.type.Percent.newBuilder(routingEnabled_).mergeFrom(value).buildPartial();
            } else {
              routingEnabled_ = value;
            }
            onChanged();
          } else {
            routingEnabledBuilder_.mergeFrom(value);
          }

          return this;
        }
        /**
         * <pre>
         * Configures percentage of requests that will be considered for zone aware routing
         * if zone aware routing is configured. If not specified, the default is 100%.
         * * :ref:`runtime values &lt;config_cluster_manager_cluster_runtime_zone_routing&gt;`.
         * * :ref:`Zone aware routing support &lt;arch_overview_load_balancing_zone_aware_routing&gt;`.
         * </pre>
         *
         * <code>.envoy.type.Percent routing_enabled = 1;</code>
         */
        public Builder clearRoutingEnabled() {
          if (routingEnabledBuilder_ == null) {
            routingEnabled_ = null;
            onChanged();
          } else {
            routingEnabled_ = null;
            routingEnabledBuilder_ = null;
          }

          return this;
        }
        /**
         * <pre>
         * Configures percentage of requests that will be considered for zone aware routing
         * if zone aware routing is configured. If not specified, the default is 100%.
         * * :ref:`runtime values &lt;config_cluster_manager_cluster_runtime_zone_routing&gt;`.
         * * :ref:`Zone aware routing support &lt;arch_overview_load_balancing_zone_aware_routing&gt;`.
         * </pre>
         *
         * <code>.envoy.type.Percent routing_enabled = 1;</code>
         */
        public io.grpc.xds.shaded.envoy.type.Percent.Builder getRoutingEnabledBuilder() {
          
          onChanged();
          return getRoutingEnabledFieldBuilder().getBuilder();
        }
        /**
         * <pre>
         * Configures percentage of requests that will be considered for zone aware routing
         * if zone aware routing is configured. If not specified, the default is 100%.
         * * :ref:`runtime values &lt;config_cluster_manager_cluster_runtime_zone_routing&gt;`.
         * * :ref:`Zone aware routing support &lt;arch_overview_load_balancing_zone_aware_routing&gt;`.
         * </pre>
         *
         * <code>.envoy.type.Percent routing_enabled = 1;</code>
         */
        public io.grpc.xds.shaded.envoy.type.PercentOrBuilder getRoutingEnabledOrBuilder() {
          if (routingEnabledBuilder_ != null) {
            return routingEnabledBuilder_.getMessageOrBuilder();
          } else {
            return routingEnabled_ == null ?
                io.grpc.xds.shaded.envoy.type.Percent.getDefaultInstance() : routingEnabled_;
          }
        }
        /**
         * <pre>
         * Configures percentage of requests that will be considered for zone aware routing
         * if zone aware routing is configured. If not specified, the default is 100%.
         * * :ref:`runtime values &lt;config_cluster_manager_cluster_runtime_zone_routing&gt;`.
         * * :ref:`Zone aware routing support &lt;arch_overview_load_balancing_zone_aware_routing&gt;`.
         * </pre>
         *
         * <code>.envoy.type.Percent routing_enabled = 1;</code>
         */
        private com.google.protobuf.SingleFieldBuilderV3<
            io.grpc.xds.shaded.envoy.type.Percent, io.grpc.xds.shaded.envoy.type.Percent.Builder, io.grpc.xds.shaded.envoy.type.PercentOrBuilder> 
            getRoutingEnabledFieldBuilder() {
          if (routingEnabledBuilder_ == null) {
            routingEnabledBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
                io.grpc.xds.shaded.envoy.type.Percent, io.grpc.xds.shaded.envoy.type.Percent.Builder, io.grpc.xds.shaded.envoy.type.PercentOrBuilder>(
                    getRoutingEnabled(),
                    getParentForChildren(),
                    isClean());
            routingEnabled_ = null;
          }
          return routingEnabledBuilder_;
        }

        private com.google.protobuf.UInt64Value minClusterSize_ = null;
        private com.google.protobuf.SingleFieldBuilderV3<
            com.google.protobuf.UInt64Value, com.google.protobuf.UInt64Value.Builder, com.google.protobuf.UInt64ValueOrBuilder> minClusterSizeBuilder_;
        /**
         * <pre>
         * Configures minimum upstream cluster size required for zone aware routing
         * If upstream cluster size is less than specified, zone aware routing is not performed
         * even if zone aware routing is configured. If not specified, the default is 6.
         * * :ref:`runtime values &lt;config_cluster_manager_cluster_runtime_zone_routing&gt;`.
         * * :ref:`Zone aware routing support &lt;arch_overview_load_balancing_zone_aware_routing&gt;`.
         * </pre>
         *
         * <code>.google.protobuf.UInt64Value min_cluster_size = 2;</code>
         */
        public boolean hasMinClusterSize() {
          return minClusterSizeBuilder_ != null || minClusterSize_ != null;
        }
        /**
         * <pre>
         * Configures minimum upstream cluster size required for zone aware routing
         * If upstream cluster size is less than specified, zone aware routing is not performed
         * even if zone aware routing is configured. If not specified, the default is 6.
         * * :ref:`runtime values &lt;config_cluster_manager_cluster_runtime_zone_routing&gt;`.
         * * :ref:`Zone aware routing support &lt;arch_overview_load_balancing_zone_aware_routing&gt;`.
         * </pre>
         *
         * <code>.google.protobuf.UInt64Value min_cluster_size = 2;</code>
         */
        public com.google.protobuf.UInt64Value getMinClusterSize() {
          if (minClusterSizeBuilder_ == null) {
            return minClusterSize_ == null ? com.google.protobuf.UInt64Value.getDefaultInstance() : minClusterSize_;
          } else {
            return minClusterSizeBuilder_.getMessage();
          }
        }
        /**
         * <pre>
         * Configures minimum upstream cluster size required for zone aware routing
         * If upstream cluster size is less than specified, zone aware routing is not performed
         * even if zone aware routing is configured. If not specified, the default is 6.
         * * :ref:`runtime values &lt;config_cluster_manager_cluster_runtime_zone_routing&gt;`.
         * * :ref:`Zone aware routing support &lt;arch_overview_load_balancing_zone_aware_routing&gt;`.
         * </pre>
         *
         * <code>.google.protobuf.UInt64Value min_cluster_size = 2;</code>
         */
        public Builder setMinClusterSize(com.google.protobuf.UInt64Value value) {
          if (minClusterSizeBuilder_ == null) {
            if (value == null) {
              throw new NullPointerException();
            }
            minClusterSize_ = value;
            onChanged();
          } else {
            minClusterSizeBuilder_.setMessage(value);
          }

          return this;
        }
        /**
         * <pre>
         * Configures minimum upstream cluster size required for zone aware routing
         * If upstream cluster size is less than specified, zone aware routing is not performed
         * even if zone aware routing is configured. If not specified, the default is 6.
         * * :ref:`runtime values &lt;config_cluster_manager_cluster_runtime_zone_routing&gt;`.
         * * :ref:`Zone aware routing support &lt;arch_overview_load_balancing_zone_aware_routing&gt;`.
         * </pre>
         *
         * <code>.google.protobuf.UInt64Value min_cluster_size = 2;</code>
         */
        public Builder setMinClusterSize(
            com.google.protobuf.UInt64Value.Builder builderForValue) {
          if (minClusterSizeBuilder_ == null) {
            minClusterSize_ = builderForValue.build();
            onChanged();
          } else {
            minClusterSizeBuilder_.setMessage(builderForValue.build());
          }

          return this;
        }
        /**
         * <pre>
         * Configures minimum upstream cluster size required for zone aware routing
         * If upstream cluster size is less than specified, zone aware routing is not performed
         * even if zone aware routing is configured. If not specified, the default is 6.
         * * :ref:`runtime values &lt;config_cluster_manager_cluster_runtime_zone_routing&gt;`.
         * * :ref:`Zone aware routing support &lt;arch_overview_load_balancing_zone_aware_routing&gt;`.
         * </pre>
         *
         * <code>.google.protobuf.UInt64Value min_cluster_size = 2;</code>
         */
        public Builder mergeMinClusterSize(com.google.protobuf.UInt64Value value) {
          if (minClusterSizeBuilder_ == null) {
            if (minClusterSize_ != null) {
              minClusterSize_ =
                com.google.protobuf.UInt64Value.newBuilder(minClusterSize_).mergeFrom(value).buildPartial();
            } else {
              minClusterSize_ = value;
            }
            onChanged();
          } else {
            minClusterSizeBuilder_.mergeFrom(value);
          }

          return this;
        }
        /**
         * <pre>
         * Configures minimum upstream cluster size required for zone aware routing
         * If upstream cluster size is less than specified, zone aware routing is not performed
         * even if zone aware routing is configured. If not specified, the default is 6.
         * * :ref:`runtime values &lt;config_cluster_manager_cluster_runtime_zone_routing&gt;`.
         * * :ref:`Zone aware routing support &lt;arch_overview_load_balancing_zone_aware_routing&gt;`.
         * </pre>
         *
         * <code>.google.protobuf.UInt64Value min_cluster_size = 2;</code>
         */
        public Builder clearMinClusterSize() {
          if (minClusterSizeBuilder_ == null) {
            minClusterSize_ = null;
            onChanged();
          } else {
            minClusterSize_ = null;
            minClusterSizeBuilder_ = null;
          }

          return this;
        }
        /**
         * <pre>
         * Configures minimum upstream cluster size required for zone aware routing
         * If upstream cluster size is less than specified, zone aware routing is not performed
         * even if zone aware routing is configured. If not specified, the default is 6.
         * * :ref:`runtime values &lt;config_cluster_manager_cluster_runtime_zone_routing&gt;`.
         * * :ref:`Zone aware routing support &lt;arch_overview_load_balancing_zone_aware_routing&gt;`.
         * </pre>
         *
         * <code>.google.protobuf.UInt64Value min_cluster_size = 2;</code>
         */
        public com.google.protobuf.UInt64Value.Builder getMinClusterSizeBuilder() {
          
          onChanged();
          return getMinClusterSizeFieldBuilder().getBuilder();
        }
        /**
         * <pre>
         * Configures minimum upstream cluster size required for zone aware routing
         * If upstream cluster size is less than specified, zone aware routing is not performed
         * even if zone aware routing is configured. If not specified, the default is 6.
         * * :ref:`runtime values &lt;config_cluster_manager_cluster_runtime_zone_routing&gt;`.
         * * :ref:`Zone aware routing support &lt;arch_overview_load_balancing_zone_aware_routing&gt;`.
         * </pre>
         *
         * <code>.google.protobuf.UInt64Value min_cluster_size = 2;</code>
         */
        public com.google.protobuf.UInt64ValueOrBuilder getMinClusterSizeOrBuilder() {
          if (minClusterSizeBuilder_ != null) {
            return minClusterSizeBuilder_.getMessageOrBuilder();
          } else {
            return minClusterSize_ == null ?
                com.google.protobuf.UInt64Value.getDefaultInstance() : minClusterSize_;
          }
        }
        /**
         * <pre>
         * Configures minimum upstream cluster size required for zone aware routing
         * If upstream cluster size is less than specified, zone aware routing is not performed
         * even if zone aware routing is configured. If not specified, the default is 6.
         * * :ref:`runtime values &lt;config_cluster_manager_cluster_runtime_zone_routing&gt;`.
         * * :ref:`Zone aware routing support &lt;arch_overview_load_balancing_zone_aware_routing&gt;`.
         * </pre>
         *
         * <code>.google.protobuf.UInt64Value min_cluster_size = 2;</code>
         */
        private com.google.protobuf.SingleFieldBuilderV3<
            com.google.protobuf.UInt64Value, com.google.protobuf.UInt64Value.Builder, com.google.protobuf.UInt64ValueOrBuilder> 
            getMinClusterSizeFieldBuilder() {
          if (minClusterSizeBuilder_ == null) {
            minClusterSizeBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
                com.google.protobuf.UInt64Value, com.google.protobuf.UInt64Value.Builder, com.google.protobuf.UInt64ValueOrBuilder>(
                    getMinClusterSize(),
                    getParentForChildren(),
                    isClean());
            minClusterSize_ = null;
          }
          return minClusterSizeBuilder_;
        }
        public final Builder setUnknownFields(
            final com.google.protobuf.UnknownFieldSet unknownFields) {
          return super.setUnknownFieldsProto3(unknownFields);
        }

        public final Builder mergeUnknownFields(
            final com.google.protobuf.UnknownFieldSet unknownFields) {
          return super.mergeUnknownFields(unknownFields);
        }


        // @@protoc_insertion_point(builder_scope:envoy.api.v2.Cluster.CommonLbConfig.ZoneAwareLbConfig)
      }

      // @@protoc_insertion_point(class_scope:envoy.api.v2.Cluster.CommonLbConfig.ZoneAwareLbConfig)
      private static final io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.ZoneAwareLbConfig DEFAULT_INSTANCE;
      static {
        DEFAULT_INSTANCE = new io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.ZoneAwareLbConfig();
      }

      public static io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.ZoneAwareLbConfig getDefaultInstance() {
        return DEFAULT_INSTANCE;
      }

      private static final com.google.protobuf.Parser<ZoneAwareLbConfig>
          PARSER = new com.google.protobuf.AbstractParser<ZoneAwareLbConfig>() {
        public ZoneAwareLbConfig parsePartialFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
          return new ZoneAwareLbConfig(input, extensionRegistry);
        }
      };

      public static com.google.protobuf.Parser<ZoneAwareLbConfig> parser() {
        return PARSER;
      }

      @java.lang.Override
      public com.google.protobuf.Parser<ZoneAwareLbConfig> getParserForType() {
        return PARSER;
      }

      public io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.ZoneAwareLbConfig getDefaultInstanceForType() {
        return DEFAULT_INSTANCE;
      }

    }

    public interface LocalityWeightedLbConfigOrBuilder extends
        // @@protoc_insertion_point(interface_extends:envoy.api.v2.Cluster.CommonLbConfig.LocalityWeightedLbConfig)
        com.google.protobuf.MessageOrBuilder {
    }
    /**
     * <pre>
     * Configuration for :ref:`locality weighted load balancing
     * &lt;arch_overview_load_balancing_locality_weighted_lb&gt;`
     * </pre>
     *
     * Protobuf type {@code envoy.api.v2.Cluster.CommonLbConfig.LocalityWeightedLbConfig}
     */
    public  static final class LocalityWeightedLbConfig extends
        com.google.protobuf.GeneratedMessageV3 implements
        // @@protoc_insertion_point(message_implements:envoy.api.v2.Cluster.CommonLbConfig.LocalityWeightedLbConfig)
        LocalityWeightedLbConfigOrBuilder {
    private static final long serialVersionUID = 0L;
      // Use LocalityWeightedLbConfig.newBuilder() to construct.
      private LocalityWeightedLbConfig(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
        super(builder);
      }
      private LocalityWeightedLbConfig() {
      }

      @java.lang.Override
      public final com.google.protobuf.UnknownFieldSet
      getUnknownFields() {
        return this.unknownFields;
      }
      private LocalityWeightedLbConfig(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        this();
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        com.google.protobuf.UnknownFieldSet.Builder unknownFields =
            com.google.protobuf.UnknownFieldSet.newBuilder();
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              default: {
                if (!parseUnknownFieldProto3(
                    input, unknownFields, extensionRegistry, tag)) {
                  done = true;
                }
                break;
              }
            }
          }
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(this);
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(
              e).setUnfinishedMessage(this);
        } finally {
          this.unknownFields = unknownFields.build();
          makeExtensionsImmutable();
        }
      }
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.grpc.xds.shaded.envoy.api.v2.Cds.internal_static_envoy_api_v2_Cluster_CommonLbConfig_LocalityWeightedLbConfig_descriptor;
      }

      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.grpc.xds.shaded.envoy.api.v2.Cds.internal_static_envoy_api_v2_Cluster_CommonLbConfig_LocalityWeightedLbConfig_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.LocalityWeightedLbConfig.class, io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.LocalityWeightedLbConfig.Builder.class);
      }

      private byte memoizedIsInitialized = -1;
      public final boolean isInitialized() {
        byte isInitialized = memoizedIsInitialized;
        if (isInitialized == 1) return true;
        if (isInitialized == 0) return false;

        memoizedIsInitialized = 1;
        return true;
      }

      public void writeTo(com.google.protobuf.CodedOutputStream output)
                          throws java.io.IOException {
        unknownFields.writeTo(output);
      }

      public int getSerializedSize() {
        int size = memoizedSize;
        if (size != -1) return size;

        size = 0;
        size += unknownFields.getSerializedSize();
        memoizedSize = size;
        return size;
      }

      @java.lang.Override
      public boolean equals(final java.lang.Object obj) {
        if (obj == this) {
         return true;
        }
        if (!(obj instanceof io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.LocalityWeightedLbConfig)) {
          return super.equals(obj);
        }
        io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.LocalityWeightedLbConfig other = (io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.LocalityWeightedLbConfig) obj;

        boolean result = true;
        result = result && unknownFields.equals(other.unknownFields);
        return result;
      }

      @java.lang.Override
      public int hashCode() {
        if (memoizedHashCode != 0) {
          return memoizedHashCode;
        }
        int hash = 41;
        hash = (19 * hash) + getDescriptor().hashCode();
        hash = (29 * hash) + unknownFields.hashCode();
        memoizedHashCode = hash;
        return hash;
      }

      public static io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.LocalityWeightedLbConfig parseFrom(
          java.nio.ByteBuffer data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.LocalityWeightedLbConfig parseFrom(
          java.nio.ByteBuffer data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.LocalityWeightedLbConfig parseFrom(
          com.google.protobuf.ByteString data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.LocalityWeightedLbConfig parseFrom(
          com.google.protobuf.ByteString data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.LocalityWeightedLbConfig parseFrom(byte[] data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.LocalityWeightedLbConfig parseFrom(
          byte[] data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.LocalityWeightedLbConfig parseFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input);
      }
      public static io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.LocalityWeightedLbConfig parseFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input, extensionRegistry);
      }
      public static io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.LocalityWeightedLbConfig parseDelimitedFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseDelimitedWithIOException(PARSER, input);
      }
      public static io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.LocalityWeightedLbConfig parseDelimitedFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
      }
      public static io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.LocalityWeightedLbConfig parseFrom(
          com.google.protobuf.CodedInputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input);
      }
      public static io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.LocalityWeightedLbConfig parseFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input, extensionRegistry);
      }

      public Builder newBuilderForType() { return newBuilder(); }
      public static Builder newBuilder() {
        return DEFAULT_INSTANCE.toBuilder();
      }
      public static Builder newBuilder(io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.LocalityWeightedLbConfig prototype) {
        return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
      }
      public Builder toBuilder() {
        return this == DEFAULT_INSTANCE
            ? new Builder() : new Builder().mergeFrom(this);
      }

      @java.lang.Override
      protected Builder newBuilderForType(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        Builder builder = new Builder(parent);
        return builder;
      }
      /**
       * <pre>
       * Configuration for :ref:`locality weighted load balancing
       * &lt;arch_overview_load_balancing_locality_weighted_lb&gt;`
       * </pre>
       *
       * Protobuf type {@code envoy.api.v2.Cluster.CommonLbConfig.LocalityWeightedLbConfig}
       */
      public static final class Builder extends
          com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
          // @@protoc_insertion_point(builder_implements:envoy.api.v2.Cluster.CommonLbConfig.LocalityWeightedLbConfig)
          io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.LocalityWeightedLbConfigOrBuilder {
        public static final com.google.protobuf.Descriptors.Descriptor
            getDescriptor() {
          return io.grpc.xds.shaded.envoy.api.v2.Cds.internal_static_envoy_api_v2_Cluster_CommonLbConfig_LocalityWeightedLbConfig_descriptor;
        }

        protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
            internalGetFieldAccessorTable() {
          return io.grpc.xds.shaded.envoy.api.v2.Cds.internal_static_envoy_api_v2_Cluster_CommonLbConfig_LocalityWeightedLbConfig_fieldAccessorTable
              .ensureFieldAccessorsInitialized(
                  io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.LocalityWeightedLbConfig.class, io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.LocalityWeightedLbConfig.Builder.class);
        }

        // Construct using io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.LocalityWeightedLbConfig.newBuilder()
        private Builder() {
          maybeForceBuilderInitialization();
        }

        private Builder(
            com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
          super(parent);
          maybeForceBuilderInitialization();
        }
        private void maybeForceBuilderInitialization() {
          if (com.google.protobuf.GeneratedMessageV3
                  .alwaysUseFieldBuilders) {
          }
        }
        public Builder clear() {
          super.clear();
          return this;
        }

        public com.google.protobuf.Descriptors.Descriptor
            getDescriptorForType() {
          return io.grpc.xds.shaded.envoy.api.v2.Cds.internal_static_envoy_api_v2_Cluster_CommonLbConfig_LocalityWeightedLbConfig_descriptor;
        }

        public io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.LocalityWeightedLbConfig getDefaultInstanceForType() {
          return io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.LocalityWeightedLbConfig.getDefaultInstance();
        }

        public io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.LocalityWeightedLbConfig build() {
          io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.LocalityWeightedLbConfig result = buildPartial();
          if (!result.isInitialized()) {
            throw newUninitializedMessageException(result);
          }
          return result;
        }

        public io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.LocalityWeightedLbConfig buildPartial() {
          io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.LocalityWeightedLbConfig result = new io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.LocalityWeightedLbConfig(this);
          onBuilt();
          return result;
        }

        public Builder clone() {
          return (Builder) super.clone();
        }
        public Builder setField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            java.lang.Object value) {
          return (Builder) super.setField(field, value);
        }
        public Builder clearField(
            com.google.protobuf.Descriptors.FieldDescriptor field) {
          return (Builder) super.clearField(field);
        }
        public Builder clearOneof(
            com.google.protobuf.Descriptors.OneofDescriptor oneof) {
          return (Builder) super.clearOneof(oneof);
        }
        public Builder setRepeatedField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            int index, java.lang.Object value) {
          return (Builder) super.setRepeatedField(field, index, value);
        }
        public Builder addRepeatedField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            java.lang.Object value) {
          return (Builder) super.addRepeatedField(field, value);
        }
        public Builder mergeFrom(com.google.protobuf.Message other) {
          if (other instanceof io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.LocalityWeightedLbConfig) {
            return mergeFrom((io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.LocalityWeightedLbConfig)other);
          } else {
            super.mergeFrom(other);
            return this;
          }
        }

        public Builder mergeFrom(io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.LocalityWeightedLbConfig other) {
          if (other == io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.LocalityWeightedLbConfig.getDefaultInstance()) return this;
          this.mergeUnknownFields(other.unknownFields);
          onChanged();
          return this;
        }

        public final boolean isInitialized() {
          return true;
        }

        public Builder mergeFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
          io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.LocalityWeightedLbConfig parsedMessage = null;
          try {
            parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            parsedMessage = (io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.LocalityWeightedLbConfig) e.getUnfinishedMessage();
            throw e.unwrapIOException();
          } finally {
            if (parsedMessage != null) {
              mergeFrom(parsedMessage);
            }
          }
          return this;
        }
        public final Builder setUnknownFields(
            final com.google.protobuf.UnknownFieldSet unknownFields) {
          return super.setUnknownFieldsProto3(unknownFields);
        }

        public final Builder mergeUnknownFields(
            final com.google.protobuf.UnknownFieldSet unknownFields) {
          return super.mergeUnknownFields(unknownFields);
        }


        // @@protoc_insertion_point(builder_scope:envoy.api.v2.Cluster.CommonLbConfig.LocalityWeightedLbConfig)
      }

      // @@protoc_insertion_point(class_scope:envoy.api.v2.Cluster.CommonLbConfig.LocalityWeightedLbConfig)
      private static final io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.LocalityWeightedLbConfig DEFAULT_INSTANCE;
      static {
        DEFAULT_INSTANCE = new io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.LocalityWeightedLbConfig();
      }

      public static io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.LocalityWeightedLbConfig getDefaultInstance() {
        return DEFAULT_INSTANCE;
      }

      private static final com.google.protobuf.Parser<LocalityWeightedLbConfig>
          PARSER = new com.google.protobuf.AbstractParser<LocalityWeightedLbConfig>() {
        public LocalityWeightedLbConfig parsePartialFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
          return new LocalityWeightedLbConfig(input, extensionRegistry);
        }
      };

      public static com.google.protobuf.Parser<LocalityWeightedLbConfig> parser() {
        return PARSER;
      }

      @java.lang.Override
      public com.google.protobuf.Parser<LocalityWeightedLbConfig> getParserForType() {
        return PARSER;
      }

      public io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.LocalityWeightedLbConfig getDefaultInstanceForType() {
        return DEFAULT_INSTANCE;
      }

    }

    private int localityConfigSpecifierCase_ = 0;
    private java.lang.Object localityConfigSpecifier_;
    public enum LocalityConfigSpecifierCase
        implements com.google.protobuf.Internal.EnumLite {
      ZONE_AWARE_LB_CONFIG(2),
      LOCALITY_WEIGHTED_LB_CONFIG(3),
      LOCALITYCONFIGSPECIFIER_NOT_SET(0);
      private final int value;
      private LocalityConfigSpecifierCase(int value) {
        this.value = value;
      }
      /**
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static LocalityConfigSpecifierCase valueOf(int value) {
        return forNumber(value);
      }

      public static LocalityConfigSpecifierCase forNumber(int value) {
        switch (value) {
          case 2: return ZONE_AWARE_LB_CONFIG;
          case 3: return LOCALITY_WEIGHTED_LB_CONFIG;
          case 0: return LOCALITYCONFIGSPECIFIER_NOT_SET;
          default: return null;
        }
      }
      public int getNumber() {
        return this.value;
      }
    };

    public LocalityConfigSpecifierCase
    getLocalityConfigSpecifierCase() {
      return LocalityConfigSpecifierCase.forNumber(
          localityConfigSpecifierCase_);
    }

    public static final int HEALTHY_PANIC_THRESHOLD_FIELD_NUMBER = 1;
    private io.grpc.xds.shaded.envoy.type.Percent healthyPanicThreshold_;
    /**
     * <pre>
     * Configures the :ref:`healthy panic threshold &lt;arch_overview_load_balancing_panic_threshold&gt;`.
     * If not specified, the default is 50%.
     * .. note::
     *   The specified percent will be truncated to the nearest 1%.
     * </pre>
     *
     * <code>.envoy.type.Percent healthy_panic_threshold = 1;</code>
     */
    public boolean hasHealthyPanicThreshold() {
      return healthyPanicThreshold_ != null;
    }
    /**
     * <pre>
     * Configures the :ref:`healthy panic threshold &lt;arch_overview_load_balancing_panic_threshold&gt;`.
     * If not specified, the default is 50%.
     * .. note::
     *   The specified percent will be truncated to the nearest 1%.
     * </pre>
     *
     * <code>.envoy.type.Percent healthy_panic_threshold = 1;</code>
     */
    public io.grpc.xds.shaded.envoy.type.Percent getHealthyPanicThreshold() {
      return healthyPanicThreshold_ == null ? io.grpc.xds.shaded.envoy.type.Percent.getDefaultInstance() : healthyPanicThreshold_;
    }
    /**
     * <pre>
     * Configures the :ref:`healthy panic threshold &lt;arch_overview_load_balancing_panic_threshold&gt;`.
     * If not specified, the default is 50%.
     * .. note::
     *   The specified percent will be truncated to the nearest 1%.
     * </pre>
     *
     * <code>.envoy.type.Percent healthy_panic_threshold = 1;</code>
     */
    public io.grpc.xds.shaded.envoy.type.PercentOrBuilder getHealthyPanicThresholdOrBuilder() {
      return getHealthyPanicThreshold();
    }

    public static final int ZONE_AWARE_LB_CONFIG_FIELD_NUMBER = 2;
    /**
     * <code>.envoy.api.v2.Cluster.CommonLbConfig.ZoneAwareLbConfig zone_aware_lb_config = 2;</code>
     */
    public boolean hasZoneAwareLbConfig() {
      return localityConfigSpecifierCase_ == 2;
    }
    /**
     * <code>.envoy.api.v2.Cluster.CommonLbConfig.ZoneAwareLbConfig zone_aware_lb_config = 2;</code>
     */
    public io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.ZoneAwareLbConfig getZoneAwareLbConfig() {
      if (localityConfigSpecifierCase_ == 2) {
         return (io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.ZoneAwareLbConfig) localityConfigSpecifier_;
      }
      return io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.ZoneAwareLbConfig.getDefaultInstance();
    }
    /**
     * <code>.envoy.api.v2.Cluster.CommonLbConfig.ZoneAwareLbConfig zone_aware_lb_config = 2;</code>
     */
    public io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.ZoneAwareLbConfigOrBuilder getZoneAwareLbConfigOrBuilder() {
      if (localityConfigSpecifierCase_ == 2) {
         return (io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.ZoneAwareLbConfig) localityConfigSpecifier_;
      }
      return io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.ZoneAwareLbConfig.getDefaultInstance();
    }

    public static final int LOCALITY_WEIGHTED_LB_CONFIG_FIELD_NUMBER = 3;
    /**
     * <code>.envoy.api.v2.Cluster.CommonLbConfig.LocalityWeightedLbConfig locality_weighted_lb_config = 3;</code>
     */
    public boolean hasLocalityWeightedLbConfig() {
      return localityConfigSpecifierCase_ == 3;
    }
    /**
     * <code>.envoy.api.v2.Cluster.CommonLbConfig.LocalityWeightedLbConfig locality_weighted_lb_config = 3;</code>
     */
    public io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.LocalityWeightedLbConfig getLocalityWeightedLbConfig() {
      if (localityConfigSpecifierCase_ == 3) {
         return (io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.LocalityWeightedLbConfig) localityConfigSpecifier_;
      }
      return io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.LocalityWeightedLbConfig.getDefaultInstance();
    }
    /**
     * <code>.envoy.api.v2.Cluster.CommonLbConfig.LocalityWeightedLbConfig locality_weighted_lb_config = 3;</code>
     */
    public io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.LocalityWeightedLbConfigOrBuilder getLocalityWeightedLbConfigOrBuilder() {
      if (localityConfigSpecifierCase_ == 3) {
         return (io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.LocalityWeightedLbConfig) localityConfigSpecifier_;
      }
      return io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.LocalityWeightedLbConfig.getDefaultInstance();
    }

    public static final int UPDATE_MERGE_WINDOW_FIELD_NUMBER = 4;
    private com.google.protobuf.Duration updateMergeWindow_;
    /**
     * <pre>
     * If set, all health check/weight/metadata updates that happen within this duration will be
     * merged and delivered in one shot when the duration expires. The start of the duration is when
     * the first update happens. This is useful for big clusters, with potentially noisy deploys
     * that might trigger excessive CPU usage due to a constant stream of healthcheck state changes
     * or metadata updates. The first set of updates to be seen apply immediately (e.g.: a new
     * cluster).
     * If this is not set, we default to a merge window of 1000ms. To disable it, set the merge
     * window to 0.
     * Note: merging does not apply to cluster membership changes (e.g.: adds/removes); this is
     * because merging those updates isn't currently safe. See
     * https://github.com/envoyproxy/envoy/pull/3941.
     * </pre>
     *
     * <code>.google.protobuf.Duration update_merge_window = 4;</code>
     */
    public boolean hasUpdateMergeWindow() {
      return updateMergeWindow_ != null;
    }
    /**
     * <pre>
     * If set, all health check/weight/metadata updates that happen within this duration will be
     * merged and delivered in one shot when the duration expires. The start of the duration is when
     * the first update happens. This is useful for big clusters, with potentially noisy deploys
     * that might trigger excessive CPU usage due to a constant stream of healthcheck state changes
     * or metadata updates. The first set of updates to be seen apply immediately (e.g.: a new
     * cluster).
     * If this is not set, we default to a merge window of 1000ms. To disable it, set the merge
     * window to 0.
     * Note: merging does not apply to cluster membership changes (e.g.: adds/removes); this is
     * because merging those updates isn't currently safe. See
     * https://github.com/envoyproxy/envoy/pull/3941.
     * </pre>
     *
     * <code>.google.protobuf.Duration update_merge_window = 4;</code>
     */
    public com.google.protobuf.Duration getUpdateMergeWindow() {
      return updateMergeWindow_ == null ? com.google.protobuf.Duration.getDefaultInstance() : updateMergeWindow_;
    }
    /**
     * <pre>
     * If set, all health check/weight/metadata updates that happen within this duration will be
     * merged and delivered in one shot when the duration expires. The start of the duration is when
     * the first update happens. This is useful for big clusters, with potentially noisy deploys
     * that might trigger excessive CPU usage due to a constant stream of healthcheck state changes
     * or metadata updates. The first set of updates to be seen apply immediately (e.g.: a new
     * cluster).
     * If this is not set, we default to a merge window of 1000ms. To disable it, set the merge
     * window to 0.
     * Note: merging does not apply to cluster membership changes (e.g.: adds/removes); this is
     * because merging those updates isn't currently safe. See
     * https://github.com/envoyproxy/envoy/pull/3941.
     * </pre>
     *
     * <code>.google.protobuf.Duration update_merge_window = 4;</code>
     */
    public com.google.protobuf.DurationOrBuilder getUpdateMergeWindowOrBuilder() {
      return getUpdateMergeWindow();
    }

    private byte memoizedIsInitialized = -1;
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (healthyPanicThreshold_ != null) {
        output.writeMessage(1, getHealthyPanicThreshold());
      }
      if (localityConfigSpecifierCase_ == 2) {
        output.writeMessage(2, (io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.ZoneAwareLbConfig) localityConfigSpecifier_);
      }
      if (localityConfigSpecifierCase_ == 3) {
        output.writeMessage(3, (io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.LocalityWeightedLbConfig) localityConfigSpecifier_);
      }
      if (updateMergeWindow_ != null) {
        output.writeMessage(4, getUpdateMergeWindow());
      }
      unknownFields.writeTo(output);
    }

    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (healthyPanicThreshold_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, getHealthyPanicThreshold());
      }
      if (localityConfigSpecifierCase_ == 2) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, (io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.ZoneAwareLbConfig) localityConfigSpecifier_);
      }
      if (localityConfigSpecifierCase_ == 3) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(3, (io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.LocalityWeightedLbConfig) localityConfigSpecifier_);
      }
      if (updateMergeWindow_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(4, getUpdateMergeWindow());
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig)) {
        return super.equals(obj);
      }
      io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig other = (io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig) obj;

      boolean result = true;
      result = result && (hasHealthyPanicThreshold() == other.hasHealthyPanicThreshold());
      if (hasHealthyPanicThreshold()) {
        result = result && getHealthyPanicThreshold()
            .equals(other.getHealthyPanicThreshold());
      }
      result = result && (hasUpdateMergeWindow() == other.hasUpdateMergeWindow());
      if (hasUpdateMergeWindow()) {
        result = result && getUpdateMergeWindow()
            .equals(other.getUpdateMergeWindow());
      }
      result = result && getLocalityConfigSpecifierCase().equals(
          other.getLocalityConfigSpecifierCase());
      if (!result) return false;
      switch (localityConfigSpecifierCase_) {
        case 2:
          result = result && getZoneAwareLbConfig()
              .equals(other.getZoneAwareLbConfig());
          break;
        case 3:
          result = result && getLocalityWeightedLbConfig()
              .equals(other.getLocalityWeightedLbConfig());
          break;
        case 0:
        default:
      }
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasHealthyPanicThreshold()) {
        hash = (37 * hash) + HEALTHY_PANIC_THRESHOLD_FIELD_NUMBER;
        hash = (53 * hash) + getHealthyPanicThreshold().hashCode();
      }
      if (hasUpdateMergeWindow()) {
        hash = (37 * hash) + UPDATE_MERGE_WINDOW_FIELD_NUMBER;
        hash = (53 * hash) + getUpdateMergeWindow().hashCode();
      }
      switch (localityConfigSpecifierCase_) {
        case 2:
          hash = (37 * hash) + ZONE_AWARE_LB_CONFIG_FIELD_NUMBER;
          hash = (53 * hash) + getZoneAwareLbConfig().hashCode();
          break;
        case 3:
          hash = (37 * hash) + LOCALITY_WEIGHTED_LB_CONFIG_FIELD_NUMBER;
          hash = (53 * hash) + getLocalityWeightedLbConfig().hashCode();
          break;
        case 0:
        default:
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Common configuration for all load balancer implementations.
     * </pre>
     *
     * Protobuf type {@code envoy.api.v2.Cluster.CommonLbConfig}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:envoy.api.v2.Cluster.CommonLbConfig)
        io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfigOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.grpc.xds.shaded.envoy.api.v2.Cds.internal_static_envoy_api_v2_Cluster_CommonLbConfig_descriptor;
      }

      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.grpc.xds.shaded.envoy.api.v2.Cds.internal_static_envoy_api_v2_Cluster_CommonLbConfig_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.class, io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.Builder.class);
      }

      // Construct using io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      public Builder clear() {
        super.clear();
        if (healthyPanicThresholdBuilder_ == null) {
          healthyPanicThreshold_ = null;
        } else {
          healthyPanicThreshold_ = null;
          healthyPanicThresholdBuilder_ = null;
        }
        if (updateMergeWindowBuilder_ == null) {
          updateMergeWindow_ = null;
        } else {
          updateMergeWindow_ = null;
          updateMergeWindowBuilder_ = null;
        }
        localityConfigSpecifierCase_ = 0;
        localityConfigSpecifier_ = null;
        return this;
      }

      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.grpc.xds.shaded.envoy.api.v2.Cds.internal_static_envoy_api_v2_Cluster_CommonLbConfig_descriptor;
      }

      public io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig getDefaultInstanceForType() {
        return io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.getDefaultInstance();
      }

      public io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig build() {
        io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      public io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig buildPartial() {
        io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig result = new io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig(this);
        if (healthyPanicThresholdBuilder_ == null) {
          result.healthyPanicThreshold_ = healthyPanicThreshold_;
        } else {
          result.healthyPanicThreshold_ = healthyPanicThresholdBuilder_.build();
        }
        if (localityConfigSpecifierCase_ == 2) {
          if (zoneAwareLbConfigBuilder_ == null) {
            result.localityConfigSpecifier_ = localityConfigSpecifier_;
          } else {
            result.localityConfigSpecifier_ = zoneAwareLbConfigBuilder_.build();
          }
        }
        if (localityConfigSpecifierCase_ == 3) {
          if (localityWeightedLbConfigBuilder_ == null) {
            result.localityConfigSpecifier_ = localityConfigSpecifier_;
          } else {
            result.localityConfigSpecifier_ = localityWeightedLbConfigBuilder_.build();
          }
        }
        if (updateMergeWindowBuilder_ == null) {
          result.updateMergeWindow_ = updateMergeWindow_;
        } else {
          result.updateMergeWindow_ = updateMergeWindowBuilder_.build();
        }
        result.localityConfigSpecifierCase_ = localityConfigSpecifierCase_;
        onBuilt();
        return result;
      }

      public Builder clone() {
        return (Builder) super.clone();
      }
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig) {
          return mergeFrom((io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig other) {
        if (other == io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.getDefaultInstance()) return this;
        if (other.hasHealthyPanicThreshold()) {
          mergeHealthyPanicThreshold(other.getHealthyPanicThreshold());
        }
        if (other.hasUpdateMergeWindow()) {
          mergeUpdateMergeWindow(other.getUpdateMergeWindow());
        }
        switch (other.getLocalityConfigSpecifierCase()) {
          case ZONE_AWARE_LB_CONFIG: {
            mergeZoneAwareLbConfig(other.getZoneAwareLbConfig());
            break;
          }
          case LOCALITY_WEIGHTED_LB_CONFIG: {
            mergeLocalityWeightedLbConfig(other.getLocalityWeightedLbConfig());
            break;
          }
          case LOCALITYCONFIGSPECIFIER_NOT_SET: {
            break;
          }
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      public final boolean isInitialized() {
        return true;
      }

      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int localityConfigSpecifierCase_ = 0;
      private java.lang.Object localityConfigSpecifier_;
      public LocalityConfigSpecifierCase
          getLocalityConfigSpecifierCase() {
        return LocalityConfigSpecifierCase.forNumber(
            localityConfigSpecifierCase_);
      }

      public Builder clearLocalityConfigSpecifier() {
        localityConfigSpecifierCase_ = 0;
        localityConfigSpecifier_ = null;
        onChanged();
        return this;
      }


      private io.grpc.xds.shaded.envoy.type.Percent healthyPanicThreshold_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          io.grpc.xds.shaded.envoy.type.Percent, io.grpc.xds.shaded.envoy.type.Percent.Builder, io.grpc.xds.shaded.envoy.type.PercentOrBuilder> healthyPanicThresholdBuilder_;
      /**
       * <pre>
       * Configures the :ref:`healthy panic threshold &lt;arch_overview_load_balancing_panic_threshold&gt;`.
       * If not specified, the default is 50%.
       * .. note::
       *   The specified percent will be truncated to the nearest 1%.
       * </pre>
       *
       * <code>.envoy.type.Percent healthy_panic_threshold = 1;</code>
       */
      public boolean hasHealthyPanicThreshold() {
        return healthyPanicThresholdBuilder_ != null || healthyPanicThreshold_ != null;
      }
      /**
       * <pre>
       * Configures the :ref:`healthy panic threshold &lt;arch_overview_load_balancing_panic_threshold&gt;`.
       * If not specified, the default is 50%.
       * .. note::
       *   The specified percent will be truncated to the nearest 1%.
       * </pre>
       *
       * <code>.envoy.type.Percent healthy_panic_threshold = 1;</code>
       */
      public io.grpc.xds.shaded.envoy.type.Percent getHealthyPanicThreshold() {
        if (healthyPanicThresholdBuilder_ == null) {
          return healthyPanicThreshold_ == null ? io.grpc.xds.shaded.envoy.type.Percent.getDefaultInstance() : healthyPanicThreshold_;
        } else {
          return healthyPanicThresholdBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Configures the :ref:`healthy panic threshold &lt;arch_overview_load_balancing_panic_threshold&gt;`.
       * If not specified, the default is 50%.
       * .. note::
       *   The specified percent will be truncated to the nearest 1%.
       * </pre>
       *
       * <code>.envoy.type.Percent healthy_panic_threshold = 1;</code>
       */
      public Builder setHealthyPanicThreshold(io.grpc.xds.shaded.envoy.type.Percent value) {
        if (healthyPanicThresholdBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          healthyPanicThreshold_ = value;
          onChanged();
        } else {
          healthyPanicThresholdBuilder_.setMessage(value);
        }

        return this;
      }
      /**
       * <pre>
       * Configures the :ref:`healthy panic threshold &lt;arch_overview_load_balancing_panic_threshold&gt;`.
       * If not specified, the default is 50%.
       * .. note::
       *   The specified percent will be truncated to the nearest 1%.
       * </pre>
       *
       * <code>.envoy.type.Percent healthy_panic_threshold = 1;</code>
       */
      public Builder setHealthyPanicThreshold(
          io.grpc.xds.shaded.envoy.type.Percent.Builder builderForValue) {
        if (healthyPanicThresholdBuilder_ == null) {
          healthyPanicThreshold_ = builderForValue.build();
          onChanged();
        } else {
          healthyPanicThresholdBuilder_.setMessage(builderForValue.build());
        }

        return this;
      }
      /**
       * <pre>
       * Configures the :ref:`healthy panic threshold &lt;arch_overview_load_balancing_panic_threshold&gt;`.
       * If not specified, the default is 50%.
       * .. note::
       *   The specified percent will be truncated to the nearest 1%.
       * </pre>
       *
       * <code>.envoy.type.Percent healthy_panic_threshold = 1;</code>
       */
      public Builder mergeHealthyPanicThreshold(io.grpc.xds.shaded.envoy.type.Percent value) {
        if (healthyPanicThresholdBuilder_ == null) {
          if (healthyPanicThreshold_ != null) {
            healthyPanicThreshold_ =
              io.grpc.xds.shaded.envoy.type.Percent.newBuilder(healthyPanicThreshold_).mergeFrom(value).buildPartial();
          } else {
            healthyPanicThreshold_ = value;
          }
          onChanged();
        } else {
          healthyPanicThresholdBuilder_.mergeFrom(value);
        }

        return this;
      }
      /**
       * <pre>
       * Configures the :ref:`healthy panic threshold &lt;arch_overview_load_balancing_panic_threshold&gt;`.
       * If not specified, the default is 50%.
       * .. note::
       *   The specified percent will be truncated to the nearest 1%.
       * </pre>
       *
       * <code>.envoy.type.Percent healthy_panic_threshold = 1;</code>
       */
      public Builder clearHealthyPanicThreshold() {
        if (healthyPanicThresholdBuilder_ == null) {
          healthyPanicThreshold_ = null;
          onChanged();
        } else {
          healthyPanicThreshold_ = null;
          healthyPanicThresholdBuilder_ = null;
        }

        return this;
      }
      /**
       * <pre>
       * Configures the :ref:`healthy panic threshold &lt;arch_overview_load_balancing_panic_threshold&gt;`.
       * If not specified, the default is 50%.
       * .. note::
       *   The specified percent will be truncated to the nearest 1%.
       * </pre>
       *
       * <code>.envoy.type.Percent healthy_panic_threshold = 1;</code>
       */
      public io.grpc.xds.shaded.envoy.type.Percent.Builder getHealthyPanicThresholdBuilder() {
        
        onChanged();
        return getHealthyPanicThresholdFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Configures the :ref:`healthy panic threshold &lt;arch_overview_load_balancing_panic_threshold&gt;`.
       * If not specified, the default is 50%.
       * .. note::
       *   The specified percent will be truncated to the nearest 1%.
       * </pre>
       *
       * <code>.envoy.type.Percent healthy_panic_threshold = 1;</code>
       */
      public io.grpc.xds.shaded.envoy.type.PercentOrBuilder getHealthyPanicThresholdOrBuilder() {
        if (healthyPanicThresholdBuilder_ != null) {
          return healthyPanicThresholdBuilder_.getMessageOrBuilder();
        } else {
          return healthyPanicThreshold_ == null ?
              io.grpc.xds.shaded.envoy.type.Percent.getDefaultInstance() : healthyPanicThreshold_;
        }
      }
      /**
       * <pre>
       * Configures the :ref:`healthy panic threshold &lt;arch_overview_load_balancing_panic_threshold&gt;`.
       * If not specified, the default is 50%.
       * .. note::
       *   The specified percent will be truncated to the nearest 1%.
       * </pre>
       *
       * <code>.envoy.type.Percent healthy_panic_threshold = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          io.grpc.xds.shaded.envoy.type.Percent, io.grpc.xds.shaded.envoy.type.Percent.Builder, io.grpc.xds.shaded.envoy.type.PercentOrBuilder> 
          getHealthyPanicThresholdFieldBuilder() {
        if (healthyPanicThresholdBuilder_ == null) {
          healthyPanicThresholdBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              io.grpc.xds.shaded.envoy.type.Percent, io.grpc.xds.shaded.envoy.type.Percent.Builder, io.grpc.xds.shaded.envoy.type.PercentOrBuilder>(
                  getHealthyPanicThreshold(),
                  getParentForChildren(),
                  isClean());
          healthyPanicThreshold_ = null;
        }
        return healthyPanicThresholdBuilder_;
      }

      private com.google.protobuf.SingleFieldBuilderV3<
          io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.ZoneAwareLbConfig, io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.ZoneAwareLbConfig.Builder, io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.ZoneAwareLbConfigOrBuilder> zoneAwareLbConfigBuilder_;
      /**
       * <code>.envoy.api.v2.Cluster.CommonLbConfig.ZoneAwareLbConfig zone_aware_lb_config = 2;</code>
       */
      public boolean hasZoneAwareLbConfig() {
        return localityConfigSpecifierCase_ == 2;
      }
      /**
       * <code>.envoy.api.v2.Cluster.CommonLbConfig.ZoneAwareLbConfig zone_aware_lb_config = 2;</code>
       */
      public io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.ZoneAwareLbConfig getZoneAwareLbConfig() {
        if (zoneAwareLbConfigBuilder_ == null) {
          if (localityConfigSpecifierCase_ == 2) {
            return (io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.ZoneAwareLbConfig) localityConfigSpecifier_;
          }
          return io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.ZoneAwareLbConfig.getDefaultInstance();
        } else {
          if (localityConfigSpecifierCase_ == 2) {
            return zoneAwareLbConfigBuilder_.getMessage();
          }
          return io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.ZoneAwareLbConfig.getDefaultInstance();
        }
      }
      /**
       * <code>.envoy.api.v2.Cluster.CommonLbConfig.ZoneAwareLbConfig zone_aware_lb_config = 2;</code>
       */
      public Builder setZoneAwareLbConfig(io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.ZoneAwareLbConfig value) {
        if (zoneAwareLbConfigBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          localityConfigSpecifier_ = value;
          onChanged();
        } else {
          zoneAwareLbConfigBuilder_.setMessage(value);
        }
        localityConfigSpecifierCase_ = 2;
        return this;
      }
      /**
       * <code>.envoy.api.v2.Cluster.CommonLbConfig.ZoneAwareLbConfig zone_aware_lb_config = 2;</code>
       */
      public Builder setZoneAwareLbConfig(
          io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.ZoneAwareLbConfig.Builder builderForValue) {
        if (zoneAwareLbConfigBuilder_ == null) {
          localityConfigSpecifier_ = builderForValue.build();
          onChanged();
        } else {
          zoneAwareLbConfigBuilder_.setMessage(builderForValue.build());
        }
        localityConfigSpecifierCase_ = 2;
        return this;
      }
      /**
       * <code>.envoy.api.v2.Cluster.CommonLbConfig.ZoneAwareLbConfig zone_aware_lb_config = 2;</code>
       */
      public Builder mergeZoneAwareLbConfig(io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.ZoneAwareLbConfig value) {
        if (zoneAwareLbConfigBuilder_ == null) {
          if (localityConfigSpecifierCase_ == 2 &&
              localityConfigSpecifier_ != io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.ZoneAwareLbConfig.getDefaultInstance()) {
            localityConfigSpecifier_ = io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.ZoneAwareLbConfig.newBuilder((io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.ZoneAwareLbConfig) localityConfigSpecifier_)
                .mergeFrom(value).buildPartial();
          } else {
            localityConfigSpecifier_ = value;
          }
          onChanged();
        } else {
          if (localityConfigSpecifierCase_ == 2) {
            zoneAwareLbConfigBuilder_.mergeFrom(value);
          }
          zoneAwareLbConfigBuilder_.setMessage(value);
        }
        localityConfigSpecifierCase_ = 2;
        return this;
      }
      /**
       * <code>.envoy.api.v2.Cluster.CommonLbConfig.ZoneAwareLbConfig zone_aware_lb_config = 2;</code>
       */
      public Builder clearZoneAwareLbConfig() {
        if (zoneAwareLbConfigBuilder_ == null) {
          if (localityConfigSpecifierCase_ == 2) {
            localityConfigSpecifierCase_ = 0;
            localityConfigSpecifier_ = null;
            onChanged();
          }
        } else {
          if (localityConfigSpecifierCase_ == 2) {
            localityConfigSpecifierCase_ = 0;
            localityConfigSpecifier_ = null;
          }
          zoneAwareLbConfigBuilder_.clear();
        }
        return this;
      }
      /**
       * <code>.envoy.api.v2.Cluster.CommonLbConfig.ZoneAwareLbConfig zone_aware_lb_config = 2;</code>
       */
      public io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.ZoneAwareLbConfig.Builder getZoneAwareLbConfigBuilder() {
        return getZoneAwareLbConfigFieldBuilder().getBuilder();
      }
      /**
       * <code>.envoy.api.v2.Cluster.CommonLbConfig.ZoneAwareLbConfig zone_aware_lb_config = 2;</code>
       */
      public io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.ZoneAwareLbConfigOrBuilder getZoneAwareLbConfigOrBuilder() {
        if ((localityConfigSpecifierCase_ == 2) && (zoneAwareLbConfigBuilder_ != null)) {
          return zoneAwareLbConfigBuilder_.getMessageOrBuilder();
        } else {
          if (localityConfigSpecifierCase_ == 2) {
            return (io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.ZoneAwareLbConfig) localityConfigSpecifier_;
          }
          return io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.ZoneAwareLbConfig.getDefaultInstance();
        }
      }
      /**
       * <code>.envoy.api.v2.Cluster.CommonLbConfig.ZoneAwareLbConfig zone_aware_lb_config = 2;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.ZoneAwareLbConfig, io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.ZoneAwareLbConfig.Builder, io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.ZoneAwareLbConfigOrBuilder> 
          getZoneAwareLbConfigFieldBuilder() {
        if (zoneAwareLbConfigBuilder_ == null) {
          if (!(localityConfigSpecifierCase_ == 2)) {
            localityConfigSpecifier_ = io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.ZoneAwareLbConfig.getDefaultInstance();
          }
          zoneAwareLbConfigBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.ZoneAwareLbConfig, io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.ZoneAwareLbConfig.Builder, io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.ZoneAwareLbConfigOrBuilder>(
                  (io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.ZoneAwareLbConfig) localityConfigSpecifier_,
                  getParentForChildren(),
                  isClean());
          localityConfigSpecifier_ = null;
        }
        localityConfigSpecifierCase_ = 2;
        onChanged();;
        return zoneAwareLbConfigBuilder_;
      }

      private com.google.protobuf.SingleFieldBuilderV3<
          io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.LocalityWeightedLbConfig, io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.LocalityWeightedLbConfig.Builder, io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.LocalityWeightedLbConfigOrBuilder> localityWeightedLbConfigBuilder_;
      /**
       * <code>.envoy.api.v2.Cluster.CommonLbConfig.LocalityWeightedLbConfig locality_weighted_lb_config = 3;</code>
       */
      public boolean hasLocalityWeightedLbConfig() {
        return localityConfigSpecifierCase_ == 3;
      }
      /**
       * <code>.envoy.api.v2.Cluster.CommonLbConfig.LocalityWeightedLbConfig locality_weighted_lb_config = 3;</code>
       */
      public io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.LocalityWeightedLbConfig getLocalityWeightedLbConfig() {
        if (localityWeightedLbConfigBuilder_ == null) {
          if (localityConfigSpecifierCase_ == 3) {
            return (io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.LocalityWeightedLbConfig) localityConfigSpecifier_;
          }
          return io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.LocalityWeightedLbConfig.getDefaultInstance();
        } else {
          if (localityConfigSpecifierCase_ == 3) {
            return localityWeightedLbConfigBuilder_.getMessage();
          }
          return io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.LocalityWeightedLbConfig.getDefaultInstance();
        }
      }
      /**
       * <code>.envoy.api.v2.Cluster.CommonLbConfig.LocalityWeightedLbConfig locality_weighted_lb_config = 3;</code>
       */
      public Builder setLocalityWeightedLbConfig(io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.LocalityWeightedLbConfig value) {
        if (localityWeightedLbConfigBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          localityConfigSpecifier_ = value;
          onChanged();
        } else {
          localityWeightedLbConfigBuilder_.setMessage(value);
        }
        localityConfigSpecifierCase_ = 3;
        return this;
      }
      /**
       * <code>.envoy.api.v2.Cluster.CommonLbConfig.LocalityWeightedLbConfig locality_weighted_lb_config = 3;</code>
       */
      public Builder setLocalityWeightedLbConfig(
          io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.LocalityWeightedLbConfig.Builder builderForValue) {
        if (localityWeightedLbConfigBuilder_ == null) {
          localityConfigSpecifier_ = builderForValue.build();
          onChanged();
        } else {
          localityWeightedLbConfigBuilder_.setMessage(builderForValue.build());
        }
        localityConfigSpecifierCase_ = 3;
        return this;
      }
      /**
       * <code>.envoy.api.v2.Cluster.CommonLbConfig.LocalityWeightedLbConfig locality_weighted_lb_config = 3;</code>
       */
      public Builder mergeLocalityWeightedLbConfig(io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.LocalityWeightedLbConfig value) {
        if (localityWeightedLbConfigBuilder_ == null) {
          if (localityConfigSpecifierCase_ == 3 &&
              localityConfigSpecifier_ != io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.LocalityWeightedLbConfig.getDefaultInstance()) {
            localityConfigSpecifier_ = io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.LocalityWeightedLbConfig.newBuilder((io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.LocalityWeightedLbConfig) localityConfigSpecifier_)
                .mergeFrom(value).buildPartial();
          } else {
            localityConfigSpecifier_ = value;
          }
          onChanged();
        } else {
          if (localityConfigSpecifierCase_ == 3) {
            localityWeightedLbConfigBuilder_.mergeFrom(value);
          }
          localityWeightedLbConfigBuilder_.setMessage(value);
        }
        localityConfigSpecifierCase_ = 3;
        return this;
      }
      /**
       * <code>.envoy.api.v2.Cluster.CommonLbConfig.LocalityWeightedLbConfig locality_weighted_lb_config = 3;</code>
       */
      public Builder clearLocalityWeightedLbConfig() {
        if (localityWeightedLbConfigBuilder_ == null) {
          if (localityConfigSpecifierCase_ == 3) {
            localityConfigSpecifierCase_ = 0;
            localityConfigSpecifier_ = null;
            onChanged();
          }
        } else {
          if (localityConfigSpecifierCase_ == 3) {
            localityConfigSpecifierCase_ = 0;
            localityConfigSpecifier_ = null;
          }
          localityWeightedLbConfigBuilder_.clear();
        }
        return this;
      }
      /**
       * <code>.envoy.api.v2.Cluster.CommonLbConfig.LocalityWeightedLbConfig locality_weighted_lb_config = 3;</code>
       */
      public io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.LocalityWeightedLbConfig.Builder getLocalityWeightedLbConfigBuilder() {
        return getLocalityWeightedLbConfigFieldBuilder().getBuilder();
      }
      /**
       * <code>.envoy.api.v2.Cluster.CommonLbConfig.LocalityWeightedLbConfig locality_weighted_lb_config = 3;</code>
       */
      public io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.LocalityWeightedLbConfigOrBuilder getLocalityWeightedLbConfigOrBuilder() {
        if ((localityConfigSpecifierCase_ == 3) && (localityWeightedLbConfigBuilder_ != null)) {
          return localityWeightedLbConfigBuilder_.getMessageOrBuilder();
        } else {
          if (localityConfigSpecifierCase_ == 3) {
            return (io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.LocalityWeightedLbConfig) localityConfigSpecifier_;
          }
          return io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.LocalityWeightedLbConfig.getDefaultInstance();
        }
      }
      /**
       * <code>.envoy.api.v2.Cluster.CommonLbConfig.LocalityWeightedLbConfig locality_weighted_lb_config = 3;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.LocalityWeightedLbConfig, io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.LocalityWeightedLbConfig.Builder, io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.LocalityWeightedLbConfigOrBuilder> 
          getLocalityWeightedLbConfigFieldBuilder() {
        if (localityWeightedLbConfigBuilder_ == null) {
          if (!(localityConfigSpecifierCase_ == 3)) {
            localityConfigSpecifier_ = io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.LocalityWeightedLbConfig.getDefaultInstance();
          }
          localityWeightedLbConfigBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.LocalityWeightedLbConfig, io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.LocalityWeightedLbConfig.Builder, io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.LocalityWeightedLbConfigOrBuilder>(
                  (io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.LocalityWeightedLbConfig) localityConfigSpecifier_,
                  getParentForChildren(),
                  isClean());
          localityConfigSpecifier_ = null;
        }
        localityConfigSpecifierCase_ = 3;
        onChanged();;
        return localityWeightedLbConfigBuilder_;
      }

      private com.google.protobuf.Duration updateMergeWindow_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          com.google.protobuf.Duration, com.google.protobuf.Duration.Builder, com.google.protobuf.DurationOrBuilder> updateMergeWindowBuilder_;
      /**
       * <pre>
       * If set, all health check/weight/metadata updates that happen within this duration will be
       * merged and delivered in one shot when the duration expires. The start of the duration is when
       * the first update happens. This is useful for big clusters, with potentially noisy deploys
       * that might trigger excessive CPU usage due to a constant stream of healthcheck state changes
       * or metadata updates. The first set of updates to be seen apply immediately (e.g.: a new
       * cluster).
       * If this is not set, we default to a merge window of 1000ms. To disable it, set the merge
       * window to 0.
       * Note: merging does not apply to cluster membership changes (e.g.: adds/removes); this is
       * because merging those updates isn't currently safe. See
       * https://github.com/envoyproxy/envoy/pull/3941.
       * </pre>
       *
       * <code>.google.protobuf.Duration update_merge_window = 4;</code>
       */
      public boolean hasUpdateMergeWindow() {
        return updateMergeWindowBuilder_ != null || updateMergeWindow_ != null;
      }
      /**
       * <pre>
       * If set, all health check/weight/metadata updates that happen within this duration will be
       * merged and delivered in one shot when the duration expires. The start of the duration is when
       * the first update happens. This is useful for big clusters, with potentially noisy deploys
       * that might trigger excessive CPU usage due to a constant stream of healthcheck state changes
       * or metadata updates. The first set of updates to be seen apply immediately (e.g.: a new
       * cluster).
       * If this is not set, we default to a merge window of 1000ms. To disable it, set the merge
       * window to 0.
       * Note: merging does not apply to cluster membership changes (e.g.: adds/removes); this is
       * because merging those updates isn't currently safe. See
       * https://github.com/envoyproxy/envoy/pull/3941.
       * </pre>
       *
       * <code>.google.protobuf.Duration update_merge_window = 4;</code>
       */
      public com.google.protobuf.Duration getUpdateMergeWindow() {
        if (updateMergeWindowBuilder_ == null) {
          return updateMergeWindow_ == null ? com.google.protobuf.Duration.getDefaultInstance() : updateMergeWindow_;
        } else {
          return updateMergeWindowBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * If set, all health check/weight/metadata updates that happen within this duration will be
       * merged and delivered in one shot when the duration expires. The start of the duration is when
       * the first update happens. This is useful for big clusters, with potentially noisy deploys
       * that might trigger excessive CPU usage due to a constant stream of healthcheck state changes
       * or metadata updates. The first set of updates to be seen apply immediately (e.g.: a new
       * cluster).
       * If this is not set, we default to a merge window of 1000ms. To disable it, set the merge
       * window to 0.
       * Note: merging does not apply to cluster membership changes (e.g.: adds/removes); this is
       * because merging those updates isn't currently safe. See
       * https://github.com/envoyproxy/envoy/pull/3941.
       * </pre>
       *
       * <code>.google.protobuf.Duration update_merge_window = 4;</code>
       */
      public Builder setUpdateMergeWindow(com.google.protobuf.Duration value) {
        if (updateMergeWindowBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          updateMergeWindow_ = value;
          onChanged();
        } else {
          updateMergeWindowBuilder_.setMessage(value);
        }

        return this;
      }
      /**
       * <pre>
       * If set, all health check/weight/metadata updates that happen within this duration will be
       * merged and delivered in one shot when the duration expires. The start of the duration is when
       * the first update happens. This is useful for big clusters, with potentially noisy deploys
       * that might trigger excessive CPU usage due to a constant stream of healthcheck state changes
       * or metadata updates. The first set of updates to be seen apply immediately (e.g.: a new
       * cluster).
       * If this is not set, we default to a merge window of 1000ms. To disable it, set the merge
       * window to 0.
       * Note: merging does not apply to cluster membership changes (e.g.: adds/removes); this is
       * because merging those updates isn't currently safe. See
       * https://github.com/envoyproxy/envoy/pull/3941.
       * </pre>
       *
       * <code>.google.protobuf.Duration update_merge_window = 4;</code>
       */
      public Builder setUpdateMergeWindow(
          com.google.protobuf.Duration.Builder builderForValue) {
        if (updateMergeWindowBuilder_ == null) {
          updateMergeWindow_ = builderForValue.build();
          onChanged();
        } else {
          updateMergeWindowBuilder_.setMessage(builderForValue.build());
        }

        return this;
      }
      /**
       * <pre>
       * If set, all health check/weight/metadata updates that happen within this duration will be
       * merged and delivered in one shot when the duration expires. The start of the duration is when
       * the first update happens. This is useful for big clusters, with potentially noisy deploys
       * that might trigger excessive CPU usage due to a constant stream of healthcheck state changes
       * or metadata updates. The first set of updates to be seen apply immediately (e.g.: a new
       * cluster).
       * If this is not set, we default to a merge window of 1000ms. To disable it, set the merge
       * window to 0.
       * Note: merging does not apply to cluster membership changes (e.g.: adds/removes); this is
       * because merging those updates isn't currently safe. See
       * https://github.com/envoyproxy/envoy/pull/3941.
       * </pre>
       *
       * <code>.google.protobuf.Duration update_merge_window = 4;</code>
       */
      public Builder mergeUpdateMergeWindow(com.google.protobuf.Duration value) {
        if (updateMergeWindowBuilder_ == null) {
          if (updateMergeWindow_ != null) {
            updateMergeWindow_ =
              com.google.protobuf.Duration.newBuilder(updateMergeWindow_).mergeFrom(value).buildPartial();
          } else {
            updateMergeWindow_ = value;
          }
          onChanged();
        } else {
          updateMergeWindowBuilder_.mergeFrom(value);
        }

        return this;
      }
      /**
       * <pre>
       * If set, all health check/weight/metadata updates that happen within this duration will be
       * merged and delivered in one shot when the duration expires. The start of the duration is when
       * the first update happens. This is useful for big clusters, with potentially noisy deploys
       * that might trigger excessive CPU usage due to a constant stream of healthcheck state changes
       * or metadata updates. The first set of updates to be seen apply immediately (e.g.: a new
       * cluster).
       * If this is not set, we default to a merge window of 1000ms. To disable it, set the merge
       * window to 0.
       * Note: merging does not apply to cluster membership changes (e.g.: adds/removes); this is
       * because merging those updates isn't currently safe. See
       * https://github.com/envoyproxy/envoy/pull/3941.
       * </pre>
       *
       * <code>.google.protobuf.Duration update_merge_window = 4;</code>
       */
      public Builder clearUpdateMergeWindow() {
        if (updateMergeWindowBuilder_ == null) {
          updateMergeWindow_ = null;
          onChanged();
        } else {
          updateMergeWindow_ = null;
          updateMergeWindowBuilder_ = null;
        }

        return this;
      }
      /**
       * <pre>
       * If set, all health check/weight/metadata updates that happen within this duration will be
       * merged and delivered in one shot when the duration expires. The start of the duration is when
       * the first update happens. This is useful for big clusters, with potentially noisy deploys
       * that might trigger excessive CPU usage due to a constant stream of healthcheck state changes
       * or metadata updates. The first set of updates to be seen apply immediately (e.g.: a new
       * cluster).
       * If this is not set, we default to a merge window of 1000ms. To disable it, set the merge
       * window to 0.
       * Note: merging does not apply to cluster membership changes (e.g.: adds/removes); this is
       * because merging those updates isn't currently safe. See
       * https://github.com/envoyproxy/envoy/pull/3941.
       * </pre>
       *
       * <code>.google.protobuf.Duration update_merge_window = 4;</code>
       */
      public com.google.protobuf.Duration.Builder getUpdateMergeWindowBuilder() {
        
        onChanged();
        return getUpdateMergeWindowFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * If set, all health check/weight/metadata updates that happen within this duration will be
       * merged and delivered in one shot when the duration expires. The start of the duration is when
       * the first update happens. This is useful for big clusters, with potentially noisy deploys
       * that might trigger excessive CPU usage due to a constant stream of healthcheck state changes
       * or metadata updates. The first set of updates to be seen apply immediately (e.g.: a new
       * cluster).
       * If this is not set, we default to a merge window of 1000ms. To disable it, set the merge
       * window to 0.
       * Note: merging does not apply to cluster membership changes (e.g.: adds/removes); this is
       * because merging those updates isn't currently safe. See
       * https://github.com/envoyproxy/envoy/pull/3941.
       * </pre>
       *
       * <code>.google.protobuf.Duration update_merge_window = 4;</code>
       */
      public com.google.protobuf.DurationOrBuilder getUpdateMergeWindowOrBuilder() {
        if (updateMergeWindowBuilder_ != null) {
          return updateMergeWindowBuilder_.getMessageOrBuilder();
        } else {
          return updateMergeWindow_ == null ?
              com.google.protobuf.Duration.getDefaultInstance() : updateMergeWindow_;
        }
      }
      /**
       * <pre>
       * If set, all health check/weight/metadata updates that happen within this duration will be
       * merged and delivered in one shot when the duration expires. The start of the duration is when
       * the first update happens. This is useful for big clusters, with potentially noisy deploys
       * that might trigger excessive CPU usage due to a constant stream of healthcheck state changes
       * or metadata updates. The first set of updates to be seen apply immediately (e.g.: a new
       * cluster).
       * If this is not set, we default to a merge window of 1000ms. To disable it, set the merge
       * window to 0.
       * Note: merging does not apply to cluster membership changes (e.g.: adds/removes); this is
       * because merging those updates isn't currently safe. See
       * https://github.com/envoyproxy/envoy/pull/3941.
       * </pre>
       *
       * <code>.google.protobuf.Duration update_merge_window = 4;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          com.google.protobuf.Duration, com.google.protobuf.Duration.Builder, com.google.protobuf.DurationOrBuilder> 
          getUpdateMergeWindowFieldBuilder() {
        if (updateMergeWindowBuilder_ == null) {
          updateMergeWindowBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              com.google.protobuf.Duration, com.google.protobuf.Duration.Builder, com.google.protobuf.DurationOrBuilder>(
                  getUpdateMergeWindow(),
                  getParentForChildren(),
                  isClean());
          updateMergeWindow_ = null;
        }
        return updateMergeWindowBuilder_;
      }
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFieldsProto3(unknownFields);
      }

      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:envoy.api.v2.Cluster.CommonLbConfig)
    }

    // @@protoc_insertion_point(class_scope:envoy.api.v2.Cluster.CommonLbConfig)
    private static final io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig();
    }

    public static io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<CommonLbConfig>
        PARSER = new com.google.protobuf.AbstractParser<CommonLbConfig>() {
      public CommonLbConfig parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new CommonLbConfig(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<CommonLbConfig> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<CommonLbConfig> getParserForType() {
      return PARSER;
    }

    public io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  private int bitField0_;
  private int lbConfigCase_ = 0;
  private java.lang.Object lbConfig_;
  public enum LbConfigCase
      implements com.google.protobuf.Internal.EnumLite {
    RING_HASH_LB_CONFIG(23),
    ORIGINAL_DST_LB_CONFIG(34),
    LEAST_REQUEST_LB_CONFIG(37),
    LBCONFIG_NOT_SET(0);
    private final int value;
    private LbConfigCase(int value) {
      this.value = value;
    }
    /**
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static LbConfigCase valueOf(int value) {
      return forNumber(value);
    }

    public static LbConfigCase forNumber(int value) {
      switch (value) {
        case 23: return RING_HASH_LB_CONFIG;
        case 34: return ORIGINAL_DST_LB_CONFIG;
        case 37: return LEAST_REQUEST_LB_CONFIG;
        case 0: return LBCONFIG_NOT_SET;
        default: return null;
      }
    }
    public int getNumber() {
      return this.value;
    }
  };

  public LbConfigCase
  getLbConfigCase() {
    return LbConfigCase.forNumber(
        lbConfigCase_);
  }

  public static final int NAME_FIELD_NUMBER = 1;
  private volatile java.lang.Object name_;
  /**
   * <pre>
   * Supplies the name of the cluster which must be unique across all clusters.
   * The cluster name is used when emitting
   * :ref:`statistics &lt;config_cluster_manager_cluster_stats&gt;` if :ref:`alt_stat_name
   * &lt;envoy_api_field_Cluster.alt_stat_name&gt;` is not provided.
   * Any ``:`` in the cluster name will be converted to ``_`` when emitting statistics.
   * By default, the maximum length of a cluster name is limited to 60
   * characters. This limit can be increased by setting the
   * :option:`--max-obj-name-len` command line argument to the desired value.
   * </pre>
   *
   * <code>string name = 1 [(.validate.rules) = { ... }</code>
   */
  public java.lang.String getName() {
    java.lang.Object ref = name_;
    if (ref instanceof java.lang.String) {
      return (java.lang.String) ref;
    } else {
      com.google.protobuf.ByteString bs = 
          (com.google.protobuf.ByteString) ref;
      java.lang.String s = bs.toStringUtf8();
      name_ = s;
      return s;
    }
  }
  /**
   * <pre>
   * Supplies the name of the cluster which must be unique across all clusters.
   * The cluster name is used when emitting
   * :ref:`statistics &lt;config_cluster_manager_cluster_stats&gt;` if :ref:`alt_stat_name
   * &lt;envoy_api_field_Cluster.alt_stat_name&gt;` is not provided.
   * Any ``:`` in the cluster name will be converted to ``_`` when emitting statistics.
   * By default, the maximum length of a cluster name is limited to 60
   * characters. This limit can be increased by setting the
   * :option:`--max-obj-name-len` command line argument to the desired value.
   * </pre>
   *
   * <code>string name = 1 [(.validate.rules) = { ... }</code>
   */
  public com.google.protobuf.ByteString
      getNameBytes() {
    java.lang.Object ref = name_;
    if (ref instanceof java.lang.String) {
      com.google.protobuf.ByteString b = 
          com.google.protobuf.ByteString.copyFromUtf8(
              (java.lang.String) ref);
      name_ = b;
      return b;
    } else {
      return (com.google.protobuf.ByteString) ref;
    }
  }

  public static final int ALT_STAT_NAME_FIELD_NUMBER = 28;
  private volatile java.lang.Object altStatName_;
  /**
   * <pre>
   * An optional alternative to the cluster name to be used while emitting stats.
   * Any ``:`` in the name will be converted to ``_`` when emitting statistics. This should not be
   * confused with :ref:`Router Filter Header
   * &lt;config_http_filters_router_x-envoy-upstream-alt-stat-name&gt;`.
   * </pre>
   *
   * <code>string alt_stat_name = 28;</code>
   */
  public java.lang.String getAltStatName() {
    java.lang.Object ref = altStatName_;
    if (ref instanceof java.lang.String) {
      return (java.lang.String) ref;
    } else {
      com.google.protobuf.ByteString bs = 
          (com.google.protobuf.ByteString) ref;
      java.lang.String s = bs.toStringUtf8();
      altStatName_ = s;
      return s;
    }
  }
  /**
   * <pre>
   * An optional alternative to the cluster name to be used while emitting stats.
   * Any ``:`` in the name will be converted to ``_`` when emitting statistics. This should not be
   * confused with :ref:`Router Filter Header
   * &lt;config_http_filters_router_x-envoy-upstream-alt-stat-name&gt;`.
   * </pre>
   *
   * <code>string alt_stat_name = 28;</code>
   */
  public com.google.protobuf.ByteString
      getAltStatNameBytes() {
    java.lang.Object ref = altStatName_;
    if (ref instanceof java.lang.String) {
      com.google.protobuf.ByteString b = 
          com.google.protobuf.ByteString.copyFromUtf8(
              (java.lang.String) ref);
      altStatName_ = b;
      return b;
    } else {
      return (com.google.protobuf.ByteString) ref;
    }
  }

  public static final int TYPE_FIELD_NUMBER = 2;
  private int type_;
  /**
   * <pre>
   * The :ref:`service discovery type &lt;arch_overview_service_discovery_types&gt;`
   * to use for resolving the cluster.
   * </pre>
   *
   * <code>.envoy.api.v2.Cluster.DiscoveryType type = 2 [(.validate.rules) = { ... }</code>
   */
  public int getTypeValue() {
    return type_;
  }
  /**
   * <pre>
   * The :ref:`service discovery type &lt;arch_overview_service_discovery_types&gt;`
   * to use for resolving the cluster.
   * </pre>
   *
   * <code>.envoy.api.v2.Cluster.DiscoveryType type = 2 [(.validate.rules) = { ... }</code>
   */
  public io.grpc.xds.shaded.envoy.api.v2.Cluster.DiscoveryType getType() {
    io.grpc.xds.shaded.envoy.api.v2.Cluster.DiscoveryType result = io.grpc.xds.shaded.envoy.api.v2.Cluster.DiscoveryType.valueOf(type_);
    return result == null ? io.grpc.xds.shaded.envoy.api.v2.Cluster.DiscoveryType.UNRECOGNIZED : result;
  }

  public static final int EDS_CLUSTER_CONFIG_FIELD_NUMBER = 3;
  private io.grpc.xds.shaded.envoy.api.v2.Cluster.EdsClusterConfig edsClusterConfig_;
  /**
   * <pre>
   * Configuration to use for EDS updates for the Cluster.
   * </pre>
   *
   * <code>.envoy.api.v2.Cluster.EdsClusterConfig eds_cluster_config = 3;</code>
   */
  public boolean hasEdsClusterConfig() {
    return edsClusterConfig_ != null;
  }
  /**
   * <pre>
   * Configuration to use for EDS updates for the Cluster.
   * </pre>
   *
   * <code>.envoy.api.v2.Cluster.EdsClusterConfig eds_cluster_config = 3;</code>
   */
  public io.grpc.xds.shaded.envoy.api.v2.Cluster.EdsClusterConfig getEdsClusterConfig() {
    return edsClusterConfig_ == null ? io.grpc.xds.shaded.envoy.api.v2.Cluster.EdsClusterConfig.getDefaultInstance() : edsClusterConfig_;
  }
  /**
   * <pre>
   * Configuration to use for EDS updates for the Cluster.
   * </pre>
   *
   * <code>.envoy.api.v2.Cluster.EdsClusterConfig eds_cluster_config = 3;</code>
   */
  public io.grpc.xds.shaded.envoy.api.v2.Cluster.EdsClusterConfigOrBuilder getEdsClusterConfigOrBuilder() {
    return getEdsClusterConfig();
  }

  public static final int CONNECT_TIMEOUT_FIELD_NUMBER = 4;
  private com.google.protobuf.Duration connectTimeout_;
  /**
   * <pre>
   * The timeout for new network connections to hosts in the cluster.
   * </pre>
   *
   * <code>.google.protobuf.Duration connect_timeout = 4 [(.validate.rules) = { ... }</code>
   */
  public boolean hasConnectTimeout() {
    return connectTimeout_ != null;
  }
  /**
   * <pre>
   * The timeout for new network connections to hosts in the cluster.
   * </pre>
   *
   * <code>.google.protobuf.Duration connect_timeout = 4 [(.validate.rules) = { ... }</code>
   */
  public com.google.protobuf.Duration getConnectTimeout() {
    return connectTimeout_ == null ? com.google.protobuf.Duration.getDefaultInstance() : connectTimeout_;
  }
  /**
   * <pre>
   * The timeout for new network connections to hosts in the cluster.
   * </pre>
   *
   * <code>.google.protobuf.Duration connect_timeout = 4 [(.validate.rules) = { ... }</code>
   */
  public com.google.protobuf.DurationOrBuilder getConnectTimeoutOrBuilder() {
    return getConnectTimeout();
  }

  public static final int PER_CONNECTION_BUFFER_LIMIT_BYTES_FIELD_NUMBER = 5;
  private com.google.protobuf.UInt32Value perConnectionBufferLimitBytes_;
  /**
   * <pre>
   * Soft limit on size of the clusters connections read and write buffers. If
   * unspecified, an implementation defined default is applied (1MiB).
   * </pre>
   *
   * <code>.google.protobuf.UInt32Value per_connection_buffer_limit_bytes = 5;</code>
   */
  public boolean hasPerConnectionBufferLimitBytes() {
    return perConnectionBufferLimitBytes_ != null;
  }
  /**
   * <pre>
   * Soft limit on size of the clusters connections read and write buffers. If
   * unspecified, an implementation defined default is applied (1MiB).
   * </pre>
   *
   * <code>.google.protobuf.UInt32Value per_connection_buffer_limit_bytes = 5;</code>
   */
  public com.google.protobuf.UInt32Value getPerConnectionBufferLimitBytes() {
    return perConnectionBufferLimitBytes_ == null ? com.google.protobuf.UInt32Value.getDefaultInstance() : perConnectionBufferLimitBytes_;
  }
  /**
   * <pre>
   * Soft limit on size of the clusters connections read and write buffers. If
   * unspecified, an implementation defined default is applied (1MiB).
   * </pre>
   *
   * <code>.google.protobuf.UInt32Value per_connection_buffer_limit_bytes = 5;</code>
   */
  public com.google.protobuf.UInt32ValueOrBuilder getPerConnectionBufferLimitBytesOrBuilder() {
    return getPerConnectionBufferLimitBytes();
  }

  public static final int LB_POLICY_FIELD_NUMBER = 6;
  private int lbPolicy_;
  /**
   * <pre>
   * The :ref:`load balancer type &lt;arch_overview_load_balancing_types&gt;` to use
   * when picking a host in the cluster.
   * </pre>
   *
   * <code>.envoy.api.v2.Cluster.LbPolicy lb_policy = 6 [(.validate.rules) = { ... }</code>
   */
  public int getLbPolicyValue() {
    return lbPolicy_;
  }
  /**
   * <pre>
   * The :ref:`load balancer type &lt;arch_overview_load_balancing_types&gt;` to use
   * when picking a host in the cluster.
   * </pre>
   *
   * <code>.envoy.api.v2.Cluster.LbPolicy lb_policy = 6 [(.validate.rules) = { ... }</code>
   */
  public io.grpc.xds.shaded.envoy.api.v2.Cluster.LbPolicy getLbPolicy() {
    io.grpc.xds.shaded.envoy.api.v2.Cluster.LbPolicy result = io.grpc.xds.shaded.envoy.api.v2.Cluster.LbPolicy.valueOf(lbPolicy_);
    return result == null ? io.grpc.xds.shaded.envoy.api.v2.Cluster.LbPolicy.UNRECOGNIZED : result;
  }

  public static final int HOSTS_FIELD_NUMBER = 7;
  private java.util.List<io.grpc.xds.shaded.envoy.api.v2.core.Address> hosts_;
  /**
   * <pre>
   * If the service discovery type is
   * :ref:`STATIC&lt;envoy_api_enum_value_Cluster.DiscoveryType.STATIC&gt;`,
   * :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS&gt;`
   * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS&gt;`,
   * then hosts is required.
   * .. attention::
   *   **This field is deprecated**. Set the
   *   :ref:`load_assignment&lt;envoy_api_field_Cluster.load_assignment&gt;` field instead.
   * </pre>
   *
   * <code>repeated .envoy.api.v2.core.Address hosts = 7 [deprecated = true];</code>
   */
  @java.lang.Deprecated public java.util.List<io.grpc.xds.shaded.envoy.api.v2.core.Address> getHostsList() {
    return hosts_;
  }
  /**
   * <pre>
   * If the service discovery type is
   * :ref:`STATIC&lt;envoy_api_enum_value_Cluster.DiscoveryType.STATIC&gt;`,
   * :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS&gt;`
   * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS&gt;`,
   * then hosts is required.
   * .. attention::
   *   **This field is deprecated**. Set the
   *   :ref:`load_assignment&lt;envoy_api_field_Cluster.load_assignment&gt;` field instead.
   * </pre>
   *
   * <code>repeated .envoy.api.v2.core.Address hosts = 7 [deprecated = true];</code>
   */
  @java.lang.Deprecated public java.util.List<? extends io.grpc.xds.shaded.envoy.api.v2.core.AddressOrBuilder> 
      getHostsOrBuilderList() {
    return hosts_;
  }
  /**
   * <pre>
   * If the service discovery type is
   * :ref:`STATIC&lt;envoy_api_enum_value_Cluster.DiscoveryType.STATIC&gt;`,
   * :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS&gt;`
   * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS&gt;`,
   * then hosts is required.
   * .. attention::
   *   **This field is deprecated**. Set the
   *   :ref:`load_assignment&lt;envoy_api_field_Cluster.load_assignment&gt;` field instead.
   * </pre>
   *
   * <code>repeated .envoy.api.v2.core.Address hosts = 7 [deprecated = true];</code>
   */
  @java.lang.Deprecated public int getHostsCount() {
    return hosts_.size();
  }
  /**
   * <pre>
   * If the service discovery type is
   * :ref:`STATIC&lt;envoy_api_enum_value_Cluster.DiscoveryType.STATIC&gt;`,
   * :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS&gt;`
   * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS&gt;`,
   * then hosts is required.
   * .. attention::
   *   **This field is deprecated**. Set the
   *   :ref:`load_assignment&lt;envoy_api_field_Cluster.load_assignment&gt;` field instead.
   * </pre>
   *
   * <code>repeated .envoy.api.v2.core.Address hosts = 7 [deprecated = true];</code>
   */
  @java.lang.Deprecated public io.grpc.xds.shaded.envoy.api.v2.core.Address getHosts(int index) {
    return hosts_.get(index);
  }
  /**
   * <pre>
   * If the service discovery type is
   * :ref:`STATIC&lt;envoy_api_enum_value_Cluster.DiscoveryType.STATIC&gt;`,
   * :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS&gt;`
   * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS&gt;`,
   * then hosts is required.
   * .. attention::
   *   **This field is deprecated**. Set the
   *   :ref:`load_assignment&lt;envoy_api_field_Cluster.load_assignment&gt;` field instead.
   * </pre>
   *
   * <code>repeated .envoy.api.v2.core.Address hosts = 7 [deprecated = true];</code>
   */
  @java.lang.Deprecated public io.grpc.xds.shaded.envoy.api.v2.core.AddressOrBuilder getHostsOrBuilder(
      int index) {
    return hosts_.get(index);
  }

  public static final int LOAD_ASSIGNMENT_FIELD_NUMBER = 33;
  private io.grpc.xds.shaded.envoy.api.v2.ClusterLoadAssignment loadAssignment_;
  /**
   * <pre>
   * Setting this is required for specifying members of
   * :ref:`STATIC&lt;envoy_api_enum_value_Cluster.DiscoveryType.STATIC&gt;`,
   * :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS&gt;`
   * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS&gt;` clusters.
   * This field supersedes :ref:`hosts&lt;envoy_api_field_Cluster.hosts&gt;` field.
   * [#comment:TODO(dio): Deprecate the hosts field and add it to DEPRECATED.md
   * once load_assignment is implemented.]
   * .. attention::
   *   Setting this allows non-EDS cluster types to contain embedded EDS equivalent
   *   :ref:`endpoint assignments&lt;envoy_api_msg_ClusterLoadAssignment&gt;`.
   *   Setting this overrides :ref:`hosts&lt;envoy_api_field_Cluster.hosts&gt;` values.
   * </pre>
   *
   * <code>.envoy.api.v2.ClusterLoadAssignment load_assignment = 33;</code>
   */
  public boolean hasLoadAssignment() {
    return loadAssignment_ != null;
  }
  /**
   * <pre>
   * Setting this is required for specifying members of
   * :ref:`STATIC&lt;envoy_api_enum_value_Cluster.DiscoveryType.STATIC&gt;`,
   * :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS&gt;`
   * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS&gt;` clusters.
   * This field supersedes :ref:`hosts&lt;envoy_api_field_Cluster.hosts&gt;` field.
   * [#comment:TODO(dio): Deprecate the hosts field and add it to DEPRECATED.md
   * once load_assignment is implemented.]
   * .. attention::
   *   Setting this allows non-EDS cluster types to contain embedded EDS equivalent
   *   :ref:`endpoint assignments&lt;envoy_api_msg_ClusterLoadAssignment&gt;`.
   *   Setting this overrides :ref:`hosts&lt;envoy_api_field_Cluster.hosts&gt;` values.
   * </pre>
   *
   * <code>.envoy.api.v2.ClusterLoadAssignment load_assignment = 33;</code>
   */
  public io.grpc.xds.shaded.envoy.api.v2.ClusterLoadAssignment getLoadAssignment() {
    return loadAssignment_ == null ? io.grpc.xds.shaded.envoy.api.v2.ClusterLoadAssignment.getDefaultInstance() : loadAssignment_;
  }
  /**
   * <pre>
   * Setting this is required for specifying members of
   * :ref:`STATIC&lt;envoy_api_enum_value_Cluster.DiscoveryType.STATIC&gt;`,
   * :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS&gt;`
   * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS&gt;` clusters.
   * This field supersedes :ref:`hosts&lt;envoy_api_field_Cluster.hosts&gt;` field.
   * [#comment:TODO(dio): Deprecate the hosts field and add it to DEPRECATED.md
   * once load_assignment is implemented.]
   * .. attention::
   *   Setting this allows non-EDS cluster types to contain embedded EDS equivalent
   *   :ref:`endpoint assignments&lt;envoy_api_msg_ClusterLoadAssignment&gt;`.
   *   Setting this overrides :ref:`hosts&lt;envoy_api_field_Cluster.hosts&gt;` values.
   * </pre>
   *
   * <code>.envoy.api.v2.ClusterLoadAssignment load_assignment = 33;</code>
   */
  public io.grpc.xds.shaded.envoy.api.v2.ClusterLoadAssignmentOrBuilder getLoadAssignmentOrBuilder() {
    return getLoadAssignment();
  }

  public static final int HEALTH_CHECKS_FIELD_NUMBER = 8;
  private java.util.List<io.grpc.xds.shaded.envoy.api.v2.core.HealthCheck> healthChecks_;
  /**
   * <pre>
   * Optional :ref:`active health checking &lt;arch_overview_health_checking&gt;`
   * configuration for the cluster. If no
   * configuration is specified no health checking will be done and all cluster
   * members will be considered healthy at all times.
   * </pre>
   *
   * <code>repeated .envoy.api.v2.core.HealthCheck health_checks = 8;</code>
   */
  public java.util.List<io.grpc.xds.shaded.envoy.api.v2.core.HealthCheck> getHealthChecksList() {
    return healthChecks_;
  }
  /**
   * <pre>
   * Optional :ref:`active health checking &lt;arch_overview_health_checking&gt;`
   * configuration for the cluster. If no
   * configuration is specified no health checking will be done and all cluster
   * members will be considered healthy at all times.
   * </pre>
   *
   * <code>repeated .envoy.api.v2.core.HealthCheck health_checks = 8;</code>
   */
  public java.util.List<? extends io.grpc.xds.shaded.envoy.api.v2.core.HealthCheckOrBuilder> 
      getHealthChecksOrBuilderList() {
    return healthChecks_;
  }
  /**
   * <pre>
   * Optional :ref:`active health checking &lt;arch_overview_health_checking&gt;`
   * configuration for the cluster. If no
   * configuration is specified no health checking will be done and all cluster
   * members will be considered healthy at all times.
   * </pre>
   *
   * <code>repeated .envoy.api.v2.core.HealthCheck health_checks = 8;</code>
   */
  public int getHealthChecksCount() {
    return healthChecks_.size();
  }
  /**
   * <pre>
   * Optional :ref:`active health checking &lt;arch_overview_health_checking&gt;`
   * configuration for the cluster. If no
   * configuration is specified no health checking will be done and all cluster
   * members will be considered healthy at all times.
   * </pre>
   *
   * <code>repeated .envoy.api.v2.core.HealthCheck health_checks = 8;</code>
   */
  public io.grpc.xds.shaded.envoy.api.v2.core.HealthCheck getHealthChecks(int index) {
    return healthChecks_.get(index);
  }
  /**
   * <pre>
   * Optional :ref:`active health checking &lt;arch_overview_health_checking&gt;`
   * configuration for the cluster. If no
   * configuration is specified no health checking will be done and all cluster
   * members will be considered healthy at all times.
   * </pre>
   *
   * <code>repeated .envoy.api.v2.core.HealthCheck health_checks = 8;</code>
   */
  public io.grpc.xds.shaded.envoy.api.v2.core.HealthCheckOrBuilder getHealthChecksOrBuilder(
      int index) {
    return healthChecks_.get(index);
  }

  public static final int MAX_REQUESTS_PER_CONNECTION_FIELD_NUMBER = 9;
  private com.google.protobuf.UInt32Value maxRequestsPerConnection_;
  /**
   * <pre>
   * Optional maximum requests for a single upstream connection. This parameter
   * is respected by both the HTTP/1.1 and HTTP/2 connection pool
   * implementations. If not specified, there is no limit. Setting this
   * parameter to 1 will effectively disable keep alive.
   * </pre>
   *
   * <code>.google.protobuf.UInt32Value max_requests_per_connection = 9;</code>
   */
  public boolean hasMaxRequestsPerConnection() {
    return maxRequestsPerConnection_ != null;
  }
  /**
   * <pre>
   * Optional maximum requests for a single upstream connection. This parameter
   * is respected by both the HTTP/1.1 and HTTP/2 connection pool
   * implementations. If not specified, there is no limit. Setting this
   * parameter to 1 will effectively disable keep alive.
   * </pre>
   *
   * <code>.google.protobuf.UInt32Value max_requests_per_connection = 9;</code>
   */
  public com.google.protobuf.UInt32Value getMaxRequestsPerConnection() {
    return maxRequestsPerConnection_ == null ? com.google.protobuf.UInt32Value.getDefaultInstance() : maxRequestsPerConnection_;
  }
  /**
   * <pre>
   * Optional maximum requests for a single upstream connection. This parameter
   * is respected by both the HTTP/1.1 and HTTP/2 connection pool
   * implementations. If not specified, there is no limit. Setting this
   * parameter to 1 will effectively disable keep alive.
   * </pre>
   *
   * <code>.google.protobuf.UInt32Value max_requests_per_connection = 9;</code>
   */
  public com.google.protobuf.UInt32ValueOrBuilder getMaxRequestsPerConnectionOrBuilder() {
    return getMaxRequestsPerConnection();
  }

  public static final int CIRCUIT_BREAKERS_FIELD_NUMBER = 10;
  private io.grpc.xds.shaded.envoy.api.v2.cluster.CircuitBreakers circuitBreakers_;
  /**
   * <pre>
   * Optional :ref:`circuit breaking &lt;arch_overview_circuit_break&gt;` for the cluster.
   * </pre>
   *
   * <code>.envoy.api.v2.cluster.CircuitBreakers circuit_breakers = 10;</code>
   */
  public boolean hasCircuitBreakers() {
    return circuitBreakers_ != null;
  }
  /**
   * <pre>
   * Optional :ref:`circuit breaking &lt;arch_overview_circuit_break&gt;` for the cluster.
   * </pre>
   *
   * <code>.envoy.api.v2.cluster.CircuitBreakers circuit_breakers = 10;</code>
   */
  public io.grpc.xds.shaded.envoy.api.v2.cluster.CircuitBreakers getCircuitBreakers() {
    return circuitBreakers_ == null ? io.grpc.xds.shaded.envoy.api.v2.cluster.CircuitBreakers.getDefaultInstance() : circuitBreakers_;
  }
  /**
   * <pre>
   * Optional :ref:`circuit breaking &lt;arch_overview_circuit_break&gt;` for the cluster.
   * </pre>
   *
   * <code>.envoy.api.v2.cluster.CircuitBreakers circuit_breakers = 10;</code>
   */
  public io.grpc.xds.shaded.envoy.api.v2.cluster.CircuitBreakersOrBuilder getCircuitBreakersOrBuilder() {
    return getCircuitBreakers();
  }

  public static final int TLS_CONTEXT_FIELD_NUMBER = 11;
  private io.grpc.xds.shaded.envoy.api.v2.auth.UpstreamTlsContext tlsContext_;
  /**
   * <pre>
   * The TLS configuration for connections to the upstream cluster. If no TLS
   * configuration is specified, TLS will not be used for new connections.
   * .. attention::
   *   Server certificate verification is not enabled by default. Configure
   *   :ref:`trusted_ca&lt;envoy_api_field_auth.CertificateValidationContext.trusted_ca&gt;` to enable
   *   verification.
   * </pre>
   *
   * <code>.envoy.api.v2.auth.UpstreamTlsContext tls_context = 11;</code>
   */
  public boolean hasTlsContext() {
    return tlsContext_ != null;
  }
  /**
   * <pre>
   * The TLS configuration for connections to the upstream cluster. If no TLS
   * configuration is specified, TLS will not be used for new connections.
   * .. attention::
   *   Server certificate verification is not enabled by default. Configure
   *   :ref:`trusted_ca&lt;envoy_api_field_auth.CertificateValidationContext.trusted_ca&gt;` to enable
   *   verification.
   * </pre>
   *
   * <code>.envoy.api.v2.auth.UpstreamTlsContext tls_context = 11;</code>
   */
  public io.grpc.xds.shaded.envoy.api.v2.auth.UpstreamTlsContext getTlsContext() {
    return tlsContext_ == null ? io.grpc.xds.shaded.envoy.api.v2.auth.UpstreamTlsContext.getDefaultInstance() : tlsContext_;
  }
  /**
   * <pre>
   * The TLS configuration for connections to the upstream cluster. If no TLS
   * configuration is specified, TLS will not be used for new connections.
   * .. attention::
   *   Server certificate verification is not enabled by default. Configure
   *   :ref:`trusted_ca&lt;envoy_api_field_auth.CertificateValidationContext.trusted_ca&gt;` to enable
   *   verification.
   * </pre>
   *
   * <code>.envoy.api.v2.auth.UpstreamTlsContext tls_context = 11;</code>
   */
  public io.grpc.xds.shaded.envoy.api.v2.auth.UpstreamTlsContextOrBuilder getTlsContextOrBuilder() {
    return getTlsContext();
  }

  public static final int COMMON_HTTP_PROTOCOL_OPTIONS_FIELD_NUMBER = 29;
  private io.grpc.xds.shaded.envoy.api.v2.core.HttpProtocolOptions commonHttpProtocolOptions_;
  /**
   * <pre>
   * Additional options when handling HTTP requests. These options will be applicable to both
   * HTTP1 and HTTP2 requests.
   * </pre>
   *
   * <code>.envoy.api.v2.core.HttpProtocolOptions common_http_protocol_options = 29;</code>
   */
  public boolean hasCommonHttpProtocolOptions() {
    return commonHttpProtocolOptions_ != null;
  }
  /**
   * <pre>
   * Additional options when handling HTTP requests. These options will be applicable to both
   * HTTP1 and HTTP2 requests.
   * </pre>
   *
   * <code>.envoy.api.v2.core.HttpProtocolOptions common_http_protocol_options = 29;</code>
   */
  public io.grpc.xds.shaded.envoy.api.v2.core.HttpProtocolOptions getCommonHttpProtocolOptions() {
    return commonHttpProtocolOptions_ == null ? io.grpc.xds.shaded.envoy.api.v2.core.HttpProtocolOptions.getDefaultInstance() : commonHttpProtocolOptions_;
  }
  /**
   * <pre>
   * Additional options when handling HTTP requests. These options will be applicable to both
   * HTTP1 and HTTP2 requests.
   * </pre>
   *
   * <code>.envoy.api.v2.core.HttpProtocolOptions common_http_protocol_options = 29;</code>
   */
  public io.grpc.xds.shaded.envoy.api.v2.core.HttpProtocolOptionsOrBuilder getCommonHttpProtocolOptionsOrBuilder() {
    return getCommonHttpProtocolOptions();
  }

  public static final int HTTP_PROTOCOL_OPTIONS_FIELD_NUMBER = 13;
  private io.grpc.xds.shaded.envoy.api.v2.core.Http1ProtocolOptions httpProtocolOptions_;
  /**
   * <pre>
   * Additional options when handling HTTP1 requests.
   * </pre>
   *
   * <code>.envoy.api.v2.core.Http1ProtocolOptions http_protocol_options = 13;</code>
   */
  public boolean hasHttpProtocolOptions() {
    return httpProtocolOptions_ != null;
  }
  /**
   * <pre>
   * Additional options when handling HTTP1 requests.
   * </pre>
   *
   * <code>.envoy.api.v2.core.Http1ProtocolOptions http_protocol_options = 13;</code>
   */
  public io.grpc.xds.shaded.envoy.api.v2.core.Http1ProtocolOptions getHttpProtocolOptions() {
    return httpProtocolOptions_ == null ? io.grpc.xds.shaded.envoy.api.v2.core.Http1ProtocolOptions.getDefaultInstance() : httpProtocolOptions_;
  }
  /**
   * <pre>
   * Additional options when handling HTTP1 requests.
   * </pre>
   *
   * <code>.envoy.api.v2.core.Http1ProtocolOptions http_protocol_options = 13;</code>
   */
  public io.grpc.xds.shaded.envoy.api.v2.core.Http1ProtocolOptionsOrBuilder getHttpProtocolOptionsOrBuilder() {
    return getHttpProtocolOptions();
  }

  public static final int HTTP2_PROTOCOL_OPTIONS_FIELD_NUMBER = 14;
  private io.grpc.xds.shaded.envoy.api.v2.core.Http2ProtocolOptions http2ProtocolOptions_;
  /**
   * <pre>
   * Even if default HTTP2 protocol options are desired, this field must be
   * set so that Envoy will assume that the upstream supports HTTP/2 when
   * making new HTTP connection pool connections. Currently, Envoy only
   * supports prior knowledge for upstream connections. Even if TLS is used
   * with ALPN, `http2_protocol_options` must be specified. As an aside this allows HTTP/2
   * connections to happen over plain text.
   * </pre>
   *
   * <code>.envoy.api.v2.core.Http2ProtocolOptions http2_protocol_options = 14;</code>
   */
  public boolean hasHttp2ProtocolOptions() {
    return http2ProtocolOptions_ != null;
  }
  /**
   * <pre>
   * Even if default HTTP2 protocol options are desired, this field must be
   * set so that Envoy will assume that the upstream supports HTTP/2 when
   * making new HTTP connection pool connections. Currently, Envoy only
   * supports prior knowledge for upstream connections. Even if TLS is used
   * with ALPN, `http2_protocol_options` must be specified. As an aside this allows HTTP/2
   * connections to happen over plain text.
   * </pre>
   *
   * <code>.envoy.api.v2.core.Http2ProtocolOptions http2_protocol_options = 14;</code>
   */
  public io.grpc.xds.shaded.envoy.api.v2.core.Http2ProtocolOptions getHttp2ProtocolOptions() {
    return http2ProtocolOptions_ == null ? io.grpc.xds.shaded.envoy.api.v2.core.Http2ProtocolOptions.getDefaultInstance() : http2ProtocolOptions_;
  }
  /**
   * <pre>
   * Even if default HTTP2 protocol options are desired, this field must be
   * set so that Envoy will assume that the upstream supports HTTP/2 when
   * making new HTTP connection pool connections. Currently, Envoy only
   * supports prior knowledge for upstream connections. Even if TLS is used
   * with ALPN, `http2_protocol_options` must be specified. As an aside this allows HTTP/2
   * connections to happen over plain text.
   * </pre>
   *
   * <code>.envoy.api.v2.core.Http2ProtocolOptions http2_protocol_options = 14;</code>
   */
  public io.grpc.xds.shaded.envoy.api.v2.core.Http2ProtocolOptionsOrBuilder getHttp2ProtocolOptionsOrBuilder() {
    return getHttp2ProtocolOptions();
  }

  public static final int EXTENSION_PROTOCOL_OPTIONS_FIELD_NUMBER = 35;
  private static final class ExtensionProtocolOptionsDefaultEntryHolder {
    static final com.google.protobuf.MapEntry<
        java.lang.String, com.google.protobuf.Struct> defaultEntry =
            com.google.protobuf.MapEntry
            .<java.lang.String, com.google.protobuf.Struct>newDefaultInstance(
                io.grpc.xds.shaded.envoy.api.v2.Cds.internal_static_envoy_api_v2_Cluster_ExtensionProtocolOptionsEntry_descriptor, 
                com.google.protobuf.WireFormat.FieldType.STRING,
                "",
                com.google.protobuf.WireFormat.FieldType.MESSAGE,
                com.google.protobuf.Struct.getDefaultInstance());
  }
  private com.google.protobuf.MapField<
      java.lang.String, com.google.protobuf.Struct> extensionProtocolOptions_;
  private com.google.protobuf.MapField<java.lang.String, com.google.protobuf.Struct>
  internalGetExtensionProtocolOptions() {
    if (extensionProtocolOptions_ == null) {
      return com.google.protobuf.MapField.emptyMapField(
          ExtensionProtocolOptionsDefaultEntryHolder.defaultEntry);
    }
    return extensionProtocolOptions_;
  }

  public int getExtensionProtocolOptionsCount() {
    return internalGetExtensionProtocolOptions().getMap().size();
  }
  /**
   * <pre>
   * The extension_protocol_options field is used to provide extension-specific protocol options
   * for upstream connections. The key should match the extension filter name, such as
   * "envoy.filters.network.thrift_proxy". See the extension's documentation for details on
   * specific options.
   * </pre>
   *
   * <code>map&lt;string, .google.protobuf.Struct&gt; extension_protocol_options = 35;</code>
   */

  public boolean containsExtensionProtocolOptions(
      java.lang.String key) {
    if (key == null) { throw new java.lang.NullPointerException(); }
    return internalGetExtensionProtocolOptions().getMap().containsKey(key);
  }
  /**
   * Use {@link #getExtensionProtocolOptionsMap()} instead.
   */
  @java.lang.Deprecated
  public java.util.Map<java.lang.String, com.google.protobuf.Struct> getExtensionProtocolOptions() {
    return getExtensionProtocolOptionsMap();
  }
  /**
   * <pre>
   * The extension_protocol_options field is used to provide extension-specific protocol options
   * for upstream connections. The key should match the extension filter name, such as
   * "envoy.filters.network.thrift_proxy". See the extension's documentation for details on
   * specific options.
   * </pre>
   *
   * <code>map&lt;string, .google.protobuf.Struct&gt; extension_protocol_options = 35;</code>
   */

  public java.util.Map<java.lang.String, com.google.protobuf.Struct> getExtensionProtocolOptionsMap() {
    return internalGetExtensionProtocolOptions().getMap();
  }
  /**
   * <pre>
   * The extension_protocol_options field is used to provide extension-specific protocol options
   * for upstream connections. The key should match the extension filter name, such as
   * "envoy.filters.network.thrift_proxy". See the extension's documentation for details on
   * specific options.
   * </pre>
   *
   * <code>map&lt;string, .google.protobuf.Struct&gt; extension_protocol_options = 35;</code>
   */

  public com.google.protobuf.Struct getExtensionProtocolOptionsOrDefault(
      java.lang.String key,
      com.google.protobuf.Struct defaultValue) {
    if (key == null) { throw new java.lang.NullPointerException(); }
    java.util.Map<java.lang.String, com.google.protobuf.Struct> map =
        internalGetExtensionProtocolOptions().getMap();
    return map.containsKey(key) ? map.get(key) : defaultValue;
  }
  /**
   * <pre>
   * The extension_protocol_options field is used to provide extension-specific protocol options
   * for upstream connections. The key should match the extension filter name, such as
   * "envoy.filters.network.thrift_proxy". See the extension's documentation for details on
   * specific options.
   * </pre>
   *
   * <code>map&lt;string, .google.protobuf.Struct&gt; extension_protocol_options = 35;</code>
   */

  public com.google.protobuf.Struct getExtensionProtocolOptionsOrThrow(
      java.lang.String key) {
    if (key == null) { throw new java.lang.NullPointerException(); }
    java.util.Map<java.lang.String, com.google.protobuf.Struct> map =
        internalGetExtensionProtocolOptions().getMap();
    if (!map.containsKey(key)) {
      throw new java.lang.IllegalArgumentException();
    }
    return map.get(key);
  }

  public static final int TYPED_EXTENSION_PROTOCOL_OPTIONS_FIELD_NUMBER = 36;
  private static final class TypedExtensionProtocolOptionsDefaultEntryHolder {
    static final com.google.protobuf.MapEntry<
        java.lang.String, com.google.protobuf.Any> defaultEntry =
            com.google.protobuf.MapEntry
            .<java.lang.String, com.google.protobuf.Any>newDefaultInstance(
                io.grpc.xds.shaded.envoy.api.v2.Cds.internal_static_envoy_api_v2_Cluster_TypedExtensionProtocolOptionsEntry_descriptor, 
                com.google.protobuf.WireFormat.FieldType.STRING,
                "",
                com.google.protobuf.WireFormat.FieldType.MESSAGE,
                com.google.protobuf.Any.getDefaultInstance());
  }
  private com.google.protobuf.MapField<
      java.lang.String, com.google.protobuf.Any> typedExtensionProtocolOptions_;
  private com.google.protobuf.MapField<java.lang.String, com.google.protobuf.Any>
  internalGetTypedExtensionProtocolOptions() {
    if (typedExtensionProtocolOptions_ == null) {
      return com.google.protobuf.MapField.emptyMapField(
          TypedExtensionProtocolOptionsDefaultEntryHolder.defaultEntry);
    }
    return typedExtensionProtocolOptions_;
  }

  public int getTypedExtensionProtocolOptionsCount() {
    return internalGetTypedExtensionProtocolOptions().getMap().size();
  }
  /**
   * <pre>
   * [#not-implemented-hide:]
   * The extension_protocol_options field is used to provide extension-specific protocol options
   * for upstream connections. The key should match the extension filter name, such as
   * "envoy.filters.network.thrift_proxy". See the extension's documentation for details on
   * specific options.
   * </pre>
   *
   * <code>map&lt;string, .google.protobuf.Any&gt; typed_extension_protocol_options = 36;</code>
   */

  public boolean containsTypedExtensionProtocolOptions(
      java.lang.String key) {
    if (key == null) { throw new java.lang.NullPointerException(); }
    return internalGetTypedExtensionProtocolOptions().getMap().containsKey(key);
  }
  /**
   * Use {@link #getTypedExtensionProtocolOptionsMap()} instead.
   */
  @java.lang.Deprecated
  public java.util.Map<java.lang.String, com.google.protobuf.Any> getTypedExtensionProtocolOptions() {
    return getTypedExtensionProtocolOptionsMap();
  }
  /**
   * <pre>
   * [#not-implemented-hide:]
   * The extension_protocol_options field is used to provide extension-specific protocol options
   * for upstream connections. The key should match the extension filter name, such as
   * "envoy.filters.network.thrift_proxy". See the extension's documentation for details on
   * specific options.
   * </pre>
   *
   * <code>map&lt;string, .google.protobuf.Any&gt; typed_extension_protocol_options = 36;</code>
   */

  public java.util.Map<java.lang.String, com.google.protobuf.Any> getTypedExtensionProtocolOptionsMap() {
    return internalGetTypedExtensionProtocolOptions().getMap();
  }
  /**
   * <pre>
   * [#not-implemented-hide:]
   * The extension_protocol_options field is used to provide extension-specific protocol options
   * for upstream connections. The key should match the extension filter name, such as
   * "envoy.filters.network.thrift_proxy". See the extension's documentation for details on
   * specific options.
   * </pre>
   *
   * <code>map&lt;string, .google.protobuf.Any&gt; typed_extension_protocol_options = 36;</code>
   */

  public com.google.protobuf.Any getTypedExtensionProtocolOptionsOrDefault(
      java.lang.String key,
      com.google.protobuf.Any defaultValue) {
    if (key == null) { throw new java.lang.NullPointerException(); }
    java.util.Map<java.lang.String, com.google.protobuf.Any> map =
        internalGetTypedExtensionProtocolOptions().getMap();
    return map.containsKey(key) ? map.get(key) : defaultValue;
  }
  /**
   * <pre>
   * [#not-implemented-hide:]
   * The extension_protocol_options field is used to provide extension-specific protocol options
   * for upstream connections. The key should match the extension filter name, such as
   * "envoy.filters.network.thrift_proxy". See the extension's documentation for details on
   * specific options.
   * </pre>
   *
   * <code>map&lt;string, .google.protobuf.Any&gt; typed_extension_protocol_options = 36;</code>
   */

  public com.google.protobuf.Any getTypedExtensionProtocolOptionsOrThrow(
      java.lang.String key) {
    if (key == null) { throw new java.lang.NullPointerException(); }
    java.util.Map<java.lang.String, com.google.protobuf.Any> map =
        internalGetTypedExtensionProtocolOptions().getMap();
    if (!map.containsKey(key)) {
      throw new java.lang.IllegalArgumentException();
    }
    return map.get(key);
  }

  public static final int DNS_REFRESH_RATE_FIELD_NUMBER = 16;
  private com.google.protobuf.Duration dnsRefreshRate_;
  /**
   * <pre>
   * If the DNS refresh rate is specified and the cluster type is either
   * :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS&gt;`,
   * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS&gt;`,
   * this value is used as the clusters DNS refresh
   * rate. If this setting is not specified, the value defaults to 5000ms. For
   * cluster types other than
   * :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS&gt;`
   * and :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS&gt;`
   * this setting is ignored.
   * </pre>
   *
   * <code>.google.protobuf.Duration dns_refresh_rate = 16 [(.validate.rules) = { ... }</code>
   */
  public boolean hasDnsRefreshRate() {
    return dnsRefreshRate_ != null;
  }
  /**
   * <pre>
   * If the DNS refresh rate is specified and the cluster type is either
   * :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS&gt;`,
   * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS&gt;`,
   * this value is used as the clusters DNS refresh
   * rate. If this setting is not specified, the value defaults to 5000ms. For
   * cluster types other than
   * :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS&gt;`
   * and :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS&gt;`
   * this setting is ignored.
   * </pre>
   *
   * <code>.google.protobuf.Duration dns_refresh_rate = 16 [(.validate.rules) = { ... }</code>
   */
  public com.google.protobuf.Duration getDnsRefreshRate() {
    return dnsRefreshRate_ == null ? com.google.protobuf.Duration.getDefaultInstance() : dnsRefreshRate_;
  }
  /**
   * <pre>
   * If the DNS refresh rate is specified and the cluster type is either
   * :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS&gt;`,
   * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS&gt;`,
   * this value is used as the clusters DNS refresh
   * rate. If this setting is not specified, the value defaults to 5000ms. For
   * cluster types other than
   * :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS&gt;`
   * and :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS&gt;`
   * this setting is ignored.
   * </pre>
   *
   * <code>.google.protobuf.Duration dns_refresh_rate = 16 [(.validate.rules) = { ... }</code>
   */
  public com.google.protobuf.DurationOrBuilder getDnsRefreshRateOrBuilder() {
    return getDnsRefreshRate();
  }

  public static final int DNS_LOOKUP_FAMILY_FIELD_NUMBER = 17;
  private int dnsLookupFamily_;
  /**
   * <pre>
   * The DNS IP address resolution policy. If this setting is not specified, the
   * value defaults to
   * :ref:`AUTO&lt;envoy_api_enum_value_Cluster.DnsLookupFamily.AUTO&gt;`.
   * </pre>
   *
   * <code>.envoy.api.v2.Cluster.DnsLookupFamily dns_lookup_family = 17 [(.validate.rules) = { ... }</code>
   */
  public int getDnsLookupFamilyValue() {
    return dnsLookupFamily_;
  }
  /**
   * <pre>
   * The DNS IP address resolution policy. If this setting is not specified, the
   * value defaults to
   * :ref:`AUTO&lt;envoy_api_enum_value_Cluster.DnsLookupFamily.AUTO&gt;`.
   * </pre>
   *
   * <code>.envoy.api.v2.Cluster.DnsLookupFamily dns_lookup_family = 17 [(.validate.rules) = { ... }</code>
   */
  public io.grpc.xds.shaded.envoy.api.v2.Cluster.DnsLookupFamily getDnsLookupFamily() {
    io.grpc.xds.shaded.envoy.api.v2.Cluster.DnsLookupFamily result = io.grpc.xds.shaded.envoy.api.v2.Cluster.DnsLookupFamily.valueOf(dnsLookupFamily_);
    return result == null ? io.grpc.xds.shaded.envoy.api.v2.Cluster.DnsLookupFamily.UNRECOGNIZED : result;
  }

  public static final int DNS_RESOLVERS_FIELD_NUMBER = 18;
  private java.util.List<io.grpc.xds.shaded.envoy.api.v2.core.Address> dnsResolvers_;
  /**
   * <pre>
   * If DNS resolvers are specified and the cluster type is either
   * :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS&gt;`,
   * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS&gt;`,
   * this value is used to specify the clusters dns resolvers.
   * If this setting is not specified, the value defaults to the default
   * resolver, which uses /etc/resolv.conf for configuration. For cluster types
   * other than
   * :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS&gt;`
   * and :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS&gt;`
   * this setting is ignored.
   * </pre>
   *
   * <code>repeated .envoy.api.v2.core.Address dns_resolvers = 18;</code>
   */
  public java.util.List<io.grpc.xds.shaded.envoy.api.v2.core.Address> getDnsResolversList() {
    return dnsResolvers_;
  }
  /**
   * <pre>
   * If DNS resolvers are specified and the cluster type is either
   * :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS&gt;`,
   * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS&gt;`,
   * this value is used to specify the clusters dns resolvers.
   * If this setting is not specified, the value defaults to the default
   * resolver, which uses /etc/resolv.conf for configuration. For cluster types
   * other than
   * :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS&gt;`
   * and :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS&gt;`
   * this setting is ignored.
   * </pre>
   *
   * <code>repeated .envoy.api.v2.core.Address dns_resolvers = 18;</code>
   */
  public java.util.List<? extends io.grpc.xds.shaded.envoy.api.v2.core.AddressOrBuilder> 
      getDnsResolversOrBuilderList() {
    return dnsResolvers_;
  }
  /**
   * <pre>
   * If DNS resolvers are specified and the cluster type is either
   * :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS&gt;`,
   * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS&gt;`,
   * this value is used to specify the clusters dns resolvers.
   * If this setting is not specified, the value defaults to the default
   * resolver, which uses /etc/resolv.conf for configuration. For cluster types
   * other than
   * :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS&gt;`
   * and :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS&gt;`
   * this setting is ignored.
   * </pre>
   *
   * <code>repeated .envoy.api.v2.core.Address dns_resolvers = 18;</code>
   */
  public int getDnsResolversCount() {
    return dnsResolvers_.size();
  }
  /**
   * <pre>
   * If DNS resolvers are specified and the cluster type is either
   * :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS&gt;`,
   * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS&gt;`,
   * this value is used to specify the clusters dns resolvers.
   * If this setting is not specified, the value defaults to the default
   * resolver, which uses /etc/resolv.conf for configuration. For cluster types
   * other than
   * :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS&gt;`
   * and :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS&gt;`
   * this setting is ignored.
   * </pre>
   *
   * <code>repeated .envoy.api.v2.core.Address dns_resolvers = 18;</code>
   */
  public io.grpc.xds.shaded.envoy.api.v2.core.Address getDnsResolvers(int index) {
    return dnsResolvers_.get(index);
  }
  /**
   * <pre>
   * If DNS resolvers are specified and the cluster type is either
   * :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS&gt;`,
   * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS&gt;`,
   * this value is used to specify the clusters dns resolvers.
   * If this setting is not specified, the value defaults to the default
   * resolver, which uses /etc/resolv.conf for configuration. For cluster types
   * other than
   * :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS&gt;`
   * and :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS&gt;`
   * this setting is ignored.
   * </pre>
   *
   * <code>repeated .envoy.api.v2.core.Address dns_resolvers = 18;</code>
   */
  public io.grpc.xds.shaded.envoy.api.v2.core.AddressOrBuilder getDnsResolversOrBuilder(
      int index) {
    return dnsResolvers_.get(index);
  }

  public static final int OUTLIER_DETECTION_FIELD_NUMBER = 19;
  private io.grpc.xds.shaded.envoy.api.v2.cluster.OutlierDetection outlierDetection_;
  /**
   * <pre>
   * If specified, outlier detection will be enabled for this upstream cluster.
   * Each of the configuration values can be overridden via
   * :ref:`runtime values &lt;config_cluster_manager_cluster_runtime_outlier_detection&gt;`.
   * </pre>
   *
   * <code>.envoy.api.v2.cluster.OutlierDetection outlier_detection = 19;</code>
   */
  public boolean hasOutlierDetection() {
    return outlierDetection_ != null;
  }
  /**
   * <pre>
   * If specified, outlier detection will be enabled for this upstream cluster.
   * Each of the configuration values can be overridden via
   * :ref:`runtime values &lt;config_cluster_manager_cluster_runtime_outlier_detection&gt;`.
   * </pre>
   *
   * <code>.envoy.api.v2.cluster.OutlierDetection outlier_detection = 19;</code>
   */
  public io.grpc.xds.shaded.envoy.api.v2.cluster.OutlierDetection getOutlierDetection() {
    return outlierDetection_ == null ? io.grpc.xds.shaded.envoy.api.v2.cluster.OutlierDetection.getDefaultInstance() : outlierDetection_;
  }
  /**
   * <pre>
   * If specified, outlier detection will be enabled for this upstream cluster.
   * Each of the configuration values can be overridden via
   * :ref:`runtime values &lt;config_cluster_manager_cluster_runtime_outlier_detection&gt;`.
   * </pre>
   *
   * <code>.envoy.api.v2.cluster.OutlierDetection outlier_detection = 19;</code>
   */
  public io.grpc.xds.shaded.envoy.api.v2.cluster.OutlierDetectionOrBuilder getOutlierDetectionOrBuilder() {
    return getOutlierDetection();
  }

  public static final int CLEANUP_INTERVAL_FIELD_NUMBER = 20;
  private com.google.protobuf.Duration cleanupInterval_;
  /**
   * <pre>
   * The interval for removing stale hosts from a cluster type
   * :ref:`ORIGINAL_DST&lt;envoy_api_enum_value_Cluster.DiscoveryType.ORIGINAL_DST&gt;`.
   * Hosts are considered stale if they have not been used
   * as upstream destinations during this interval. New hosts are added
   * to original destination clusters on demand as new connections are
   * redirected to Envoy, causing the number of hosts in the cluster to
   * grow over time. Hosts that are not stale (they are actively used as
   * destinations) are kept in the cluster, which allows connections to
   * them remain open, saving the latency that would otherwise be spent
   * on opening new connections. If this setting is not specified, the
   * value defaults to 5000ms. For cluster types other than
   * :ref:`ORIGINAL_DST&lt;envoy_api_enum_value_Cluster.DiscoveryType.ORIGINAL_DST&gt;`
   * this setting is ignored.
   * </pre>
   *
   * <code>.google.protobuf.Duration cleanup_interval = 20 [(.validate.rules) = { ... }</code>
   */
  public boolean hasCleanupInterval() {
    return cleanupInterval_ != null;
  }
  /**
   * <pre>
   * The interval for removing stale hosts from a cluster type
   * :ref:`ORIGINAL_DST&lt;envoy_api_enum_value_Cluster.DiscoveryType.ORIGINAL_DST&gt;`.
   * Hosts are considered stale if they have not been used
   * as upstream destinations during this interval. New hosts are added
   * to original destination clusters on demand as new connections are
   * redirected to Envoy, causing the number of hosts in the cluster to
   * grow over time. Hosts that are not stale (they are actively used as
   * destinations) are kept in the cluster, which allows connections to
   * them remain open, saving the latency that would otherwise be spent
   * on opening new connections. If this setting is not specified, the
   * value defaults to 5000ms. For cluster types other than
   * :ref:`ORIGINAL_DST&lt;envoy_api_enum_value_Cluster.DiscoveryType.ORIGINAL_DST&gt;`
   * this setting is ignored.
   * </pre>
   *
   * <code>.google.protobuf.Duration cleanup_interval = 20 [(.validate.rules) = { ... }</code>
   */
  public com.google.protobuf.Duration getCleanupInterval() {
    return cleanupInterval_ == null ? com.google.protobuf.Duration.getDefaultInstance() : cleanupInterval_;
  }
  /**
   * <pre>
   * The interval for removing stale hosts from a cluster type
   * :ref:`ORIGINAL_DST&lt;envoy_api_enum_value_Cluster.DiscoveryType.ORIGINAL_DST&gt;`.
   * Hosts are considered stale if they have not been used
   * as upstream destinations during this interval. New hosts are added
   * to original destination clusters on demand as new connections are
   * redirected to Envoy, causing the number of hosts in the cluster to
   * grow over time. Hosts that are not stale (they are actively used as
   * destinations) are kept in the cluster, which allows connections to
   * them remain open, saving the latency that would otherwise be spent
   * on opening new connections. If this setting is not specified, the
   * value defaults to 5000ms. For cluster types other than
   * :ref:`ORIGINAL_DST&lt;envoy_api_enum_value_Cluster.DiscoveryType.ORIGINAL_DST&gt;`
   * this setting is ignored.
   * </pre>
   *
   * <code>.google.protobuf.Duration cleanup_interval = 20 [(.validate.rules) = { ... }</code>
   */
  public com.google.protobuf.DurationOrBuilder getCleanupIntervalOrBuilder() {
    return getCleanupInterval();
  }

  public static final int UPSTREAM_BIND_CONFIG_FIELD_NUMBER = 21;
  private io.grpc.xds.shaded.envoy.api.v2.core.BindConfig upstreamBindConfig_;
  /**
   * <pre>
   * Optional configuration used to bind newly established upstream connections.
   * This overrides any bind_config specified in the bootstrap proto.
   * If the address and port are empty, no bind will be performed.
   * </pre>
   *
   * <code>.envoy.api.v2.core.BindConfig upstream_bind_config = 21;</code>
   */
  public boolean hasUpstreamBindConfig() {
    return upstreamBindConfig_ != null;
  }
  /**
   * <pre>
   * Optional configuration used to bind newly established upstream connections.
   * This overrides any bind_config specified in the bootstrap proto.
   * If the address and port are empty, no bind will be performed.
   * </pre>
   *
   * <code>.envoy.api.v2.core.BindConfig upstream_bind_config = 21;</code>
   */
  public io.grpc.xds.shaded.envoy.api.v2.core.BindConfig getUpstreamBindConfig() {
    return upstreamBindConfig_ == null ? io.grpc.xds.shaded.envoy.api.v2.core.BindConfig.getDefaultInstance() : upstreamBindConfig_;
  }
  /**
   * <pre>
   * Optional configuration used to bind newly established upstream connections.
   * This overrides any bind_config specified in the bootstrap proto.
   * If the address and port are empty, no bind will be performed.
   * </pre>
   *
   * <code>.envoy.api.v2.core.BindConfig upstream_bind_config = 21;</code>
   */
  public io.grpc.xds.shaded.envoy.api.v2.core.BindConfigOrBuilder getUpstreamBindConfigOrBuilder() {
    return getUpstreamBindConfig();
  }

  public static final int LB_SUBSET_CONFIG_FIELD_NUMBER = 22;
  private io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfig lbSubsetConfig_;
  /**
   * <pre>
   * Configuration for load balancing subsetting.
   * </pre>
   *
   * <code>.envoy.api.v2.Cluster.LbSubsetConfig lb_subset_config = 22;</code>
   */
  public boolean hasLbSubsetConfig() {
    return lbSubsetConfig_ != null;
  }
  /**
   * <pre>
   * Configuration for load balancing subsetting.
   * </pre>
   *
   * <code>.envoy.api.v2.Cluster.LbSubsetConfig lb_subset_config = 22;</code>
   */
  public io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfig getLbSubsetConfig() {
    return lbSubsetConfig_ == null ? io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfig.getDefaultInstance() : lbSubsetConfig_;
  }
  /**
   * <pre>
   * Configuration for load balancing subsetting.
   * </pre>
   *
   * <code>.envoy.api.v2.Cluster.LbSubsetConfig lb_subset_config = 22;</code>
   */
  public io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfigOrBuilder getLbSubsetConfigOrBuilder() {
    return getLbSubsetConfig();
  }

  public static final int RING_HASH_LB_CONFIG_FIELD_NUMBER = 23;
  /**
   * <pre>
   * Optional configuration for the Ring Hash load balancing policy.
   * </pre>
   *
   * <code>.envoy.api.v2.Cluster.RingHashLbConfig ring_hash_lb_config = 23;</code>
   */
  public boolean hasRingHashLbConfig() {
    return lbConfigCase_ == 23;
  }
  /**
   * <pre>
   * Optional configuration for the Ring Hash load balancing policy.
   * </pre>
   *
   * <code>.envoy.api.v2.Cluster.RingHashLbConfig ring_hash_lb_config = 23;</code>
   */
  public io.grpc.xds.shaded.envoy.api.v2.Cluster.RingHashLbConfig getRingHashLbConfig() {
    if (lbConfigCase_ == 23) {
       return (io.grpc.xds.shaded.envoy.api.v2.Cluster.RingHashLbConfig) lbConfig_;
    }
    return io.grpc.xds.shaded.envoy.api.v2.Cluster.RingHashLbConfig.getDefaultInstance();
  }
  /**
   * <pre>
   * Optional configuration for the Ring Hash load balancing policy.
   * </pre>
   *
   * <code>.envoy.api.v2.Cluster.RingHashLbConfig ring_hash_lb_config = 23;</code>
   */
  public io.grpc.xds.shaded.envoy.api.v2.Cluster.RingHashLbConfigOrBuilder getRingHashLbConfigOrBuilder() {
    if (lbConfigCase_ == 23) {
       return (io.grpc.xds.shaded.envoy.api.v2.Cluster.RingHashLbConfig) lbConfig_;
    }
    return io.grpc.xds.shaded.envoy.api.v2.Cluster.RingHashLbConfig.getDefaultInstance();
  }

  public static final int ORIGINAL_DST_LB_CONFIG_FIELD_NUMBER = 34;
  /**
   * <pre>
   * Optional configuration for the Original Destination load balancing policy.
   * </pre>
   *
   * <code>.envoy.api.v2.Cluster.OriginalDstLbConfig original_dst_lb_config = 34;</code>
   */
  public boolean hasOriginalDstLbConfig() {
    return lbConfigCase_ == 34;
  }
  /**
   * <pre>
   * Optional configuration for the Original Destination load balancing policy.
   * </pre>
   *
   * <code>.envoy.api.v2.Cluster.OriginalDstLbConfig original_dst_lb_config = 34;</code>
   */
  public io.grpc.xds.shaded.envoy.api.v2.Cluster.OriginalDstLbConfig getOriginalDstLbConfig() {
    if (lbConfigCase_ == 34) {
       return (io.grpc.xds.shaded.envoy.api.v2.Cluster.OriginalDstLbConfig) lbConfig_;
    }
    return io.grpc.xds.shaded.envoy.api.v2.Cluster.OriginalDstLbConfig.getDefaultInstance();
  }
  /**
   * <pre>
   * Optional configuration for the Original Destination load balancing policy.
   * </pre>
   *
   * <code>.envoy.api.v2.Cluster.OriginalDstLbConfig original_dst_lb_config = 34;</code>
   */
  public io.grpc.xds.shaded.envoy.api.v2.Cluster.OriginalDstLbConfigOrBuilder getOriginalDstLbConfigOrBuilder() {
    if (lbConfigCase_ == 34) {
       return (io.grpc.xds.shaded.envoy.api.v2.Cluster.OriginalDstLbConfig) lbConfig_;
    }
    return io.grpc.xds.shaded.envoy.api.v2.Cluster.OriginalDstLbConfig.getDefaultInstance();
  }

  public static final int LEAST_REQUEST_LB_CONFIG_FIELD_NUMBER = 37;
  /**
   * <pre>
   * Optional configuration for the LeastRequest load balancing policy.
   * </pre>
   *
   * <code>.envoy.api.v2.Cluster.LeastRequestLbConfig least_request_lb_config = 37;</code>
   */
  public boolean hasLeastRequestLbConfig() {
    return lbConfigCase_ == 37;
  }
  /**
   * <pre>
   * Optional configuration for the LeastRequest load balancing policy.
   * </pre>
   *
   * <code>.envoy.api.v2.Cluster.LeastRequestLbConfig least_request_lb_config = 37;</code>
   */
  public io.grpc.xds.shaded.envoy.api.v2.Cluster.LeastRequestLbConfig getLeastRequestLbConfig() {
    if (lbConfigCase_ == 37) {
       return (io.grpc.xds.shaded.envoy.api.v2.Cluster.LeastRequestLbConfig) lbConfig_;
    }
    return io.grpc.xds.shaded.envoy.api.v2.Cluster.LeastRequestLbConfig.getDefaultInstance();
  }
  /**
   * <pre>
   * Optional configuration for the LeastRequest load balancing policy.
   * </pre>
   *
   * <code>.envoy.api.v2.Cluster.LeastRequestLbConfig least_request_lb_config = 37;</code>
   */
  public io.grpc.xds.shaded.envoy.api.v2.Cluster.LeastRequestLbConfigOrBuilder getLeastRequestLbConfigOrBuilder() {
    if (lbConfigCase_ == 37) {
       return (io.grpc.xds.shaded.envoy.api.v2.Cluster.LeastRequestLbConfig) lbConfig_;
    }
    return io.grpc.xds.shaded.envoy.api.v2.Cluster.LeastRequestLbConfig.getDefaultInstance();
  }

  public static final int COMMON_LB_CONFIG_FIELD_NUMBER = 27;
  private io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig commonLbConfig_;
  /**
   * <pre>
   * Common configuration for all load balancer implementations.
   * </pre>
   *
   * <code>.envoy.api.v2.Cluster.CommonLbConfig common_lb_config = 27;</code>
   */
  public boolean hasCommonLbConfig() {
    return commonLbConfig_ != null;
  }
  /**
   * <pre>
   * Common configuration for all load balancer implementations.
   * </pre>
   *
   * <code>.envoy.api.v2.Cluster.CommonLbConfig common_lb_config = 27;</code>
   */
  public io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig getCommonLbConfig() {
    return commonLbConfig_ == null ? io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.getDefaultInstance() : commonLbConfig_;
  }
  /**
   * <pre>
   * Common configuration for all load balancer implementations.
   * </pre>
   *
   * <code>.envoy.api.v2.Cluster.CommonLbConfig common_lb_config = 27;</code>
   */
  public io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfigOrBuilder getCommonLbConfigOrBuilder() {
    return getCommonLbConfig();
  }

  public static final int TRANSPORT_SOCKET_FIELD_NUMBER = 24;
  private io.grpc.xds.shaded.envoy.api.v2.core.TransportSocket transportSocket_;
  /**
   * <pre>
   * Optional custom transport socket implementation to use for upstream connections.
   * </pre>
   *
   * <code>.envoy.api.v2.core.TransportSocket transport_socket = 24;</code>
   */
  public boolean hasTransportSocket() {
    return transportSocket_ != null;
  }
  /**
   * <pre>
   * Optional custom transport socket implementation to use for upstream connections.
   * </pre>
   *
   * <code>.envoy.api.v2.core.TransportSocket transport_socket = 24;</code>
   */
  public io.grpc.xds.shaded.envoy.api.v2.core.TransportSocket getTransportSocket() {
    return transportSocket_ == null ? io.grpc.xds.shaded.envoy.api.v2.core.TransportSocket.getDefaultInstance() : transportSocket_;
  }
  /**
   * <pre>
   * Optional custom transport socket implementation to use for upstream connections.
   * </pre>
   *
   * <code>.envoy.api.v2.core.TransportSocket transport_socket = 24;</code>
   */
  public io.grpc.xds.shaded.envoy.api.v2.core.TransportSocketOrBuilder getTransportSocketOrBuilder() {
    return getTransportSocket();
  }

  public static final int METADATA_FIELD_NUMBER = 25;
  private io.grpc.xds.shaded.envoy.api.v2.core.Metadata metadata_;
  /**
   * <pre>
   * The Metadata field can be used to provide additional information about the
   * cluster. It can be used for stats, logging, and varying filter behavior.
   * Fields should use reverse DNS notation to denote which entity within Envoy
   * will need the information. For instance, if the metadata is intended for
   * the Router filter, the filter name should be specified as *envoy.router*.
   * </pre>
   *
   * <code>.envoy.api.v2.core.Metadata metadata = 25;</code>
   */
  public boolean hasMetadata() {
    return metadata_ != null;
  }
  /**
   * <pre>
   * The Metadata field can be used to provide additional information about the
   * cluster. It can be used for stats, logging, and varying filter behavior.
   * Fields should use reverse DNS notation to denote which entity within Envoy
   * will need the information. For instance, if the metadata is intended for
   * the Router filter, the filter name should be specified as *envoy.router*.
   * </pre>
   *
   * <code>.envoy.api.v2.core.Metadata metadata = 25;</code>
   */
  public io.grpc.xds.shaded.envoy.api.v2.core.Metadata getMetadata() {
    return metadata_ == null ? io.grpc.xds.shaded.envoy.api.v2.core.Metadata.getDefaultInstance() : metadata_;
  }
  /**
   * <pre>
   * The Metadata field can be used to provide additional information about the
   * cluster. It can be used for stats, logging, and varying filter behavior.
   * Fields should use reverse DNS notation to denote which entity within Envoy
   * will need the information. For instance, if the metadata is intended for
   * the Router filter, the filter name should be specified as *envoy.router*.
   * </pre>
   *
   * <code>.envoy.api.v2.core.Metadata metadata = 25;</code>
   */
  public io.grpc.xds.shaded.envoy.api.v2.core.MetadataOrBuilder getMetadataOrBuilder() {
    return getMetadata();
  }

  public static final int PROTOCOL_SELECTION_FIELD_NUMBER = 26;
  private int protocolSelection_;
  /**
   * <pre>
   * Determines how Envoy selects the protocol used to speak to upstream hosts.
   * </pre>
   *
   * <code>.envoy.api.v2.Cluster.ClusterProtocolSelection protocol_selection = 26;</code>
   */
  public int getProtocolSelectionValue() {
    return protocolSelection_;
  }
  /**
   * <pre>
   * Determines how Envoy selects the protocol used to speak to upstream hosts.
   * </pre>
   *
   * <code>.envoy.api.v2.Cluster.ClusterProtocolSelection protocol_selection = 26;</code>
   */
  public io.grpc.xds.shaded.envoy.api.v2.Cluster.ClusterProtocolSelection getProtocolSelection() {
    io.grpc.xds.shaded.envoy.api.v2.Cluster.ClusterProtocolSelection result = io.grpc.xds.shaded.envoy.api.v2.Cluster.ClusterProtocolSelection.valueOf(protocolSelection_);
    return result == null ? io.grpc.xds.shaded.envoy.api.v2.Cluster.ClusterProtocolSelection.UNRECOGNIZED : result;
  }

  public static final int UPSTREAM_CONNECTION_OPTIONS_FIELD_NUMBER = 30;
  private io.grpc.xds.shaded.envoy.api.v2.UpstreamConnectionOptions upstreamConnectionOptions_;
  /**
   * <pre>
   * Optional options for upstream connections.
   * </pre>
   *
   * <code>.envoy.api.v2.UpstreamConnectionOptions upstream_connection_options = 30;</code>
   */
  public boolean hasUpstreamConnectionOptions() {
    return upstreamConnectionOptions_ != null;
  }
  /**
   * <pre>
   * Optional options for upstream connections.
   * </pre>
   *
   * <code>.envoy.api.v2.UpstreamConnectionOptions upstream_connection_options = 30;</code>
   */
  public io.grpc.xds.shaded.envoy.api.v2.UpstreamConnectionOptions getUpstreamConnectionOptions() {
    return upstreamConnectionOptions_ == null ? io.grpc.xds.shaded.envoy.api.v2.UpstreamConnectionOptions.getDefaultInstance() : upstreamConnectionOptions_;
  }
  /**
   * <pre>
   * Optional options for upstream connections.
   * </pre>
   *
   * <code>.envoy.api.v2.UpstreamConnectionOptions upstream_connection_options = 30;</code>
   */
  public io.grpc.xds.shaded.envoy.api.v2.UpstreamConnectionOptionsOrBuilder getUpstreamConnectionOptionsOrBuilder() {
    return getUpstreamConnectionOptions();
  }

  public static final int CLOSE_CONNECTIONS_ON_HOST_HEALTH_FAILURE_FIELD_NUMBER = 31;
  private boolean closeConnectionsOnHostHealthFailure_;
  /**
   * <pre>
   * If an upstream host becomes unhealthy (as determined by the configured health checks
   * or outlier detection), immediately close all connections to the failed host.
   * .. note::
   *   This is currently only supported for connections created by tcp_proxy.
   * .. note::
   *   The current implementation of this feature closes all connections immediately when
   *   the unhealthy status is detected. If there are a large number of connections open
   *   to an upstream host that becomes unhealthy, Envoy may spend a substantial amount of
   *   time exclusively closing these connections, and not processing any other traffic.
   * </pre>
   *
   * <code>bool close_connections_on_host_health_failure = 31;</code>
   */
  public boolean getCloseConnectionsOnHostHealthFailure() {
    return closeConnectionsOnHostHealthFailure_;
  }

  public static final int DRAIN_CONNECTIONS_ON_HOST_REMOVAL_FIELD_NUMBER = 32;
  private boolean drainConnectionsOnHostRemoval_;
  /**
   * <pre>
   * If this cluster uses EDS or STRICT_DNS to configure its hosts, immediately drain
   * connections from any hosts that are removed from service discovery.
   * This only affects behavior for hosts that are being actively health checked.
   * If this flag is not set to true, Envoy will wait until the hosts fail active health
   * checking before removing it from the cluster.
   * </pre>
   *
   * <code>bool drain_connections_on_host_removal = 32;</code>
   */
  public boolean getDrainConnectionsOnHostRemoval() {
    return drainConnectionsOnHostRemoval_;
  }

  private byte memoizedIsInitialized = -1;
  public final boolean isInitialized() {
    byte isInitialized = memoizedIsInitialized;
    if (isInitialized == 1) return true;
    if (isInitialized == 0) return false;

    memoizedIsInitialized = 1;
    return true;
  }

  public void writeTo(com.google.protobuf.CodedOutputStream output)
                      throws java.io.IOException {
    if (!getNameBytes().isEmpty()) {
      com.google.protobuf.GeneratedMessageV3.writeString(output, 1, name_);
    }
    if (type_ != io.grpc.xds.shaded.envoy.api.v2.Cluster.DiscoveryType.STATIC.getNumber()) {
      output.writeEnum(2, type_);
    }
    if (edsClusterConfig_ != null) {
      output.writeMessage(3, getEdsClusterConfig());
    }
    if (connectTimeout_ != null) {
      output.writeMessage(4, getConnectTimeout());
    }
    if (perConnectionBufferLimitBytes_ != null) {
      output.writeMessage(5, getPerConnectionBufferLimitBytes());
    }
    if (lbPolicy_ != io.grpc.xds.shaded.envoy.api.v2.Cluster.LbPolicy.ROUND_ROBIN.getNumber()) {
      output.writeEnum(6, lbPolicy_);
    }
    for (int i = 0; i < hosts_.size(); i++) {
      output.writeMessage(7, hosts_.get(i));
    }
    for (int i = 0; i < healthChecks_.size(); i++) {
      output.writeMessage(8, healthChecks_.get(i));
    }
    if (maxRequestsPerConnection_ != null) {
      output.writeMessage(9, getMaxRequestsPerConnection());
    }
    if (circuitBreakers_ != null) {
      output.writeMessage(10, getCircuitBreakers());
    }
    if (tlsContext_ != null) {
      output.writeMessage(11, getTlsContext());
    }
    if (httpProtocolOptions_ != null) {
      output.writeMessage(13, getHttpProtocolOptions());
    }
    if (http2ProtocolOptions_ != null) {
      output.writeMessage(14, getHttp2ProtocolOptions());
    }
    if (dnsRefreshRate_ != null) {
      output.writeMessage(16, getDnsRefreshRate());
    }
    if (dnsLookupFamily_ != io.grpc.xds.shaded.envoy.api.v2.Cluster.DnsLookupFamily.AUTO.getNumber()) {
      output.writeEnum(17, dnsLookupFamily_);
    }
    for (int i = 0; i < dnsResolvers_.size(); i++) {
      output.writeMessage(18, dnsResolvers_.get(i));
    }
    if (outlierDetection_ != null) {
      output.writeMessage(19, getOutlierDetection());
    }
    if (cleanupInterval_ != null) {
      output.writeMessage(20, getCleanupInterval());
    }
    if (upstreamBindConfig_ != null) {
      output.writeMessage(21, getUpstreamBindConfig());
    }
    if (lbSubsetConfig_ != null) {
      output.writeMessage(22, getLbSubsetConfig());
    }
    if (lbConfigCase_ == 23) {
      output.writeMessage(23, (io.grpc.xds.shaded.envoy.api.v2.Cluster.RingHashLbConfig) lbConfig_);
    }
    if (transportSocket_ != null) {
      output.writeMessage(24, getTransportSocket());
    }
    if (metadata_ != null) {
      output.writeMessage(25, getMetadata());
    }
    if (protocolSelection_ != io.grpc.xds.shaded.envoy.api.v2.Cluster.ClusterProtocolSelection.USE_CONFIGURED_PROTOCOL.getNumber()) {
      output.writeEnum(26, protocolSelection_);
    }
    if (commonLbConfig_ != null) {
      output.writeMessage(27, getCommonLbConfig());
    }
    if (!getAltStatNameBytes().isEmpty()) {
      com.google.protobuf.GeneratedMessageV3.writeString(output, 28, altStatName_);
    }
    if (commonHttpProtocolOptions_ != null) {
      output.writeMessage(29, getCommonHttpProtocolOptions());
    }
    if (upstreamConnectionOptions_ != null) {
      output.writeMessage(30, getUpstreamConnectionOptions());
    }
    if (closeConnectionsOnHostHealthFailure_ != false) {
      output.writeBool(31, closeConnectionsOnHostHealthFailure_);
    }
    if (drainConnectionsOnHostRemoval_ != false) {
      output.writeBool(32, drainConnectionsOnHostRemoval_);
    }
    if (loadAssignment_ != null) {
      output.writeMessage(33, getLoadAssignment());
    }
    if (lbConfigCase_ == 34) {
      output.writeMessage(34, (io.grpc.xds.shaded.envoy.api.v2.Cluster.OriginalDstLbConfig) lbConfig_);
    }
    com.google.protobuf.GeneratedMessageV3
      .serializeStringMapTo(
        output,
        internalGetExtensionProtocolOptions(),
        ExtensionProtocolOptionsDefaultEntryHolder.defaultEntry,
        35);
    com.google.protobuf.GeneratedMessageV3
      .serializeStringMapTo(
        output,
        internalGetTypedExtensionProtocolOptions(),
        TypedExtensionProtocolOptionsDefaultEntryHolder.defaultEntry,
        36);
    if (lbConfigCase_ == 37) {
      output.writeMessage(37, (io.grpc.xds.shaded.envoy.api.v2.Cluster.LeastRequestLbConfig) lbConfig_);
    }
    unknownFields.writeTo(output);
  }

  public int getSerializedSize() {
    int size = memoizedSize;
    if (size != -1) return size;

    size = 0;
    if (!getNameBytes().isEmpty()) {
      size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, name_);
    }
    if (type_ != io.grpc.xds.shaded.envoy.api.v2.Cluster.DiscoveryType.STATIC.getNumber()) {
      size += com.google.protobuf.CodedOutputStream
        .computeEnumSize(2, type_);
    }
    if (edsClusterConfig_ != null) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(3, getEdsClusterConfig());
    }
    if (connectTimeout_ != null) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(4, getConnectTimeout());
    }
    if (perConnectionBufferLimitBytes_ != null) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(5, getPerConnectionBufferLimitBytes());
    }
    if (lbPolicy_ != io.grpc.xds.shaded.envoy.api.v2.Cluster.LbPolicy.ROUND_ROBIN.getNumber()) {
      size += com.google.protobuf.CodedOutputStream
        .computeEnumSize(6, lbPolicy_);
    }
    for (int i = 0; i < hosts_.size(); i++) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(7, hosts_.get(i));
    }
    for (int i = 0; i < healthChecks_.size(); i++) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(8, healthChecks_.get(i));
    }
    if (maxRequestsPerConnection_ != null) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(9, getMaxRequestsPerConnection());
    }
    if (circuitBreakers_ != null) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(10, getCircuitBreakers());
    }
    if (tlsContext_ != null) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(11, getTlsContext());
    }
    if (httpProtocolOptions_ != null) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(13, getHttpProtocolOptions());
    }
    if (http2ProtocolOptions_ != null) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(14, getHttp2ProtocolOptions());
    }
    if (dnsRefreshRate_ != null) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(16, getDnsRefreshRate());
    }
    if (dnsLookupFamily_ != io.grpc.xds.shaded.envoy.api.v2.Cluster.DnsLookupFamily.AUTO.getNumber()) {
      size += com.google.protobuf.CodedOutputStream
        .computeEnumSize(17, dnsLookupFamily_);
    }
    for (int i = 0; i < dnsResolvers_.size(); i++) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(18, dnsResolvers_.get(i));
    }
    if (outlierDetection_ != null) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(19, getOutlierDetection());
    }
    if (cleanupInterval_ != null) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(20, getCleanupInterval());
    }
    if (upstreamBindConfig_ != null) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(21, getUpstreamBindConfig());
    }
    if (lbSubsetConfig_ != null) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(22, getLbSubsetConfig());
    }
    if (lbConfigCase_ == 23) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(23, (io.grpc.xds.shaded.envoy.api.v2.Cluster.RingHashLbConfig) lbConfig_);
    }
    if (transportSocket_ != null) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(24, getTransportSocket());
    }
    if (metadata_ != null) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(25, getMetadata());
    }
    if (protocolSelection_ != io.grpc.xds.shaded.envoy.api.v2.Cluster.ClusterProtocolSelection.USE_CONFIGURED_PROTOCOL.getNumber()) {
      size += com.google.protobuf.CodedOutputStream
        .computeEnumSize(26, protocolSelection_);
    }
    if (commonLbConfig_ != null) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(27, getCommonLbConfig());
    }
    if (!getAltStatNameBytes().isEmpty()) {
      size += com.google.protobuf.GeneratedMessageV3.computeStringSize(28, altStatName_);
    }
    if (commonHttpProtocolOptions_ != null) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(29, getCommonHttpProtocolOptions());
    }
    if (upstreamConnectionOptions_ != null) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(30, getUpstreamConnectionOptions());
    }
    if (closeConnectionsOnHostHealthFailure_ != false) {
      size += com.google.protobuf.CodedOutputStream
        .computeBoolSize(31, closeConnectionsOnHostHealthFailure_);
    }
    if (drainConnectionsOnHostRemoval_ != false) {
      size += com.google.protobuf.CodedOutputStream
        .computeBoolSize(32, drainConnectionsOnHostRemoval_);
    }
    if (loadAssignment_ != null) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(33, getLoadAssignment());
    }
    if (lbConfigCase_ == 34) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(34, (io.grpc.xds.shaded.envoy.api.v2.Cluster.OriginalDstLbConfig) lbConfig_);
    }
    for (java.util.Map.Entry<java.lang.String, com.google.protobuf.Struct> entry
         : internalGetExtensionProtocolOptions().getMap().entrySet()) {
      com.google.protobuf.MapEntry<java.lang.String, com.google.protobuf.Struct>
      extensionProtocolOptions__ = ExtensionProtocolOptionsDefaultEntryHolder.defaultEntry.newBuilderForType()
          .setKey(entry.getKey())
          .setValue(entry.getValue())
          .build();
      size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(35, extensionProtocolOptions__);
    }
    for (java.util.Map.Entry<java.lang.String, com.google.protobuf.Any> entry
         : internalGetTypedExtensionProtocolOptions().getMap().entrySet()) {
      com.google.protobuf.MapEntry<java.lang.String, com.google.protobuf.Any>
      typedExtensionProtocolOptions__ = TypedExtensionProtocolOptionsDefaultEntryHolder.defaultEntry.newBuilderForType()
          .setKey(entry.getKey())
          .setValue(entry.getValue())
          .build();
      size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(36, typedExtensionProtocolOptions__);
    }
    if (lbConfigCase_ == 37) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(37, (io.grpc.xds.shaded.envoy.api.v2.Cluster.LeastRequestLbConfig) lbConfig_);
    }
    size += unknownFields.getSerializedSize();
    memoizedSize = size;
    return size;
  }

  @java.lang.Override
  public boolean equals(final java.lang.Object obj) {
    if (obj == this) {
     return true;
    }
    if (!(obj instanceof io.grpc.xds.shaded.envoy.api.v2.Cluster)) {
      return super.equals(obj);
    }
    io.grpc.xds.shaded.envoy.api.v2.Cluster other = (io.grpc.xds.shaded.envoy.api.v2.Cluster) obj;

    boolean result = true;
    result = result && getName()
        .equals(other.getName());
    result = result && getAltStatName()
        .equals(other.getAltStatName());
    result = result && type_ == other.type_;
    result = result && (hasEdsClusterConfig() == other.hasEdsClusterConfig());
    if (hasEdsClusterConfig()) {
      result = result && getEdsClusterConfig()
          .equals(other.getEdsClusterConfig());
    }
    result = result && (hasConnectTimeout() == other.hasConnectTimeout());
    if (hasConnectTimeout()) {
      result = result && getConnectTimeout()
          .equals(other.getConnectTimeout());
    }
    result = result && (hasPerConnectionBufferLimitBytes() == other.hasPerConnectionBufferLimitBytes());
    if (hasPerConnectionBufferLimitBytes()) {
      result = result && getPerConnectionBufferLimitBytes()
          .equals(other.getPerConnectionBufferLimitBytes());
    }
    result = result && lbPolicy_ == other.lbPolicy_;
    result = result && getHostsList()
        .equals(other.getHostsList());
    result = result && (hasLoadAssignment() == other.hasLoadAssignment());
    if (hasLoadAssignment()) {
      result = result && getLoadAssignment()
          .equals(other.getLoadAssignment());
    }
    result = result && getHealthChecksList()
        .equals(other.getHealthChecksList());
    result = result && (hasMaxRequestsPerConnection() == other.hasMaxRequestsPerConnection());
    if (hasMaxRequestsPerConnection()) {
      result = result && getMaxRequestsPerConnection()
          .equals(other.getMaxRequestsPerConnection());
    }
    result = result && (hasCircuitBreakers() == other.hasCircuitBreakers());
    if (hasCircuitBreakers()) {
      result = result && getCircuitBreakers()
          .equals(other.getCircuitBreakers());
    }
    result = result && (hasTlsContext() == other.hasTlsContext());
    if (hasTlsContext()) {
      result = result && getTlsContext()
          .equals(other.getTlsContext());
    }
    result = result && (hasCommonHttpProtocolOptions() == other.hasCommonHttpProtocolOptions());
    if (hasCommonHttpProtocolOptions()) {
      result = result && getCommonHttpProtocolOptions()
          .equals(other.getCommonHttpProtocolOptions());
    }
    result = result && (hasHttpProtocolOptions() == other.hasHttpProtocolOptions());
    if (hasHttpProtocolOptions()) {
      result = result && getHttpProtocolOptions()
          .equals(other.getHttpProtocolOptions());
    }
    result = result && (hasHttp2ProtocolOptions() == other.hasHttp2ProtocolOptions());
    if (hasHttp2ProtocolOptions()) {
      result = result && getHttp2ProtocolOptions()
          .equals(other.getHttp2ProtocolOptions());
    }
    result = result && internalGetExtensionProtocolOptions().equals(
        other.internalGetExtensionProtocolOptions());
    result = result && internalGetTypedExtensionProtocolOptions().equals(
        other.internalGetTypedExtensionProtocolOptions());
    result = result && (hasDnsRefreshRate() == other.hasDnsRefreshRate());
    if (hasDnsRefreshRate()) {
      result = result && getDnsRefreshRate()
          .equals(other.getDnsRefreshRate());
    }
    result = result && dnsLookupFamily_ == other.dnsLookupFamily_;
    result = result && getDnsResolversList()
        .equals(other.getDnsResolversList());
    result = result && (hasOutlierDetection() == other.hasOutlierDetection());
    if (hasOutlierDetection()) {
      result = result && getOutlierDetection()
          .equals(other.getOutlierDetection());
    }
    result = result && (hasCleanupInterval() == other.hasCleanupInterval());
    if (hasCleanupInterval()) {
      result = result && getCleanupInterval()
          .equals(other.getCleanupInterval());
    }
    result = result && (hasUpstreamBindConfig() == other.hasUpstreamBindConfig());
    if (hasUpstreamBindConfig()) {
      result = result && getUpstreamBindConfig()
          .equals(other.getUpstreamBindConfig());
    }
    result = result && (hasLbSubsetConfig() == other.hasLbSubsetConfig());
    if (hasLbSubsetConfig()) {
      result = result && getLbSubsetConfig()
          .equals(other.getLbSubsetConfig());
    }
    result = result && (hasCommonLbConfig() == other.hasCommonLbConfig());
    if (hasCommonLbConfig()) {
      result = result && getCommonLbConfig()
          .equals(other.getCommonLbConfig());
    }
    result = result && (hasTransportSocket() == other.hasTransportSocket());
    if (hasTransportSocket()) {
      result = result && getTransportSocket()
          .equals(other.getTransportSocket());
    }
    result = result && (hasMetadata() == other.hasMetadata());
    if (hasMetadata()) {
      result = result && getMetadata()
          .equals(other.getMetadata());
    }
    result = result && protocolSelection_ == other.protocolSelection_;
    result = result && (hasUpstreamConnectionOptions() == other.hasUpstreamConnectionOptions());
    if (hasUpstreamConnectionOptions()) {
      result = result && getUpstreamConnectionOptions()
          .equals(other.getUpstreamConnectionOptions());
    }
    result = result && (getCloseConnectionsOnHostHealthFailure()
        == other.getCloseConnectionsOnHostHealthFailure());
    result = result && (getDrainConnectionsOnHostRemoval()
        == other.getDrainConnectionsOnHostRemoval());
    result = result && getLbConfigCase().equals(
        other.getLbConfigCase());
    if (!result) return false;
    switch (lbConfigCase_) {
      case 23:
        result = result && getRingHashLbConfig()
            .equals(other.getRingHashLbConfig());
        break;
      case 34:
        result = result && getOriginalDstLbConfig()
            .equals(other.getOriginalDstLbConfig());
        break;
      case 37:
        result = result && getLeastRequestLbConfig()
            .equals(other.getLeastRequestLbConfig());
        break;
      case 0:
      default:
    }
    result = result && unknownFields.equals(other.unknownFields);
    return result;
  }

  @java.lang.Override
  public int hashCode() {
    if (memoizedHashCode != 0) {
      return memoizedHashCode;
    }
    int hash = 41;
    hash = (19 * hash) + getDescriptor().hashCode();
    hash = (37 * hash) + NAME_FIELD_NUMBER;
    hash = (53 * hash) + getName().hashCode();
    hash = (37 * hash) + ALT_STAT_NAME_FIELD_NUMBER;
    hash = (53 * hash) + getAltStatName().hashCode();
    hash = (37 * hash) + TYPE_FIELD_NUMBER;
    hash = (53 * hash) + type_;
    if (hasEdsClusterConfig()) {
      hash = (37 * hash) + EDS_CLUSTER_CONFIG_FIELD_NUMBER;
      hash = (53 * hash) + getEdsClusterConfig().hashCode();
    }
    if (hasConnectTimeout()) {
      hash = (37 * hash) + CONNECT_TIMEOUT_FIELD_NUMBER;
      hash = (53 * hash) + getConnectTimeout().hashCode();
    }
    if (hasPerConnectionBufferLimitBytes()) {
      hash = (37 * hash) + PER_CONNECTION_BUFFER_LIMIT_BYTES_FIELD_NUMBER;
      hash = (53 * hash) + getPerConnectionBufferLimitBytes().hashCode();
    }
    hash = (37 * hash) + LB_POLICY_FIELD_NUMBER;
    hash = (53 * hash) + lbPolicy_;
    if (getHostsCount() > 0) {
      hash = (37 * hash) + HOSTS_FIELD_NUMBER;
      hash = (53 * hash) + getHostsList().hashCode();
    }
    if (hasLoadAssignment()) {
      hash = (37 * hash) + LOAD_ASSIGNMENT_FIELD_NUMBER;
      hash = (53 * hash) + getLoadAssignment().hashCode();
    }
    if (getHealthChecksCount() > 0) {
      hash = (37 * hash) + HEALTH_CHECKS_FIELD_NUMBER;
      hash = (53 * hash) + getHealthChecksList().hashCode();
    }
    if (hasMaxRequestsPerConnection()) {
      hash = (37 * hash) + MAX_REQUESTS_PER_CONNECTION_FIELD_NUMBER;
      hash = (53 * hash) + getMaxRequestsPerConnection().hashCode();
    }
    if (hasCircuitBreakers()) {
      hash = (37 * hash) + CIRCUIT_BREAKERS_FIELD_NUMBER;
      hash = (53 * hash) + getCircuitBreakers().hashCode();
    }
    if (hasTlsContext()) {
      hash = (37 * hash) + TLS_CONTEXT_FIELD_NUMBER;
      hash = (53 * hash) + getTlsContext().hashCode();
    }
    if (hasCommonHttpProtocolOptions()) {
      hash = (37 * hash) + COMMON_HTTP_PROTOCOL_OPTIONS_FIELD_NUMBER;
      hash = (53 * hash) + getCommonHttpProtocolOptions().hashCode();
    }
    if (hasHttpProtocolOptions()) {
      hash = (37 * hash) + HTTP_PROTOCOL_OPTIONS_FIELD_NUMBER;
      hash = (53 * hash) + getHttpProtocolOptions().hashCode();
    }
    if (hasHttp2ProtocolOptions()) {
      hash = (37 * hash) + HTTP2_PROTOCOL_OPTIONS_FIELD_NUMBER;
      hash = (53 * hash) + getHttp2ProtocolOptions().hashCode();
    }
    if (!internalGetExtensionProtocolOptions().getMap().isEmpty()) {
      hash = (37 * hash) + EXTENSION_PROTOCOL_OPTIONS_FIELD_NUMBER;
      hash = (53 * hash) + internalGetExtensionProtocolOptions().hashCode();
    }
    if (!internalGetTypedExtensionProtocolOptions().getMap().isEmpty()) {
      hash = (37 * hash) + TYPED_EXTENSION_PROTOCOL_OPTIONS_FIELD_NUMBER;
      hash = (53 * hash) + internalGetTypedExtensionProtocolOptions().hashCode();
    }
    if (hasDnsRefreshRate()) {
      hash = (37 * hash) + DNS_REFRESH_RATE_FIELD_NUMBER;
      hash = (53 * hash) + getDnsRefreshRate().hashCode();
    }
    hash = (37 * hash) + DNS_LOOKUP_FAMILY_FIELD_NUMBER;
    hash = (53 * hash) + dnsLookupFamily_;
    if (getDnsResolversCount() > 0) {
      hash = (37 * hash) + DNS_RESOLVERS_FIELD_NUMBER;
      hash = (53 * hash) + getDnsResolversList().hashCode();
    }
    if (hasOutlierDetection()) {
      hash = (37 * hash) + OUTLIER_DETECTION_FIELD_NUMBER;
      hash = (53 * hash) + getOutlierDetection().hashCode();
    }
    if (hasCleanupInterval()) {
      hash = (37 * hash) + CLEANUP_INTERVAL_FIELD_NUMBER;
      hash = (53 * hash) + getCleanupInterval().hashCode();
    }
    if (hasUpstreamBindConfig()) {
      hash = (37 * hash) + UPSTREAM_BIND_CONFIG_FIELD_NUMBER;
      hash = (53 * hash) + getUpstreamBindConfig().hashCode();
    }
    if (hasLbSubsetConfig()) {
      hash = (37 * hash) + LB_SUBSET_CONFIG_FIELD_NUMBER;
      hash = (53 * hash) + getLbSubsetConfig().hashCode();
    }
    if (hasCommonLbConfig()) {
      hash = (37 * hash) + COMMON_LB_CONFIG_FIELD_NUMBER;
      hash = (53 * hash) + getCommonLbConfig().hashCode();
    }
    if (hasTransportSocket()) {
      hash = (37 * hash) + TRANSPORT_SOCKET_FIELD_NUMBER;
      hash = (53 * hash) + getTransportSocket().hashCode();
    }
    if (hasMetadata()) {
      hash = (37 * hash) + METADATA_FIELD_NUMBER;
      hash = (53 * hash) + getMetadata().hashCode();
    }
    hash = (37 * hash) + PROTOCOL_SELECTION_FIELD_NUMBER;
    hash = (53 * hash) + protocolSelection_;
    if (hasUpstreamConnectionOptions()) {
      hash = (37 * hash) + UPSTREAM_CONNECTION_OPTIONS_FIELD_NUMBER;
      hash = (53 * hash) + getUpstreamConnectionOptions().hashCode();
    }
    hash = (37 * hash) + CLOSE_CONNECTIONS_ON_HOST_HEALTH_FAILURE_FIELD_NUMBER;
    hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
        getCloseConnectionsOnHostHealthFailure());
    hash = (37 * hash) + DRAIN_CONNECTIONS_ON_HOST_REMOVAL_FIELD_NUMBER;
    hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
        getDrainConnectionsOnHostRemoval());
    switch (lbConfigCase_) {
      case 23:
        hash = (37 * hash) + RING_HASH_LB_CONFIG_FIELD_NUMBER;
        hash = (53 * hash) + getRingHashLbConfig().hashCode();
        break;
      case 34:
        hash = (37 * hash) + ORIGINAL_DST_LB_CONFIG_FIELD_NUMBER;
        hash = (53 * hash) + getOriginalDstLbConfig().hashCode();
        break;
      case 37:
        hash = (37 * hash) + LEAST_REQUEST_LB_CONFIG_FIELD_NUMBER;
        hash = (53 * hash) + getLeastRequestLbConfig().hashCode();
        break;
      case 0:
      default:
    }
    hash = (29 * hash) + unknownFields.hashCode();
    memoizedHashCode = hash;
    return hash;
  }

  public static io.grpc.xds.shaded.envoy.api.v2.Cluster parseFrom(
      java.nio.ByteBuffer data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data);
  }
  public static io.grpc.xds.shaded.envoy.api.v2.Cluster parseFrom(
      java.nio.ByteBuffer data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data, extensionRegistry);
  }
  public static io.grpc.xds.shaded.envoy.api.v2.Cluster parseFrom(
      com.google.protobuf.ByteString data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data);
  }
  public static io.grpc.xds.shaded.envoy.api.v2.Cluster parseFrom(
      com.google.protobuf.ByteString data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data, extensionRegistry);
  }
  public static io.grpc.xds.shaded.envoy.api.v2.Cluster parseFrom(byte[] data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data);
  }
  public static io.grpc.xds.shaded.envoy.api.v2.Cluster parseFrom(
      byte[] data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data, extensionRegistry);
  }
  public static io.grpc.xds.shaded.envoy.api.v2.Cluster parseFrom(java.io.InputStream input)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3
        .parseWithIOException(PARSER, input);
  }
  public static io.grpc.xds.shaded.envoy.api.v2.Cluster parseFrom(
      java.io.InputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3
        .parseWithIOException(PARSER, input, extensionRegistry);
  }
  public static io.grpc.xds.shaded.envoy.api.v2.Cluster parseDelimitedFrom(java.io.InputStream input)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3
        .parseDelimitedWithIOException(PARSER, input);
  }
  public static io.grpc.xds.shaded.envoy.api.v2.Cluster parseDelimitedFrom(
      java.io.InputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3
        .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
  }
  public static io.grpc.xds.shaded.envoy.api.v2.Cluster parseFrom(
      com.google.protobuf.CodedInputStream input)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3
        .parseWithIOException(PARSER, input);
  }
  public static io.grpc.xds.shaded.envoy.api.v2.Cluster parseFrom(
      com.google.protobuf.CodedInputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3
        .parseWithIOException(PARSER, input, extensionRegistry);
  }

  public Builder newBuilderForType() { return newBuilder(); }
  public static Builder newBuilder() {
    return DEFAULT_INSTANCE.toBuilder();
  }
  public static Builder newBuilder(io.grpc.xds.shaded.envoy.api.v2.Cluster prototype) {
    return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
  }
  public Builder toBuilder() {
    return this == DEFAULT_INSTANCE
        ? new Builder() : new Builder().mergeFrom(this);
  }

  @java.lang.Override
  protected Builder newBuilderForType(
      com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
    Builder builder = new Builder(parent);
    return builder;
  }
  /**
   * <pre>
   * Configuration for a single upstream cluster.
   * [#comment:next free field: 38]
   * </pre>
   *
   * Protobuf type {@code envoy.api.v2.Cluster}
   */
  public static final class Builder extends
      com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
      // @@protoc_insertion_point(builder_implements:envoy.api.v2.Cluster)
      io.grpc.xds.shaded.envoy.api.v2.ClusterOrBuilder {
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.grpc.xds.shaded.envoy.api.v2.Cds.internal_static_envoy_api_v2_Cluster_descriptor;
    }

    @SuppressWarnings({"rawtypes"})
    protected com.google.protobuf.MapField internalGetMapField(
        int number) {
      switch (number) {
        case 35:
          return internalGetExtensionProtocolOptions();
        case 36:
          return internalGetTypedExtensionProtocolOptions();
        default:
          throw new RuntimeException(
              "Invalid map field number: " + number);
      }
    }
    @SuppressWarnings({"rawtypes"})
    protected com.google.protobuf.MapField internalGetMutableMapField(
        int number) {
      switch (number) {
        case 35:
          return internalGetMutableExtensionProtocolOptions();
        case 36:
          return internalGetMutableTypedExtensionProtocolOptions();
        default:
          throw new RuntimeException(
              "Invalid map field number: " + number);
      }
    }
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.grpc.xds.shaded.envoy.api.v2.Cds.internal_static_envoy_api_v2_Cluster_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.grpc.xds.shaded.envoy.api.v2.Cluster.class, io.grpc.xds.shaded.envoy.api.v2.Cluster.Builder.class);
    }

    // Construct using io.grpc.xds.shaded.envoy.api.v2.Cluster.newBuilder()
    private Builder() {
      maybeForceBuilderInitialization();
    }

    private Builder(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      super(parent);
      maybeForceBuilderInitialization();
    }
    private void maybeForceBuilderInitialization() {
      if (com.google.protobuf.GeneratedMessageV3
              .alwaysUseFieldBuilders) {
        getHostsFieldBuilder();
        getHealthChecksFieldBuilder();
        getDnsResolversFieldBuilder();
      }
    }
    public Builder clear() {
      super.clear();
      name_ = "";

      altStatName_ = "";

      type_ = 0;

      if (edsClusterConfigBuilder_ == null) {
        edsClusterConfig_ = null;
      } else {
        edsClusterConfig_ = null;
        edsClusterConfigBuilder_ = null;
      }
      if (connectTimeoutBuilder_ == null) {
        connectTimeout_ = null;
      } else {
        connectTimeout_ = null;
        connectTimeoutBuilder_ = null;
      }
      if (perConnectionBufferLimitBytesBuilder_ == null) {
        perConnectionBufferLimitBytes_ = null;
      } else {
        perConnectionBufferLimitBytes_ = null;
        perConnectionBufferLimitBytesBuilder_ = null;
      }
      lbPolicy_ = 0;

      if (hostsBuilder_ == null) {
        hosts_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x00000080);
      } else {
        hostsBuilder_.clear();
      }
      if (loadAssignmentBuilder_ == null) {
        loadAssignment_ = null;
      } else {
        loadAssignment_ = null;
        loadAssignmentBuilder_ = null;
      }
      if (healthChecksBuilder_ == null) {
        healthChecks_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x00000200);
      } else {
        healthChecksBuilder_.clear();
      }
      if (maxRequestsPerConnectionBuilder_ == null) {
        maxRequestsPerConnection_ = null;
      } else {
        maxRequestsPerConnection_ = null;
        maxRequestsPerConnectionBuilder_ = null;
      }
      if (circuitBreakersBuilder_ == null) {
        circuitBreakers_ = null;
      } else {
        circuitBreakers_ = null;
        circuitBreakersBuilder_ = null;
      }
      if (tlsContextBuilder_ == null) {
        tlsContext_ = null;
      } else {
        tlsContext_ = null;
        tlsContextBuilder_ = null;
      }
      if (commonHttpProtocolOptionsBuilder_ == null) {
        commonHttpProtocolOptions_ = null;
      } else {
        commonHttpProtocolOptions_ = null;
        commonHttpProtocolOptionsBuilder_ = null;
      }
      if (httpProtocolOptionsBuilder_ == null) {
        httpProtocolOptions_ = null;
      } else {
        httpProtocolOptions_ = null;
        httpProtocolOptionsBuilder_ = null;
      }
      if (http2ProtocolOptionsBuilder_ == null) {
        http2ProtocolOptions_ = null;
      } else {
        http2ProtocolOptions_ = null;
        http2ProtocolOptionsBuilder_ = null;
      }
      internalGetMutableExtensionProtocolOptions().clear();
      internalGetMutableTypedExtensionProtocolOptions().clear();
      if (dnsRefreshRateBuilder_ == null) {
        dnsRefreshRate_ = null;
      } else {
        dnsRefreshRate_ = null;
        dnsRefreshRateBuilder_ = null;
      }
      dnsLookupFamily_ = 0;

      if (dnsResolversBuilder_ == null) {
        dnsResolvers_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x00100000);
      } else {
        dnsResolversBuilder_.clear();
      }
      if (outlierDetectionBuilder_ == null) {
        outlierDetection_ = null;
      } else {
        outlierDetection_ = null;
        outlierDetectionBuilder_ = null;
      }
      if (cleanupIntervalBuilder_ == null) {
        cleanupInterval_ = null;
      } else {
        cleanupInterval_ = null;
        cleanupIntervalBuilder_ = null;
      }
      if (upstreamBindConfigBuilder_ == null) {
        upstreamBindConfig_ = null;
      } else {
        upstreamBindConfig_ = null;
        upstreamBindConfigBuilder_ = null;
      }
      if (lbSubsetConfigBuilder_ == null) {
        lbSubsetConfig_ = null;
      } else {
        lbSubsetConfig_ = null;
        lbSubsetConfigBuilder_ = null;
      }
      if (commonLbConfigBuilder_ == null) {
        commonLbConfig_ = null;
      } else {
        commonLbConfig_ = null;
        commonLbConfigBuilder_ = null;
      }
      if (transportSocketBuilder_ == null) {
        transportSocket_ = null;
      } else {
        transportSocket_ = null;
        transportSocketBuilder_ = null;
      }
      if (metadataBuilder_ == null) {
        metadata_ = null;
      } else {
        metadata_ = null;
        metadataBuilder_ = null;
      }
      protocolSelection_ = 0;

      if (upstreamConnectionOptionsBuilder_ == null) {
        upstreamConnectionOptions_ = null;
      } else {
        upstreamConnectionOptions_ = null;
        upstreamConnectionOptionsBuilder_ = null;
      }
      closeConnectionsOnHostHealthFailure_ = false;

      drainConnectionsOnHostRemoval_ = false;

      lbConfigCase_ = 0;
      lbConfig_ = null;
      return this;
    }

    public com.google.protobuf.Descriptors.Descriptor
        getDescriptorForType() {
      return io.grpc.xds.shaded.envoy.api.v2.Cds.internal_static_envoy_api_v2_Cluster_descriptor;
    }

    public io.grpc.xds.shaded.envoy.api.v2.Cluster getDefaultInstanceForType() {
      return io.grpc.xds.shaded.envoy.api.v2.Cluster.getDefaultInstance();
    }

    public io.grpc.xds.shaded.envoy.api.v2.Cluster build() {
      io.grpc.xds.shaded.envoy.api.v2.Cluster result = buildPartial();
      if (!result.isInitialized()) {
        throw newUninitializedMessageException(result);
      }
      return result;
    }

    public io.grpc.xds.shaded.envoy.api.v2.Cluster buildPartial() {
      io.grpc.xds.shaded.envoy.api.v2.Cluster result = new io.grpc.xds.shaded.envoy.api.v2.Cluster(this);
      int from_bitField0_ = bitField0_;
      int from_bitField1_ = bitField1_;
      int to_bitField0_ = 0;
      result.name_ = name_;
      result.altStatName_ = altStatName_;
      result.type_ = type_;
      if (edsClusterConfigBuilder_ == null) {
        result.edsClusterConfig_ = edsClusterConfig_;
      } else {
        result.edsClusterConfig_ = edsClusterConfigBuilder_.build();
      }
      if (connectTimeoutBuilder_ == null) {
        result.connectTimeout_ = connectTimeout_;
      } else {
        result.connectTimeout_ = connectTimeoutBuilder_.build();
      }
      if (perConnectionBufferLimitBytesBuilder_ == null) {
        result.perConnectionBufferLimitBytes_ = perConnectionBufferLimitBytes_;
      } else {
        result.perConnectionBufferLimitBytes_ = perConnectionBufferLimitBytesBuilder_.build();
      }
      result.lbPolicy_ = lbPolicy_;
      if (hostsBuilder_ == null) {
        if (((bitField0_ & 0x00000080) == 0x00000080)) {
          hosts_ = java.util.Collections.unmodifiableList(hosts_);
          bitField0_ = (bitField0_ & ~0x00000080);
        }
        result.hosts_ = hosts_;
      } else {
        result.hosts_ = hostsBuilder_.build();
      }
      if (loadAssignmentBuilder_ == null) {
        result.loadAssignment_ = loadAssignment_;
      } else {
        result.loadAssignment_ = loadAssignmentBuilder_.build();
      }
      if (healthChecksBuilder_ == null) {
        if (((bitField0_ & 0x00000200) == 0x00000200)) {
          healthChecks_ = java.util.Collections.unmodifiableList(healthChecks_);
          bitField0_ = (bitField0_ & ~0x00000200);
        }
        result.healthChecks_ = healthChecks_;
      } else {
        result.healthChecks_ = healthChecksBuilder_.build();
      }
      if (maxRequestsPerConnectionBuilder_ == null) {
        result.maxRequestsPerConnection_ = maxRequestsPerConnection_;
      } else {
        result.maxRequestsPerConnection_ = maxRequestsPerConnectionBuilder_.build();
      }
      if (circuitBreakersBuilder_ == null) {
        result.circuitBreakers_ = circuitBreakers_;
      } else {
        result.circuitBreakers_ = circuitBreakersBuilder_.build();
      }
      if (tlsContextBuilder_ == null) {
        result.tlsContext_ = tlsContext_;
      } else {
        result.tlsContext_ = tlsContextBuilder_.build();
      }
      if (commonHttpProtocolOptionsBuilder_ == null) {
        result.commonHttpProtocolOptions_ = commonHttpProtocolOptions_;
      } else {
        result.commonHttpProtocolOptions_ = commonHttpProtocolOptionsBuilder_.build();
      }
      if (httpProtocolOptionsBuilder_ == null) {
        result.httpProtocolOptions_ = httpProtocolOptions_;
      } else {
        result.httpProtocolOptions_ = httpProtocolOptionsBuilder_.build();
      }
      if (http2ProtocolOptionsBuilder_ == null) {
        result.http2ProtocolOptions_ = http2ProtocolOptions_;
      } else {
        result.http2ProtocolOptions_ = http2ProtocolOptionsBuilder_.build();
      }
      result.extensionProtocolOptions_ = internalGetExtensionProtocolOptions();
      result.extensionProtocolOptions_.makeImmutable();
      result.typedExtensionProtocolOptions_ = internalGetTypedExtensionProtocolOptions();
      result.typedExtensionProtocolOptions_.makeImmutable();
      if (dnsRefreshRateBuilder_ == null) {
        result.dnsRefreshRate_ = dnsRefreshRate_;
      } else {
        result.dnsRefreshRate_ = dnsRefreshRateBuilder_.build();
      }
      result.dnsLookupFamily_ = dnsLookupFamily_;
      if (dnsResolversBuilder_ == null) {
        if (((bitField0_ & 0x00100000) == 0x00100000)) {
          dnsResolvers_ = java.util.Collections.unmodifiableList(dnsResolvers_);
          bitField0_ = (bitField0_ & ~0x00100000);
        }
        result.dnsResolvers_ = dnsResolvers_;
      } else {
        result.dnsResolvers_ = dnsResolversBuilder_.build();
      }
      if (outlierDetectionBuilder_ == null) {
        result.outlierDetection_ = outlierDetection_;
      } else {
        result.outlierDetection_ = outlierDetectionBuilder_.build();
      }
      if (cleanupIntervalBuilder_ == null) {
        result.cleanupInterval_ = cleanupInterval_;
      } else {
        result.cleanupInterval_ = cleanupIntervalBuilder_.build();
      }
      if (upstreamBindConfigBuilder_ == null) {
        result.upstreamBindConfig_ = upstreamBindConfig_;
      } else {
        result.upstreamBindConfig_ = upstreamBindConfigBuilder_.build();
      }
      if (lbSubsetConfigBuilder_ == null) {
        result.lbSubsetConfig_ = lbSubsetConfig_;
      } else {
        result.lbSubsetConfig_ = lbSubsetConfigBuilder_.build();
      }
      if (lbConfigCase_ == 23) {
        if (ringHashLbConfigBuilder_ == null) {
          result.lbConfig_ = lbConfig_;
        } else {
          result.lbConfig_ = ringHashLbConfigBuilder_.build();
        }
      }
      if (lbConfigCase_ == 34) {
        if (originalDstLbConfigBuilder_ == null) {
          result.lbConfig_ = lbConfig_;
        } else {
          result.lbConfig_ = originalDstLbConfigBuilder_.build();
        }
      }
      if (lbConfigCase_ == 37) {
        if (leastRequestLbConfigBuilder_ == null) {
          result.lbConfig_ = lbConfig_;
        } else {
          result.lbConfig_ = leastRequestLbConfigBuilder_.build();
        }
      }
      if (commonLbConfigBuilder_ == null) {
        result.commonLbConfig_ = commonLbConfig_;
      } else {
        result.commonLbConfig_ = commonLbConfigBuilder_.build();
      }
      if (transportSocketBuilder_ == null) {
        result.transportSocket_ = transportSocket_;
      } else {
        result.transportSocket_ = transportSocketBuilder_.build();
      }
      if (metadataBuilder_ == null) {
        result.metadata_ = metadata_;
      } else {
        result.metadata_ = metadataBuilder_.build();
      }
      result.protocolSelection_ = protocolSelection_;
      if (upstreamConnectionOptionsBuilder_ == null) {
        result.upstreamConnectionOptions_ = upstreamConnectionOptions_;
      } else {
        result.upstreamConnectionOptions_ = upstreamConnectionOptionsBuilder_.build();
      }
      result.closeConnectionsOnHostHealthFailure_ = closeConnectionsOnHostHealthFailure_;
      result.drainConnectionsOnHostRemoval_ = drainConnectionsOnHostRemoval_;
      result.bitField0_ = to_bitField0_;
      result.lbConfigCase_ = lbConfigCase_;
      onBuilt();
      return result;
    }

    public Builder clone() {
      return (Builder) super.clone();
    }
    public Builder setField(
        com.google.protobuf.Descriptors.FieldDescriptor field,
        java.lang.Object value) {
      return (Builder) super.setField(field, value);
    }
    public Builder clearField(
        com.google.protobuf.Descriptors.FieldDescriptor field) {
      return (Builder) super.clearField(field);
    }
    public Builder clearOneof(
        com.google.protobuf.Descriptors.OneofDescriptor oneof) {
      return (Builder) super.clearOneof(oneof);
    }
    public Builder setRepeatedField(
        com.google.protobuf.Descriptors.FieldDescriptor field,
        int index, java.lang.Object value) {
      return (Builder) super.setRepeatedField(field, index, value);
    }
    public Builder addRepeatedField(
        com.google.protobuf.Descriptors.FieldDescriptor field,
        java.lang.Object value) {
      return (Builder) super.addRepeatedField(field, value);
    }
    public Builder mergeFrom(com.google.protobuf.Message other) {
      if (other instanceof io.grpc.xds.shaded.envoy.api.v2.Cluster) {
        return mergeFrom((io.grpc.xds.shaded.envoy.api.v2.Cluster)other);
      } else {
        super.mergeFrom(other);
        return this;
      }
    }

    public Builder mergeFrom(io.grpc.xds.shaded.envoy.api.v2.Cluster other) {
      if (other == io.grpc.xds.shaded.envoy.api.v2.Cluster.getDefaultInstance()) return this;
      if (!other.getName().isEmpty()) {
        name_ = other.name_;
        onChanged();
      }
      if (!other.getAltStatName().isEmpty()) {
        altStatName_ = other.altStatName_;
        onChanged();
      }
      if (other.type_ != 0) {
        setTypeValue(other.getTypeValue());
      }
      if (other.hasEdsClusterConfig()) {
        mergeEdsClusterConfig(other.getEdsClusterConfig());
      }
      if (other.hasConnectTimeout()) {
        mergeConnectTimeout(other.getConnectTimeout());
      }
      if (other.hasPerConnectionBufferLimitBytes()) {
        mergePerConnectionBufferLimitBytes(other.getPerConnectionBufferLimitBytes());
      }
      if (other.lbPolicy_ != 0) {
        setLbPolicyValue(other.getLbPolicyValue());
      }
      if (hostsBuilder_ == null) {
        if (!other.hosts_.isEmpty()) {
          if (hosts_.isEmpty()) {
            hosts_ = other.hosts_;
            bitField0_ = (bitField0_ & ~0x00000080);
          } else {
            ensureHostsIsMutable();
            hosts_.addAll(other.hosts_);
          }
          onChanged();
        }
      } else {
        if (!other.hosts_.isEmpty()) {
          if (hostsBuilder_.isEmpty()) {
            hostsBuilder_.dispose();
            hostsBuilder_ = null;
            hosts_ = other.hosts_;
            bitField0_ = (bitField0_ & ~0x00000080);
            hostsBuilder_ = 
              com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                 getHostsFieldBuilder() : null;
          } else {
            hostsBuilder_.addAllMessages(other.hosts_);
          }
        }
      }
      if (other.hasLoadAssignment()) {
        mergeLoadAssignment(other.getLoadAssignment());
      }
      if (healthChecksBuilder_ == null) {
        if (!other.healthChecks_.isEmpty()) {
          if (healthChecks_.isEmpty()) {
            healthChecks_ = other.healthChecks_;
            bitField0_ = (bitField0_ & ~0x00000200);
          } else {
            ensureHealthChecksIsMutable();
            healthChecks_.addAll(other.healthChecks_);
          }
          onChanged();
        }
      } else {
        if (!other.healthChecks_.isEmpty()) {
          if (healthChecksBuilder_.isEmpty()) {
            healthChecksBuilder_.dispose();
            healthChecksBuilder_ = null;
            healthChecks_ = other.healthChecks_;
            bitField0_ = (bitField0_ & ~0x00000200);
            healthChecksBuilder_ = 
              com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                 getHealthChecksFieldBuilder() : null;
          } else {
            healthChecksBuilder_.addAllMessages(other.healthChecks_);
          }
        }
      }
      if (other.hasMaxRequestsPerConnection()) {
        mergeMaxRequestsPerConnection(other.getMaxRequestsPerConnection());
      }
      if (other.hasCircuitBreakers()) {
        mergeCircuitBreakers(other.getCircuitBreakers());
      }
      if (other.hasTlsContext()) {
        mergeTlsContext(other.getTlsContext());
      }
      if (other.hasCommonHttpProtocolOptions()) {
        mergeCommonHttpProtocolOptions(other.getCommonHttpProtocolOptions());
      }
      if (other.hasHttpProtocolOptions()) {
        mergeHttpProtocolOptions(other.getHttpProtocolOptions());
      }
      if (other.hasHttp2ProtocolOptions()) {
        mergeHttp2ProtocolOptions(other.getHttp2ProtocolOptions());
      }
      internalGetMutableExtensionProtocolOptions().mergeFrom(
          other.internalGetExtensionProtocolOptions());
      internalGetMutableTypedExtensionProtocolOptions().mergeFrom(
          other.internalGetTypedExtensionProtocolOptions());
      if (other.hasDnsRefreshRate()) {
        mergeDnsRefreshRate(other.getDnsRefreshRate());
      }
      if (other.dnsLookupFamily_ != 0) {
        setDnsLookupFamilyValue(other.getDnsLookupFamilyValue());
      }
      if (dnsResolversBuilder_ == null) {
        if (!other.dnsResolvers_.isEmpty()) {
          if (dnsResolvers_.isEmpty()) {
            dnsResolvers_ = other.dnsResolvers_;
            bitField0_ = (bitField0_ & ~0x00100000);
          } else {
            ensureDnsResolversIsMutable();
            dnsResolvers_.addAll(other.dnsResolvers_);
          }
          onChanged();
        }
      } else {
        if (!other.dnsResolvers_.isEmpty()) {
          if (dnsResolversBuilder_.isEmpty()) {
            dnsResolversBuilder_.dispose();
            dnsResolversBuilder_ = null;
            dnsResolvers_ = other.dnsResolvers_;
            bitField0_ = (bitField0_ & ~0x00100000);
            dnsResolversBuilder_ = 
              com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                 getDnsResolversFieldBuilder() : null;
          } else {
            dnsResolversBuilder_.addAllMessages(other.dnsResolvers_);
          }
        }
      }
      if (other.hasOutlierDetection()) {
        mergeOutlierDetection(other.getOutlierDetection());
      }
      if (other.hasCleanupInterval()) {
        mergeCleanupInterval(other.getCleanupInterval());
      }
      if (other.hasUpstreamBindConfig()) {
        mergeUpstreamBindConfig(other.getUpstreamBindConfig());
      }
      if (other.hasLbSubsetConfig()) {
        mergeLbSubsetConfig(other.getLbSubsetConfig());
      }
      if (other.hasCommonLbConfig()) {
        mergeCommonLbConfig(other.getCommonLbConfig());
      }
      if (other.hasTransportSocket()) {
        mergeTransportSocket(other.getTransportSocket());
      }
      if (other.hasMetadata()) {
        mergeMetadata(other.getMetadata());
      }
      if (other.protocolSelection_ != 0) {
        setProtocolSelectionValue(other.getProtocolSelectionValue());
      }
      if (other.hasUpstreamConnectionOptions()) {
        mergeUpstreamConnectionOptions(other.getUpstreamConnectionOptions());
      }
      if (other.getCloseConnectionsOnHostHealthFailure() != false) {
        setCloseConnectionsOnHostHealthFailure(other.getCloseConnectionsOnHostHealthFailure());
      }
      if (other.getDrainConnectionsOnHostRemoval() != false) {
        setDrainConnectionsOnHostRemoval(other.getDrainConnectionsOnHostRemoval());
      }
      switch (other.getLbConfigCase()) {
        case RING_HASH_LB_CONFIG: {
          mergeRingHashLbConfig(other.getRingHashLbConfig());
          break;
        }
        case ORIGINAL_DST_LB_CONFIG: {
          mergeOriginalDstLbConfig(other.getOriginalDstLbConfig());
          break;
        }
        case LEAST_REQUEST_LB_CONFIG: {
          mergeLeastRequestLbConfig(other.getLeastRequestLbConfig());
          break;
        }
        case LBCONFIG_NOT_SET: {
          break;
        }
      }
      this.mergeUnknownFields(other.unknownFields);
      onChanged();
      return this;
    }

    public final boolean isInitialized() {
      return true;
    }

    public Builder mergeFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      io.grpc.xds.shaded.envoy.api.v2.Cluster parsedMessage = null;
      try {
        parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        parsedMessage = (io.grpc.xds.shaded.envoy.api.v2.Cluster) e.getUnfinishedMessage();
        throw e.unwrapIOException();
      } finally {
        if (parsedMessage != null) {
          mergeFrom(parsedMessage);
        }
      }
      return this;
    }
    private int lbConfigCase_ = 0;
    private java.lang.Object lbConfig_;
    public LbConfigCase
        getLbConfigCase() {
      return LbConfigCase.forNumber(
          lbConfigCase_);
    }

    public Builder clearLbConfig() {
      lbConfigCase_ = 0;
      lbConfig_ = null;
      onChanged();
      return this;
    }

    private int bitField0_;
    private int bitField1_;

    private java.lang.Object name_ = "";
    /**
     * <pre>
     * Supplies the name of the cluster which must be unique across all clusters.
     * The cluster name is used when emitting
     * :ref:`statistics &lt;config_cluster_manager_cluster_stats&gt;` if :ref:`alt_stat_name
     * &lt;envoy_api_field_Cluster.alt_stat_name&gt;` is not provided.
     * Any ``:`` in the cluster name will be converted to ``_`` when emitting statistics.
     * By default, the maximum length of a cluster name is limited to 60
     * characters. This limit can be increased by setting the
     * :option:`--max-obj-name-len` command line argument to the desired value.
     * </pre>
     *
     * <code>string name = 1 [(.validate.rules) = { ... }</code>
     */
    public java.lang.String getName() {
      java.lang.Object ref = name_;
      if (!(ref instanceof java.lang.String)) {
        com.google.protobuf.ByteString bs =
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        name_ = s;
        return s;
      } else {
        return (java.lang.String) ref;
      }
    }
    /**
     * <pre>
     * Supplies the name of the cluster which must be unique across all clusters.
     * The cluster name is used when emitting
     * :ref:`statistics &lt;config_cluster_manager_cluster_stats&gt;` if :ref:`alt_stat_name
     * &lt;envoy_api_field_Cluster.alt_stat_name&gt;` is not provided.
     * Any ``:`` in the cluster name will be converted to ``_`` when emitting statistics.
     * By default, the maximum length of a cluster name is limited to 60
     * characters. This limit can be increased by setting the
     * :option:`--max-obj-name-len` command line argument to the desired value.
     * </pre>
     *
     * <code>string name = 1 [(.validate.rules) = { ... }</code>
     */
    public com.google.protobuf.ByteString
        getNameBytes() {
      java.lang.Object ref = name_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        name_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }
    /**
     * <pre>
     * Supplies the name of the cluster which must be unique across all clusters.
     * The cluster name is used when emitting
     * :ref:`statistics &lt;config_cluster_manager_cluster_stats&gt;` if :ref:`alt_stat_name
     * &lt;envoy_api_field_Cluster.alt_stat_name&gt;` is not provided.
     * Any ``:`` in the cluster name will be converted to ``_`` when emitting statistics.
     * By default, the maximum length of a cluster name is limited to 60
     * characters. This limit can be increased by setting the
     * :option:`--max-obj-name-len` command line argument to the desired value.
     * </pre>
     *
     * <code>string name = 1 [(.validate.rules) = { ... }</code>
     */
    public Builder setName(
        java.lang.String value) {
      if (value == null) {
    throw new NullPointerException();
  }
  
      name_ = value;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Supplies the name of the cluster which must be unique across all clusters.
     * The cluster name is used when emitting
     * :ref:`statistics &lt;config_cluster_manager_cluster_stats&gt;` if :ref:`alt_stat_name
     * &lt;envoy_api_field_Cluster.alt_stat_name&gt;` is not provided.
     * Any ``:`` in the cluster name will be converted to ``_`` when emitting statistics.
     * By default, the maximum length of a cluster name is limited to 60
     * characters. This limit can be increased by setting the
     * :option:`--max-obj-name-len` command line argument to the desired value.
     * </pre>
     *
     * <code>string name = 1 [(.validate.rules) = { ... }</code>
     */
    public Builder clearName() {
      
      name_ = getDefaultInstance().getName();
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Supplies the name of the cluster which must be unique across all clusters.
     * The cluster name is used when emitting
     * :ref:`statistics &lt;config_cluster_manager_cluster_stats&gt;` if :ref:`alt_stat_name
     * &lt;envoy_api_field_Cluster.alt_stat_name&gt;` is not provided.
     * Any ``:`` in the cluster name will be converted to ``_`` when emitting statistics.
     * By default, the maximum length of a cluster name is limited to 60
     * characters. This limit can be increased by setting the
     * :option:`--max-obj-name-len` command line argument to the desired value.
     * </pre>
     *
     * <code>string name = 1 [(.validate.rules) = { ... }</code>
     */
    public Builder setNameBytes(
        com.google.protobuf.ByteString value) {
      if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
      
      name_ = value;
      onChanged();
      return this;
    }

    private java.lang.Object altStatName_ = "";
    /**
     * <pre>
     * An optional alternative to the cluster name to be used while emitting stats.
     * Any ``:`` in the name will be converted to ``_`` when emitting statistics. This should not be
     * confused with :ref:`Router Filter Header
     * &lt;config_http_filters_router_x-envoy-upstream-alt-stat-name&gt;`.
     * </pre>
     *
     * <code>string alt_stat_name = 28;</code>
     */
    public java.lang.String getAltStatName() {
      java.lang.Object ref = altStatName_;
      if (!(ref instanceof java.lang.String)) {
        com.google.protobuf.ByteString bs =
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        altStatName_ = s;
        return s;
      } else {
        return (java.lang.String) ref;
      }
    }
    /**
     * <pre>
     * An optional alternative to the cluster name to be used while emitting stats.
     * Any ``:`` in the name will be converted to ``_`` when emitting statistics. This should not be
     * confused with :ref:`Router Filter Header
     * &lt;config_http_filters_router_x-envoy-upstream-alt-stat-name&gt;`.
     * </pre>
     *
     * <code>string alt_stat_name = 28;</code>
     */
    public com.google.protobuf.ByteString
        getAltStatNameBytes() {
      java.lang.Object ref = altStatName_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        altStatName_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }
    /**
     * <pre>
     * An optional alternative to the cluster name to be used while emitting stats.
     * Any ``:`` in the name will be converted to ``_`` when emitting statistics. This should not be
     * confused with :ref:`Router Filter Header
     * &lt;config_http_filters_router_x-envoy-upstream-alt-stat-name&gt;`.
     * </pre>
     *
     * <code>string alt_stat_name = 28;</code>
     */
    public Builder setAltStatName(
        java.lang.String value) {
      if (value == null) {
    throw new NullPointerException();
  }
  
      altStatName_ = value;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * An optional alternative to the cluster name to be used while emitting stats.
     * Any ``:`` in the name will be converted to ``_`` when emitting statistics. This should not be
     * confused with :ref:`Router Filter Header
     * &lt;config_http_filters_router_x-envoy-upstream-alt-stat-name&gt;`.
     * </pre>
     *
     * <code>string alt_stat_name = 28;</code>
     */
    public Builder clearAltStatName() {
      
      altStatName_ = getDefaultInstance().getAltStatName();
      onChanged();
      return this;
    }
    /**
     * <pre>
     * An optional alternative to the cluster name to be used while emitting stats.
     * Any ``:`` in the name will be converted to ``_`` when emitting statistics. This should not be
     * confused with :ref:`Router Filter Header
     * &lt;config_http_filters_router_x-envoy-upstream-alt-stat-name&gt;`.
     * </pre>
     *
     * <code>string alt_stat_name = 28;</code>
     */
    public Builder setAltStatNameBytes(
        com.google.protobuf.ByteString value) {
      if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
      
      altStatName_ = value;
      onChanged();
      return this;
    }

    private int type_ = 0;
    /**
     * <pre>
     * The :ref:`service discovery type &lt;arch_overview_service_discovery_types&gt;`
     * to use for resolving the cluster.
     * </pre>
     *
     * <code>.envoy.api.v2.Cluster.DiscoveryType type = 2 [(.validate.rules) = { ... }</code>
     */
    public int getTypeValue() {
      return type_;
    }
    /**
     * <pre>
     * The :ref:`service discovery type &lt;arch_overview_service_discovery_types&gt;`
     * to use for resolving the cluster.
     * </pre>
     *
     * <code>.envoy.api.v2.Cluster.DiscoveryType type = 2 [(.validate.rules) = { ... }</code>
     */
    public Builder setTypeValue(int value) {
      type_ = value;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * The :ref:`service discovery type &lt;arch_overview_service_discovery_types&gt;`
     * to use for resolving the cluster.
     * </pre>
     *
     * <code>.envoy.api.v2.Cluster.DiscoveryType type = 2 [(.validate.rules) = { ... }</code>
     */
    public io.grpc.xds.shaded.envoy.api.v2.Cluster.DiscoveryType getType() {
      io.grpc.xds.shaded.envoy.api.v2.Cluster.DiscoveryType result = io.grpc.xds.shaded.envoy.api.v2.Cluster.DiscoveryType.valueOf(type_);
      return result == null ? io.grpc.xds.shaded.envoy.api.v2.Cluster.DiscoveryType.UNRECOGNIZED : result;
    }
    /**
     * <pre>
     * The :ref:`service discovery type &lt;arch_overview_service_discovery_types&gt;`
     * to use for resolving the cluster.
     * </pre>
     *
     * <code>.envoy.api.v2.Cluster.DiscoveryType type = 2 [(.validate.rules) = { ... }</code>
     */
    public Builder setType(io.grpc.xds.shaded.envoy.api.v2.Cluster.DiscoveryType value) {
      if (value == null) {
        throw new NullPointerException();
      }
      
      type_ = value.getNumber();
      onChanged();
      return this;
    }
    /**
     * <pre>
     * The :ref:`service discovery type &lt;arch_overview_service_discovery_types&gt;`
     * to use for resolving the cluster.
     * </pre>
     *
     * <code>.envoy.api.v2.Cluster.DiscoveryType type = 2 [(.validate.rules) = { ... }</code>
     */
    public Builder clearType() {
      
      type_ = 0;
      onChanged();
      return this;
    }

    private io.grpc.xds.shaded.envoy.api.v2.Cluster.EdsClusterConfig edsClusterConfig_ = null;
    private com.google.protobuf.SingleFieldBuilderV3<
        io.grpc.xds.shaded.envoy.api.v2.Cluster.EdsClusterConfig, io.grpc.xds.shaded.envoy.api.v2.Cluster.EdsClusterConfig.Builder, io.grpc.xds.shaded.envoy.api.v2.Cluster.EdsClusterConfigOrBuilder> edsClusterConfigBuilder_;
    /**
     * <pre>
     * Configuration to use for EDS updates for the Cluster.
     * </pre>
     *
     * <code>.envoy.api.v2.Cluster.EdsClusterConfig eds_cluster_config = 3;</code>
     */
    public boolean hasEdsClusterConfig() {
      return edsClusterConfigBuilder_ != null || edsClusterConfig_ != null;
    }
    /**
     * <pre>
     * Configuration to use for EDS updates for the Cluster.
     * </pre>
     *
     * <code>.envoy.api.v2.Cluster.EdsClusterConfig eds_cluster_config = 3;</code>
     */
    public io.grpc.xds.shaded.envoy.api.v2.Cluster.EdsClusterConfig getEdsClusterConfig() {
      if (edsClusterConfigBuilder_ == null) {
        return edsClusterConfig_ == null ? io.grpc.xds.shaded.envoy.api.v2.Cluster.EdsClusterConfig.getDefaultInstance() : edsClusterConfig_;
      } else {
        return edsClusterConfigBuilder_.getMessage();
      }
    }
    /**
     * <pre>
     * Configuration to use for EDS updates for the Cluster.
     * </pre>
     *
     * <code>.envoy.api.v2.Cluster.EdsClusterConfig eds_cluster_config = 3;</code>
     */
    public Builder setEdsClusterConfig(io.grpc.xds.shaded.envoy.api.v2.Cluster.EdsClusterConfig value) {
      if (edsClusterConfigBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        edsClusterConfig_ = value;
        onChanged();
      } else {
        edsClusterConfigBuilder_.setMessage(value);
      }

      return this;
    }
    /**
     * <pre>
     * Configuration to use for EDS updates for the Cluster.
     * </pre>
     *
     * <code>.envoy.api.v2.Cluster.EdsClusterConfig eds_cluster_config = 3;</code>
     */
    public Builder setEdsClusterConfig(
        io.grpc.xds.shaded.envoy.api.v2.Cluster.EdsClusterConfig.Builder builderForValue) {
      if (edsClusterConfigBuilder_ == null) {
        edsClusterConfig_ = builderForValue.build();
        onChanged();
      } else {
        edsClusterConfigBuilder_.setMessage(builderForValue.build());
      }

      return this;
    }
    /**
     * <pre>
     * Configuration to use for EDS updates for the Cluster.
     * </pre>
     *
     * <code>.envoy.api.v2.Cluster.EdsClusterConfig eds_cluster_config = 3;</code>
     */
    public Builder mergeEdsClusterConfig(io.grpc.xds.shaded.envoy.api.v2.Cluster.EdsClusterConfig value) {
      if (edsClusterConfigBuilder_ == null) {
        if (edsClusterConfig_ != null) {
          edsClusterConfig_ =
            io.grpc.xds.shaded.envoy.api.v2.Cluster.EdsClusterConfig.newBuilder(edsClusterConfig_).mergeFrom(value).buildPartial();
        } else {
          edsClusterConfig_ = value;
        }
        onChanged();
      } else {
        edsClusterConfigBuilder_.mergeFrom(value);
      }

      return this;
    }
    /**
     * <pre>
     * Configuration to use for EDS updates for the Cluster.
     * </pre>
     *
     * <code>.envoy.api.v2.Cluster.EdsClusterConfig eds_cluster_config = 3;</code>
     */
    public Builder clearEdsClusterConfig() {
      if (edsClusterConfigBuilder_ == null) {
        edsClusterConfig_ = null;
        onChanged();
      } else {
        edsClusterConfig_ = null;
        edsClusterConfigBuilder_ = null;
      }

      return this;
    }
    /**
     * <pre>
     * Configuration to use for EDS updates for the Cluster.
     * </pre>
     *
     * <code>.envoy.api.v2.Cluster.EdsClusterConfig eds_cluster_config = 3;</code>
     */
    public io.grpc.xds.shaded.envoy.api.v2.Cluster.EdsClusterConfig.Builder getEdsClusterConfigBuilder() {
      
      onChanged();
      return getEdsClusterConfigFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * Configuration to use for EDS updates for the Cluster.
     * </pre>
     *
     * <code>.envoy.api.v2.Cluster.EdsClusterConfig eds_cluster_config = 3;</code>
     */
    public io.grpc.xds.shaded.envoy.api.v2.Cluster.EdsClusterConfigOrBuilder getEdsClusterConfigOrBuilder() {
      if (edsClusterConfigBuilder_ != null) {
        return edsClusterConfigBuilder_.getMessageOrBuilder();
      } else {
        return edsClusterConfig_ == null ?
            io.grpc.xds.shaded.envoy.api.v2.Cluster.EdsClusterConfig.getDefaultInstance() : edsClusterConfig_;
      }
    }
    /**
     * <pre>
     * Configuration to use for EDS updates for the Cluster.
     * </pre>
     *
     * <code>.envoy.api.v2.Cluster.EdsClusterConfig eds_cluster_config = 3;</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        io.grpc.xds.shaded.envoy.api.v2.Cluster.EdsClusterConfig, io.grpc.xds.shaded.envoy.api.v2.Cluster.EdsClusterConfig.Builder, io.grpc.xds.shaded.envoy.api.v2.Cluster.EdsClusterConfigOrBuilder> 
        getEdsClusterConfigFieldBuilder() {
      if (edsClusterConfigBuilder_ == null) {
        edsClusterConfigBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            io.grpc.xds.shaded.envoy.api.v2.Cluster.EdsClusterConfig, io.grpc.xds.shaded.envoy.api.v2.Cluster.EdsClusterConfig.Builder, io.grpc.xds.shaded.envoy.api.v2.Cluster.EdsClusterConfigOrBuilder>(
                getEdsClusterConfig(),
                getParentForChildren(),
                isClean());
        edsClusterConfig_ = null;
      }
      return edsClusterConfigBuilder_;
    }

    private com.google.protobuf.Duration connectTimeout_ = null;
    private com.google.protobuf.SingleFieldBuilderV3<
        com.google.protobuf.Duration, com.google.protobuf.Duration.Builder, com.google.protobuf.DurationOrBuilder> connectTimeoutBuilder_;
    /**
     * <pre>
     * The timeout for new network connections to hosts in the cluster.
     * </pre>
     *
     * <code>.google.protobuf.Duration connect_timeout = 4 [(.validate.rules) = { ... }</code>
     */
    public boolean hasConnectTimeout() {
      return connectTimeoutBuilder_ != null || connectTimeout_ != null;
    }
    /**
     * <pre>
     * The timeout for new network connections to hosts in the cluster.
     * </pre>
     *
     * <code>.google.protobuf.Duration connect_timeout = 4 [(.validate.rules) = { ... }</code>
     */
    public com.google.protobuf.Duration getConnectTimeout() {
      if (connectTimeoutBuilder_ == null) {
        return connectTimeout_ == null ? com.google.protobuf.Duration.getDefaultInstance() : connectTimeout_;
      } else {
        return connectTimeoutBuilder_.getMessage();
      }
    }
    /**
     * <pre>
     * The timeout for new network connections to hosts in the cluster.
     * </pre>
     *
     * <code>.google.protobuf.Duration connect_timeout = 4 [(.validate.rules) = { ... }</code>
     */
    public Builder setConnectTimeout(com.google.protobuf.Duration value) {
      if (connectTimeoutBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        connectTimeout_ = value;
        onChanged();
      } else {
        connectTimeoutBuilder_.setMessage(value);
      }

      return this;
    }
    /**
     * <pre>
     * The timeout for new network connections to hosts in the cluster.
     * </pre>
     *
     * <code>.google.protobuf.Duration connect_timeout = 4 [(.validate.rules) = { ... }</code>
     */
    public Builder setConnectTimeout(
        com.google.protobuf.Duration.Builder builderForValue) {
      if (connectTimeoutBuilder_ == null) {
        connectTimeout_ = builderForValue.build();
        onChanged();
      } else {
        connectTimeoutBuilder_.setMessage(builderForValue.build());
      }

      return this;
    }
    /**
     * <pre>
     * The timeout for new network connections to hosts in the cluster.
     * </pre>
     *
     * <code>.google.protobuf.Duration connect_timeout = 4 [(.validate.rules) = { ... }</code>
     */
    public Builder mergeConnectTimeout(com.google.protobuf.Duration value) {
      if (connectTimeoutBuilder_ == null) {
        if (connectTimeout_ != null) {
          connectTimeout_ =
            com.google.protobuf.Duration.newBuilder(connectTimeout_).mergeFrom(value).buildPartial();
        } else {
          connectTimeout_ = value;
        }
        onChanged();
      } else {
        connectTimeoutBuilder_.mergeFrom(value);
      }

      return this;
    }
    /**
     * <pre>
     * The timeout for new network connections to hosts in the cluster.
     * </pre>
     *
     * <code>.google.protobuf.Duration connect_timeout = 4 [(.validate.rules) = { ... }</code>
     */
    public Builder clearConnectTimeout() {
      if (connectTimeoutBuilder_ == null) {
        connectTimeout_ = null;
        onChanged();
      } else {
        connectTimeout_ = null;
        connectTimeoutBuilder_ = null;
      }

      return this;
    }
    /**
     * <pre>
     * The timeout for new network connections to hosts in the cluster.
     * </pre>
     *
     * <code>.google.protobuf.Duration connect_timeout = 4 [(.validate.rules) = { ... }</code>
     */
    public com.google.protobuf.Duration.Builder getConnectTimeoutBuilder() {
      
      onChanged();
      return getConnectTimeoutFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * The timeout for new network connections to hosts in the cluster.
     * </pre>
     *
     * <code>.google.protobuf.Duration connect_timeout = 4 [(.validate.rules) = { ... }</code>
     */
    public com.google.protobuf.DurationOrBuilder getConnectTimeoutOrBuilder() {
      if (connectTimeoutBuilder_ != null) {
        return connectTimeoutBuilder_.getMessageOrBuilder();
      } else {
        return connectTimeout_ == null ?
            com.google.protobuf.Duration.getDefaultInstance() : connectTimeout_;
      }
    }
    /**
     * <pre>
     * The timeout for new network connections to hosts in the cluster.
     * </pre>
     *
     * <code>.google.protobuf.Duration connect_timeout = 4 [(.validate.rules) = { ... }</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        com.google.protobuf.Duration, com.google.protobuf.Duration.Builder, com.google.protobuf.DurationOrBuilder> 
        getConnectTimeoutFieldBuilder() {
      if (connectTimeoutBuilder_ == null) {
        connectTimeoutBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            com.google.protobuf.Duration, com.google.protobuf.Duration.Builder, com.google.protobuf.DurationOrBuilder>(
                getConnectTimeout(),
                getParentForChildren(),
                isClean());
        connectTimeout_ = null;
      }
      return connectTimeoutBuilder_;
    }

    private com.google.protobuf.UInt32Value perConnectionBufferLimitBytes_ = null;
    private com.google.protobuf.SingleFieldBuilderV3<
        com.google.protobuf.UInt32Value, com.google.protobuf.UInt32Value.Builder, com.google.protobuf.UInt32ValueOrBuilder> perConnectionBufferLimitBytesBuilder_;
    /**
     * <pre>
     * Soft limit on size of the clusters connections read and write buffers. If
     * unspecified, an implementation defined default is applied (1MiB).
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value per_connection_buffer_limit_bytes = 5;</code>
     */
    public boolean hasPerConnectionBufferLimitBytes() {
      return perConnectionBufferLimitBytesBuilder_ != null || perConnectionBufferLimitBytes_ != null;
    }
    /**
     * <pre>
     * Soft limit on size of the clusters connections read and write buffers. If
     * unspecified, an implementation defined default is applied (1MiB).
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value per_connection_buffer_limit_bytes = 5;</code>
     */
    public com.google.protobuf.UInt32Value getPerConnectionBufferLimitBytes() {
      if (perConnectionBufferLimitBytesBuilder_ == null) {
        return perConnectionBufferLimitBytes_ == null ? com.google.protobuf.UInt32Value.getDefaultInstance() : perConnectionBufferLimitBytes_;
      } else {
        return perConnectionBufferLimitBytesBuilder_.getMessage();
      }
    }
    /**
     * <pre>
     * Soft limit on size of the clusters connections read and write buffers. If
     * unspecified, an implementation defined default is applied (1MiB).
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value per_connection_buffer_limit_bytes = 5;</code>
     */
    public Builder setPerConnectionBufferLimitBytes(com.google.protobuf.UInt32Value value) {
      if (perConnectionBufferLimitBytesBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        perConnectionBufferLimitBytes_ = value;
        onChanged();
      } else {
        perConnectionBufferLimitBytesBuilder_.setMessage(value);
      }

      return this;
    }
    /**
     * <pre>
     * Soft limit on size of the clusters connections read and write buffers. If
     * unspecified, an implementation defined default is applied (1MiB).
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value per_connection_buffer_limit_bytes = 5;</code>
     */
    public Builder setPerConnectionBufferLimitBytes(
        com.google.protobuf.UInt32Value.Builder builderForValue) {
      if (perConnectionBufferLimitBytesBuilder_ == null) {
        perConnectionBufferLimitBytes_ = builderForValue.build();
        onChanged();
      } else {
        perConnectionBufferLimitBytesBuilder_.setMessage(builderForValue.build());
      }

      return this;
    }
    /**
     * <pre>
     * Soft limit on size of the clusters connections read and write buffers. If
     * unspecified, an implementation defined default is applied (1MiB).
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value per_connection_buffer_limit_bytes = 5;</code>
     */
    public Builder mergePerConnectionBufferLimitBytes(com.google.protobuf.UInt32Value value) {
      if (perConnectionBufferLimitBytesBuilder_ == null) {
        if (perConnectionBufferLimitBytes_ != null) {
          perConnectionBufferLimitBytes_ =
            com.google.protobuf.UInt32Value.newBuilder(perConnectionBufferLimitBytes_).mergeFrom(value).buildPartial();
        } else {
          perConnectionBufferLimitBytes_ = value;
        }
        onChanged();
      } else {
        perConnectionBufferLimitBytesBuilder_.mergeFrom(value);
      }

      return this;
    }
    /**
     * <pre>
     * Soft limit on size of the clusters connections read and write buffers. If
     * unspecified, an implementation defined default is applied (1MiB).
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value per_connection_buffer_limit_bytes = 5;</code>
     */
    public Builder clearPerConnectionBufferLimitBytes() {
      if (perConnectionBufferLimitBytesBuilder_ == null) {
        perConnectionBufferLimitBytes_ = null;
        onChanged();
      } else {
        perConnectionBufferLimitBytes_ = null;
        perConnectionBufferLimitBytesBuilder_ = null;
      }

      return this;
    }
    /**
     * <pre>
     * Soft limit on size of the clusters connections read and write buffers. If
     * unspecified, an implementation defined default is applied (1MiB).
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value per_connection_buffer_limit_bytes = 5;</code>
     */
    public com.google.protobuf.UInt32Value.Builder getPerConnectionBufferLimitBytesBuilder() {
      
      onChanged();
      return getPerConnectionBufferLimitBytesFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * Soft limit on size of the clusters connections read and write buffers. If
     * unspecified, an implementation defined default is applied (1MiB).
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value per_connection_buffer_limit_bytes = 5;</code>
     */
    public com.google.protobuf.UInt32ValueOrBuilder getPerConnectionBufferLimitBytesOrBuilder() {
      if (perConnectionBufferLimitBytesBuilder_ != null) {
        return perConnectionBufferLimitBytesBuilder_.getMessageOrBuilder();
      } else {
        return perConnectionBufferLimitBytes_ == null ?
            com.google.protobuf.UInt32Value.getDefaultInstance() : perConnectionBufferLimitBytes_;
      }
    }
    /**
     * <pre>
     * Soft limit on size of the clusters connections read and write buffers. If
     * unspecified, an implementation defined default is applied (1MiB).
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value per_connection_buffer_limit_bytes = 5;</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        com.google.protobuf.UInt32Value, com.google.protobuf.UInt32Value.Builder, com.google.protobuf.UInt32ValueOrBuilder> 
        getPerConnectionBufferLimitBytesFieldBuilder() {
      if (perConnectionBufferLimitBytesBuilder_ == null) {
        perConnectionBufferLimitBytesBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            com.google.protobuf.UInt32Value, com.google.protobuf.UInt32Value.Builder, com.google.protobuf.UInt32ValueOrBuilder>(
                getPerConnectionBufferLimitBytes(),
                getParentForChildren(),
                isClean());
        perConnectionBufferLimitBytes_ = null;
      }
      return perConnectionBufferLimitBytesBuilder_;
    }

    private int lbPolicy_ = 0;
    /**
     * <pre>
     * The :ref:`load balancer type &lt;arch_overview_load_balancing_types&gt;` to use
     * when picking a host in the cluster.
     * </pre>
     *
     * <code>.envoy.api.v2.Cluster.LbPolicy lb_policy = 6 [(.validate.rules) = { ... }</code>
     */
    public int getLbPolicyValue() {
      return lbPolicy_;
    }
    /**
     * <pre>
     * The :ref:`load balancer type &lt;arch_overview_load_balancing_types&gt;` to use
     * when picking a host in the cluster.
     * </pre>
     *
     * <code>.envoy.api.v2.Cluster.LbPolicy lb_policy = 6 [(.validate.rules) = { ... }</code>
     */
    public Builder setLbPolicyValue(int value) {
      lbPolicy_ = value;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * The :ref:`load balancer type &lt;arch_overview_load_balancing_types&gt;` to use
     * when picking a host in the cluster.
     * </pre>
     *
     * <code>.envoy.api.v2.Cluster.LbPolicy lb_policy = 6 [(.validate.rules) = { ... }</code>
     */
    public io.grpc.xds.shaded.envoy.api.v2.Cluster.LbPolicy getLbPolicy() {
      io.grpc.xds.shaded.envoy.api.v2.Cluster.LbPolicy result = io.grpc.xds.shaded.envoy.api.v2.Cluster.LbPolicy.valueOf(lbPolicy_);
      return result == null ? io.grpc.xds.shaded.envoy.api.v2.Cluster.LbPolicy.UNRECOGNIZED : result;
    }
    /**
     * <pre>
     * The :ref:`load balancer type &lt;arch_overview_load_balancing_types&gt;` to use
     * when picking a host in the cluster.
     * </pre>
     *
     * <code>.envoy.api.v2.Cluster.LbPolicy lb_policy = 6 [(.validate.rules) = { ... }</code>
     */
    public Builder setLbPolicy(io.grpc.xds.shaded.envoy.api.v2.Cluster.LbPolicy value) {
      if (value == null) {
        throw new NullPointerException();
      }
      
      lbPolicy_ = value.getNumber();
      onChanged();
      return this;
    }
    /**
     * <pre>
     * The :ref:`load balancer type &lt;arch_overview_load_balancing_types&gt;` to use
     * when picking a host in the cluster.
     * </pre>
     *
     * <code>.envoy.api.v2.Cluster.LbPolicy lb_policy = 6 [(.validate.rules) = { ... }</code>
     */
    public Builder clearLbPolicy() {
      
      lbPolicy_ = 0;
      onChanged();
      return this;
    }

    private java.util.List<io.grpc.xds.shaded.envoy.api.v2.core.Address> hosts_ =
      java.util.Collections.emptyList();
    private void ensureHostsIsMutable() {
      if (!((bitField0_ & 0x00000080) == 0x00000080)) {
        hosts_ = new java.util.ArrayList<io.grpc.xds.shaded.envoy.api.v2.core.Address>(hosts_);
        bitField0_ |= 0x00000080;
       }
    }

    private com.google.protobuf.RepeatedFieldBuilderV3<
        io.grpc.xds.shaded.envoy.api.v2.core.Address, io.grpc.xds.shaded.envoy.api.v2.core.Address.Builder, io.grpc.xds.shaded.envoy.api.v2.core.AddressOrBuilder> hostsBuilder_;

    /**
     * <pre>
     * If the service discovery type is
     * :ref:`STATIC&lt;envoy_api_enum_value_Cluster.DiscoveryType.STATIC&gt;`,
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS&gt;`
     * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS&gt;`,
     * then hosts is required.
     * .. attention::
     *   **This field is deprecated**. Set the
     *   :ref:`load_assignment&lt;envoy_api_field_Cluster.load_assignment&gt;` field instead.
     * </pre>
     *
     * <code>repeated .envoy.api.v2.core.Address hosts = 7 [deprecated = true];</code>
     */
    @java.lang.Deprecated public java.util.List<io.grpc.xds.shaded.envoy.api.v2.core.Address> getHostsList() {
      if (hostsBuilder_ == null) {
        return java.util.Collections.unmodifiableList(hosts_);
      } else {
        return hostsBuilder_.getMessageList();
      }
    }
    /**
     * <pre>
     * If the service discovery type is
     * :ref:`STATIC&lt;envoy_api_enum_value_Cluster.DiscoveryType.STATIC&gt;`,
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS&gt;`
     * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS&gt;`,
     * then hosts is required.
     * .. attention::
     *   **This field is deprecated**. Set the
     *   :ref:`load_assignment&lt;envoy_api_field_Cluster.load_assignment&gt;` field instead.
     * </pre>
     *
     * <code>repeated .envoy.api.v2.core.Address hosts = 7 [deprecated = true];</code>
     */
    @java.lang.Deprecated public int getHostsCount() {
      if (hostsBuilder_ == null) {
        return hosts_.size();
      } else {
        return hostsBuilder_.getCount();
      }
    }
    /**
     * <pre>
     * If the service discovery type is
     * :ref:`STATIC&lt;envoy_api_enum_value_Cluster.DiscoveryType.STATIC&gt;`,
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS&gt;`
     * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS&gt;`,
     * then hosts is required.
     * .. attention::
     *   **This field is deprecated**. Set the
     *   :ref:`load_assignment&lt;envoy_api_field_Cluster.load_assignment&gt;` field instead.
     * </pre>
     *
     * <code>repeated .envoy.api.v2.core.Address hosts = 7 [deprecated = true];</code>
     */
    @java.lang.Deprecated public io.grpc.xds.shaded.envoy.api.v2.core.Address getHosts(int index) {
      if (hostsBuilder_ == null) {
        return hosts_.get(index);
      } else {
        return hostsBuilder_.getMessage(index);
      }
    }
    /**
     * <pre>
     * If the service discovery type is
     * :ref:`STATIC&lt;envoy_api_enum_value_Cluster.DiscoveryType.STATIC&gt;`,
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS&gt;`
     * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS&gt;`,
     * then hosts is required.
     * .. attention::
     *   **This field is deprecated**. Set the
     *   :ref:`load_assignment&lt;envoy_api_field_Cluster.load_assignment&gt;` field instead.
     * </pre>
     *
     * <code>repeated .envoy.api.v2.core.Address hosts = 7 [deprecated = true];</code>
     */
    @java.lang.Deprecated public Builder setHosts(
        int index, io.grpc.xds.shaded.envoy.api.v2.core.Address value) {
      if (hostsBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureHostsIsMutable();
        hosts_.set(index, value);
        onChanged();
      } else {
        hostsBuilder_.setMessage(index, value);
      }
      return this;
    }
    /**
     * <pre>
     * If the service discovery type is
     * :ref:`STATIC&lt;envoy_api_enum_value_Cluster.DiscoveryType.STATIC&gt;`,
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS&gt;`
     * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS&gt;`,
     * then hosts is required.
     * .. attention::
     *   **This field is deprecated**. Set the
     *   :ref:`load_assignment&lt;envoy_api_field_Cluster.load_assignment&gt;` field instead.
     * </pre>
     *
     * <code>repeated .envoy.api.v2.core.Address hosts = 7 [deprecated = true];</code>
     */
    @java.lang.Deprecated public Builder setHosts(
        int index, io.grpc.xds.shaded.envoy.api.v2.core.Address.Builder builderForValue) {
      if (hostsBuilder_ == null) {
        ensureHostsIsMutable();
        hosts_.set(index, builderForValue.build());
        onChanged();
      } else {
        hostsBuilder_.setMessage(index, builderForValue.build());
      }
      return this;
    }
    /**
     * <pre>
     * If the service discovery type is
     * :ref:`STATIC&lt;envoy_api_enum_value_Cluster.DiscoveryType.STATIC&gt;`,
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS&gt;`
     * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS&gt;`,
     * then hosts is required.
     * .. attention::
     *   **This field is deprecated**. Set the
     *   :ref:`load_assignment&lt;envoy_api_field_Cluster.load_assignment&gt;` field instead.
     * </pre>
     *
     * <code>repeated .envoy.api.v2.core.Address hosts = 7 [deprecated = true];</code>
     */
    @java.lang.Deprecated public Builder addHosts(io.grpc.xds.shaded.envoy.api.v2.core.Address value) {
      if (hostsBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureHostsIsMutable();
        hosts_.add(value);
        onChanged();
      } else {
        hostsBuilder_.addMessage(value);
      }
      return this;
    }
    /**
     * <pre>
     * If the service discovery type is
     * :ref:`STATIC&lt;envoy_api_enum_value_Cluster.DiscoveryType.STATIC&gt;`,
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS&gt;`
     * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS&gt;`,
     * then hosts is required.
     * .. attention::
     *   **This field is deprecated**. Set the
     *   :ref:`load_assignment&lt;envoy_api_field_Cluster.load_assignment&gt;` field instead.
     * </pre>
     *
     * <code>repeated .envoy.api.v2.core.Address hosts = 7 [deprecated = true];</code>
     */
    @java.lang.Deprecated public Builder addHosts(
        int index, io.grpc.xds.shaded.envoy.api.v2.core.Address value) {
      if (hostsBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureHostsIsMutable();
        hosts_.add(index, value);
        onChanged();
      } else {
        hostsBuilder_.addMessage(index, value);
      }
      return this;
    }
    /**
     * <pre>
     * If the service discovery type is
     * :ref:`STATIC&lt;envoy_api_enum_value_Cluster.DiscoveryType.STATIC&gt;`,
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS&gt;`
     * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS&gt;`,
     * then hosts is required.
     * .. attention::
     *   **This field is deprecated**. Set the
     *   :ref:`load_assignment&lt;envoy_api_field_Cluster.load_assignment&gt;` field instead.
     * </pre>
     *
     * <code>repeated .envoy.api.v2.core.Address hosts = 7 [deprecated = true];</code>
     */
    @java.lang.Deprecated public Builder addHosts(
        io.grpc.xds.shaded.envoy.api.v2.core.Address.Builder builderForValue) {
      if (hostsBuilder_ == null) {
        ensureHostsIsMutable();
        hosts_.add(builderForValue.build());
        onChanged();
      } else {
        hostsBuilder_.addMessage(builderForValue.build());
      }
      return this;
    }
    /**
     * <pre>
     * If the service discovery type is
     * :ref:`STATIC&lt;envoy_api_enum_value_Cluster.DiscoveryType.STATIC&gt;`,
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS&gt;`
     * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS&gt;`,
     * then hosts is required.
     * .. attention::
     *   **This field is deprecated**. Set the
     *   :ref:`load_assignment&lt;envoy_api_field_Cluster.load_assignment&gt;` field instead.
     * </pre>
     *
     * <code>repeated .envoy.api.v2.core.Address hosts = 7 [deprecated = true];</code>
     */
    @java.lang.Deprecated public Builder addHosts(
        int index, io.grpc.xds.shaded.envoy.api.v2.core.Address.Builder builderForValue) {
      if (hostsBuilder_ == null) {
        ensureHostsIsMutable();
        hosts_.add(index, builderForValue.build());
        onChanged();
      } else {
        hostsBuilder_.addMessage(index, builderForValue.build());
      }
      return this;
    }
    /**
     * <pre>
     * If the service discovery type is
     * :ref:`STATIC&lt;envoy_api_enum_value_Cluster.DiscoveryType.STATIC&gt;`,
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS&gt;`
     * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS&gt;`,
     * then hosts is required.
     * .. attention::
     *   **This field is deprecated**. Set the
     *   :ref:`load_assignment&lt;envoy_api_field_Cluster.load_assignment&gt;` field instead.
     * </pre>
     *
     * <code>repeated .envoy.api.v2.core.Address hosts = 7 [deprecated = true];</code>
     */
    @java.lang.Deprecated public Builder addAllHosts(
        java.lang.Iterable<? extends io.grpc.xds.shaded.envoy.api.v2.core.Address> values) {
      if (hostsBuilder_ == null) {
        ensureHostsIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, hosts_);
        onChanged();
      } else {
        hostsBuilder_.addAllMessages(values);
      }
      return this;
    }
    /**
     * <pre>
     * If the service discovery type is
     * :ref:`STATIC&lt;envoy_api_enum_value_Cluster.DiscoveryType.STATIC&gt;`,
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS&gt;`
     * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS&gt;`,
     * then hosts is required.
     * .. attention::
     *   **This field is deprecated**. Set the
     *   :ref:`load_assignment&lt;envoy_api_field_Cluster.load_assignment&gt;` field instead.
     * </pre>
     *
     * <code>repeated .envoy.api.v2.core.Address hosts = 7 [deprecated = true];</code>
     */
    @java.lang.Deprecated public Builder clearHosts() {
      if (hostsBuilder_ == null) {
        hosts_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x00000080);
        onChanged();
      } else {
        hostsBuilder_.clear();
      }
      return this;
    }
    /**
     * <pre>
     * If the service discovery type is
     * :ref:`STATIC&lt;envoy_api_enum_value_Cluster.DiscoveryType.STATIC&gt;`,
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS&gt;`
     * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS&gt;`,
     * then hosts is required.
     * .. attention::
     *   **This field is deprecated**. Set the
     *   :ref:`load_assignment&lt;envoy_api_field_Cluster.load_assignment&gt;` field instead.
     * </pre>
     *
     * <code>repeated .envoy.api.v2.core.Address hosts = 7 [deprecated = true];</code>
     */
    @java.lang.Deprecated public Builder removeHosts(int index) {
      if (hostsBuilder_ == null) {
        ensureHostsIsMutable();
        hosts_.remove(index);
        onChanged();
      } else {
        hostsBuilder_.remove(index);
      }
      return this;
    }
    /**
     * <pre>
     * If the service discovery type is
     * :ref:`STATIC&lt;envoy_api_enum_value_Cluster.DiscoveryType.STATIC&gt;`,
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS&gt;`
     * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS&gt;`,
     * then hosts is required.
     * .. attention::
     *   **This field is deprecated**. Set the
     *   :ref:`load_assignment&lt;envoy_api_field_Cluster.load_assignment&gt;` field instead.
     * </pre>
     *
     * <code>repeated .envoy.api.v2.core.Address hosts = 7 [deprecated = true];</code>
     */
    @java.lang.Deprecated public io.grpc.xds.shaded.envoy.api.v2.core.Address.Builder getHostsBuilder(
        int index) {
      return getHostsFieldBuilder().getBuilder(index);
    }
    /**
     * <pre>
     * If the service discovery type is
     * :ref:`STATIC&lt;envoy_api_enum_value_Cluster.DiscoveryType.STATIC&gt;`,
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS&gt;`
     * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS&gt;`,
     * then hosts is required.
     * .. attention::
     *   **This field is deprecated**. Set the
     *   :ref:`load_assignment&lt;envoy_api_field_Cluster.load_assignment&gt;` field instead.
     * </pre>
     *
     * <code>repeated .envoy.api.v2.core.Address hosts = 7 [deprecated = true];</code>
     */
    @java.lang.Deprecated public io.grpc.xds.shaded.envoy.api.v2.core.AddressOrBuilder getHostsOrBuilder(
        int index) {
      if (hostsBuilder_ == null) {
        return hosts_.get(index);  } else {
        return hostsBuilder_.getMessageOrBuilder(index);
      }
    }
    /**
     * <pre>
     * If the service discovery type is
     * :ref:`STATIC&lt;envoy_api_enum_value_Cluster.DiscoveryType.STATIC&gt;`,
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS&gt;`
     * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS&gt;`,
     * then hosts is required.
     * .. attention::
     *   **This field is deprecated**. Set the
     *   :ref:`load_assignment&lt;envoy_api_field_Cluster.load_assignment&gt;` field instead.
     * </pre>
     *
     * <code>repeated .envoy.api.v2.core.Address hosts = 7 [deprecated = true];</code>
     */
    @java.lang.Deprecated public java.util.List<? extends io.grpc.xds.shaded.envoy.api.v2.core.AddressOrBuilder> 
         getHostsOrBuilderList() {
      if (hostsBuilder_ != null) {
        return hostsBuilder_.getMessageOrBuilderList();
      } else {
        return java.util.Collections.unmodifiableList(hosts_);
      }
    }
    /**
     * <pre>
     * If the service discovery type is
     * :ref:`STATIC&lt;envoy_api_enum_value_Cluster.DiscoveryType.STATIC&gt;`,
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS&gt;`
     * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS&gt;`,
     * then hosts is required.
     * .. attention::
     *   **This field is deprecated**. Set the
     *   :ref:`load_assignment&lt;envoy_api_field_Cluster.load_assignment&gt;` field instead.
     * </pre>
     *
     * <code>repeated .envoy.api.v2.core.Address hosts = 7 [deprecated = true];</code>
     */
    @java.lang.Deprecated public io.grpc.xds.shaded.envoy.api.v2.core.Address.Builder addHostsBuilder() {
      return getHostsFieldBuilder().addBuilder(
          io.grpc.xds.shaded.envoy.api.v2.core.Address.getDefaultInstance());
    }
    /**
     * <pre>
     * If the service discovery type is
     * :ref:`STATIC&lt;envoy_api_enum_value_Cluster.DiscoveryType.STATIC&gt;`,
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS&gt;`
     * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS&gt;`,
     * then hosts is required.
     * .. attention::
     *   **This field is deprecated**. Set the
     *   :ref:`load_assignment&lt;envoy_api_field_Cluster.load_assignment&gt;` field instead.
     * </pre>
     *
     * <code>repeated .envoy.api.v2.core.Address hosts = 7 [deprecated = true];</code>
     */
    @java.lang.Deprecated public io.grpc.xds.shaded.envoy.api.v2.core.Address.Builder addHostsBuilder(
        int index) {
      return getHostsFieldBuilder().addBuilder(
          index, io.grpc.xds.shaded.envoy.api.v2.core.Address.getDefaultInstance());
    }
    /**
     * <pre>
     * If the service discovery type is
     * :ref:`STATIC&lt;envoy_api_enum_value_Cluster.DiscoveryType.STATIC&gt;`,
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS&gt;`
     * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS&gt;`,
     * then hosts is required.
     * .. attention::
     *   **This field is deprecated**. Set the
     *   :ref:`load_assignment&lt;envoy_api_field_Cluster.load_assignment&gt;` field instead.
     * </pre>
     *
     * <code>repeated .envoy.api.v2.core.Address hosts = 7 [deprecated = true];</code>
     */
    @java.lang.Deprecated public java.util.List<io.grpc.xds.shaded.envoy.api.v2.core.Address.Builder> 
         getHostsBuilderList() {
      return getHostsFieldBuilder().getBuilderList();
    }
    private com.google.protobuf.RepeatedFieldBuilderV3<
        io.grpc.xds.shaded.envoy.api.v2.core.Address, io.grpc.xds.shaded.envoy.api.v2.core.Address.Builder, io.grpc.xds.shaded.envoy.api.v2.core.AddressOrBuilder> 
        getHostsFieldBuilder() {
      if (hostsBuilder_ == null) {
        hostsBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
            io.grpc.xds.shaded.envoy.api.v2.core.Address, io.grpc.xds.shaded.envoy.api.v2.core.Address.Builder, io.grpc.xds.shaded.envoy.api.v2.core.AddressOrBuilder>(
                hosts_,
                ((bitField0_ & 0x00000080) == 0x00000080),
                getParentForChildren(),
                isClean());
        hosts_ = null;
      }
      return hostsBuilder_;
    }

    private io.grpc.xds.shaded.envoy.api.v2.ClusterLoadAssignment loadAssignment_ = null;
    private com.google.protobuf.SingleFieldBuilderV3<
        io.grpc.xds.shaded.envoy.api.v2.ClusterLoadAssignment, io.grpc.xds.shaded.envoy.api.v2.ClusterLoadAssignment.Builder, io.grpc.xds.shaded.envoy.api.v2.ClusterLoadAssignmentOrBuilder> loadAssignmentBuilder_;
    /**
     * <pre>
     * Setting this is required for specifying members of
     * :ref:`STATIC&lt;envoy_api_enum_value_Cluster.DiscoveryType.STATIC&gt;`,
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS&gt;`
     * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS&gt;` clusters.
     * This field supersedes :ref:`hosts&lt;envoy_api_field_Cluster.hosts&gt;` field.
     * [#comment:TODO(dio): Deprecate the hosts field and add it to DEPRECATED.md
     * once load_assignment is implemented.]
     * .. attention::
     *   Setting this allows non-EDS cluster types to contain embedded EDS equivalent
     *   :ref:`endpoint assignments&lt;envoy_api_msg_ClusterLoadAssignment&gt;`.
     *   Setting this overrides :ref:`hosts&lt;envoy_api_field_Cluster.hosts&gt;` values.
     * </pre>
     *
     * <code>.envoy.api.v2.ClusterLoadAssignment load_assignment = 33;</code>
     */
    public boolean hasLoadAssignment() {
      return loadAssignmentBuilder_ != null || loadAssignment_ != null;
    }
    /**
     * <pre>
     * Setting this is required for specifying members of
     * :ref:`STATIC&lt;envoy_api_enum_value_Cluster.DiscoveryType.STATIC&gt;`,
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS&gt;`
     * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS&gt;` clusters.
     * This field supersedes :ref:`hosts&lt;envoy_api_field_Cluster.hosts&gt;` field.
     * [#comment:TODO(dio): Deprecate the hosts field and add it to DEPRECATED.md
     * once load_assignment is implemented.]
     * .. attention::
     *   Setting this allows non-EDS cluster types to contain embedded EDS equivalent
     *   :ref:`endpoint assignments&lt;envoy_api_msg_ClusterLoadAssignment&gt;`.
     *   Setting this overrides :ref:`hosts&lt;envoy_api_field_Cluster.hosts&gt;` values.
     * </pre>
     *
     * <code>.envoy.api.v2.ClusterLoadAssignment load_assignment = 33;</code>
     */
    public io.grpc.xds.shaded.envoy.api.v2.ClusterLoadAssignment getLoadAssignment() {
      if (loadAssignmentBuilder_ == null) {
        return loadAssignment_ == null ? io.grpc.xds.shaded.envoy.api.v2.ClusterLoadAssignment.getDefaultInstance() : loadAssignment_;
      } else {
        return loadAssignmentBuilder_.getMessage();
      }
    }
    /**
     * <pre>
     * Setting this is required for specifying members of
     * :ref:`STATIC&lt;envoy_api_enum_value_Cluster.DiscoveryType.STATIC&gt;`,
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS&gt;`
     * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS&gt;` clusters.
     * This field supersedes :ref:`hosts&lt;envoy_api_field_Cluster.hosts&gt;` field.
     * [#comment:TODO(dio): Deprecate the hosts field and add it to DEPRECATED.md
     * once load_assignment is implemented.]
     * .. attention::
     *   Setting this allows non-EDS cluster types to contain embedded EDS equivalent
     *   :ref:`endpoint assignments&lt;envoy_api_msg_ClusterLoadAssignment&gt;`.
     *   Setting this overrides :ref:`hosts&lt;envoy_api_field_Cluster.hosts&gt;` values.
     * </pre>
     *
     * <code>.envoy.api.v2.ClusterLoadAssignment load_assignment = 33;</code>
     */
    public Builder setLoadAssignment(io.grpc.xds.shaded.envoy.api.v2.ClusterLoadAssignment value) {
      if (loadAssignmentBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        loadAssignment_ = value;
        onChanged();
      } else {
        loadAssignmentBuilder_.setMessage(value);
      }

      return this;
    }
    /**
     * <pre>
     * Setting this is required for specifying members of
     * :ref:`STATIC&lt;envoy_api_enum_value_Cluster.DiscoveryType.STATIC&gt;`,
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS&gt;`
     * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS&gt;` clusters.
     * This field supersedes :ref:`hosts&lt;envoy_api_field_Cluster.hosts&gt;` field.
     * [#comment:TODO(dio): Deprecate the hosts field and add it to DEPRECATED.md
     * once load_assignment is implemented.]
     * .. attention::
     *   Setting this allows non-EDS cluster types to contain embedded EDS equivalent
     *   :ref:`endpoint assignments&lt;envoy_api_msg_ClusterLoadAssignment&gt;`.
     *   Setting this overrides :ref:`hosts&lt;envoy_api_field_Cluster.hosts&gt;` values.
     * </pre>
     *
     * <code>.envoy.api.v2.ClusterLoadAssignment load_assignment = 33;</code>
     */
    public Builder setLoadAssignment(
        io.grpc.xds.shaded.envoy.api.v2.ClusterLoadAssignment.Builder builderForValue) {
      if (loadAssignmentBuilder_ == null) {
        loadAssignment_ = builderForValue.build();
        onChanged();
      } else {
        loadAssignmentBuilder_.setMessage(builderForValue.build());
      }

      return this;
    }
    /**
     * <pre>
     * Setting this is required for specifying members of
     * :ref:`STATIC&lt;envoy_api_enum_value_Cluster.DiscoveryType.STATIC&gt;`,
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS&gt;`
     * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS&gt;` clusters.
     * This field supersedes :ref:`hosts&lt;envoy_api_field_Cluster.hosts&gt;` field.
     * [#comment:TODO(dio): Deprecate the hosts field and add it to DEPRECATED.md
     * once load_assignment is implemented.]
     * .. attention::
     *   Setting this allows non-EDS cluster types to contain embedded EDS equivalent
     *   :ref:`endpoint assignments&lt;envoy_api_msg_ClusterLoadAssignment&gt;`.
     *   Setting this overrides :ref:`hosts&lt;envoy_api_field_Cluster.hosts&gt;` values.
     * </pre>
     *
     * <code>.envoy.api.v2.ClusterLoadAssignment load_assignment = 33;</code>
     */
    public Builder mergeLoadAssignment(io.grpc.xds.shaded.envoy.api.v2.ClusterLoadAssignment value) {
      if (loadAssignmentBuilder_ == null) {
        if (loadAssignment_ != null) {
          loadAssignment_ =
            io.grpc.xds.shaded.envoy.api.v2.ClusterLoadAssignment.newBuilder(loadAssignment_).mergeFrom(value).buildPartial();
        } else {
          loadAssignment_ = value;
        }
        onChanged();
      } else {
        loadAssignmentBuilder_.mergeFrom(value);
      }

      return this;
    }
    /**
     * <pre>
     * Setting this is required for specifying members of
     * :ref:`STATIC&lt;envoy_api_enum_value_Cluster.DiscoveryType.STATIC&gt;`,
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS&gt;`
     * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS&gt;` clusters.
     * This field supersedes :ref:`hosts&lt;envoy_api_field_Cluster.hosts&gt;` field.
     * [#comment:TODO(dio): Deprecate the hosts field and add it to DEPRECATED.md
     * once load_assignment is implemented.]
     * .. attention::
     *   Setting this allows non-EDS cluster types to contain embedded EDS equivalent
     *   :ref:`endpoint assignments&lt;envoy_api_msg_ClusterLoadAssignment&gt;`.
     *   Setting this overrides :ref:`hosts&lt;envoy_api_field_Cluster.hosts&gt;` values.
     * </pre>
     *
     * <code>.envoy.api.v2.ClusterLoadAssignment load_assignment = 33;</code>
     */
    public Builder clearLoadAssignment() {
      if (loadAssignmentBuilder_ == null) {
        loadAssignment_ = null;
        onChanged();
      } else {
        loadAssignment_ = null;
        loadAssignmentBuilder_ = null;
      }

      return this;
    }
    /**
     * <pre>
     * Setting this is required for specifying members of
     * :ref:`STATIC&lt;envoy_api_enum_value_Cluster.DiscoveryType.STATIC&gt;`,
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS&gt;`
     * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS&gt;` clusters.
     * This field supersedes :ref:`hosts&lt;envoy_api_field_Cluster.hosts&gt;` field.
     * [#comment:TODO(dio): Deprecate the hosts field and add it to DEPRECATED.md
     * once load_assignment is implemented.]
     * .. attention::
     *   Setting this allows non-EDS cluster types to contain embedded EDS equivalent
     *   :ref:`endpoint assignments&lt;envoy_api_msg_ClusterLoadAssignment&gt;`.
     *   Setting this overrides :ref:`hosts&lt;envoy_api_field_Cluster.hosts&gt;` values.
     * </pre>
     *
     * <code>.envoy.api.v2.ClusterLoadAssignment load_assignment = 33;</code>
     */
    public io.grpc.xds.shaded.envoy.api.v2.ClusterLoadAssignment.Builder getLoadAssignmentBuilder() {
      
      onChanged();
      return getLoadAssignmentFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * Setting this is required for specifying members of
     * :ref:`STATIC&lt;envoy_api_enum_value_Cluster.DiscoveryType.STATIC&gt;`,
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS&gt;`
     * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS&gt;` clusters.
     * This field supersedes :ref:`hosts&lt;envoy_api_field_Cluster.hosts&gt;` field.
     * [#comment:TODO(dio): Deprecate the hosts field and add it to DEPRECATED.md
     * once load_assignment is implemented.]
     * .. attention::
     *   Setting this allows non-EDS cluster types to contain embedded EDS equivalent
     *   :ref:`endpoint assignments&lt;envoy_api_msg_ClusterLoadAssignment&gt;`.
     *   Setting this overrides :ref:`hosts&lt;envoy_api_field_Cluster.hosts&gt;` values.
     * </pre>
     *
     * <code>.envoy.api.v2.ClusterLoadAssignment load_assignment = 33;</code>
     */
    public io.grpc.xds.shaded.envoy.api.v2.ClusterLoadAssignmentOrBuilder getLoadAssignmentOrBuilder() {
      if (loadAssignmentBuilder_ != null) {
        return loadAssignmentBuilder_.getMessageOrBuilder();
      } else {
        return loadAssignment_ == null ?
            io.grpc.xds.shaded.envoy.api.v2.ClusterLoadAssignment.getDefaultInstance() : loadAssignment_;
      }
    }
    /**
     * <pre>
     * Setting this is required for specifying members of
     * :ref:`STATIC&lt;envoy_api_enum_value_Cluster.DiscoveryType.STATIC&gt;`,
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS&gt;`
     * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS&gt;` clusters.
     * This field supersedes :ref:`hosts&lt;envoy_api_field_Cluster.hosts&gt;` field.
     * [#comment:TODO(dio): Deprecate the hosts field and add it to DEPRECATED.md
     * once load_assignment is implemented.]
     * .. attention::
     *   Setting this allows non-EDS cluster types to contain embedded EDS equivalent
     *   :ref:`endpoint assignments&lt;envoy_api_msg_ClusterLoadAssignment&gt;`.
     *   Setting this overrides :ref:`hosts&lt;envoy_api_field_Cluster.hosts&gt;` values.
     * </pre>
     *
     * <code>.envoy.api.v2.ClusterLoadAssignment load_assignment = 33;</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        io.grpc.xds.shaded.envoy.api.v2.ClusterLoadAssignment, io.grpc.xds.shaded.envoy.api.v2.ClusterLoadAssignment.Builder, io.grpc.xds.shaded.envoy.api.v2.ClusterLoadAssignmentOrBuilder> 
        getLoadAssignmentFieldBuilder() {
      if (loadAssignmentBuilder_ == null) {
        loadAssignmentBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            io.grpc.xds.shaded.envoy.api.v2.ClusterLoadAssignment, io.grpc.xds.shaded.envoy.api.v2.ClusterLoadAssignment.Builder, io.grpc.xds.shaded.envoy.api.v2.ClusterLoadAssignmentOrBuilder>(
                getLoadAssignment(),
                getParentForChildren(),
                isClean());
        loadAssignment_ = null;
      }
      return loadAssignmentBuilder_;
    }

    private java.util.List<io.grpc.xds.shaded.envoy.api.v2.core.HealthCheck> healthChecks_ =
      java.util.Collections.emptyList();
    private void ensureHealthChecksIsMutable() {
      if (!((bitField0_ & 0x00000200) == 0x00000200)) {
        healthChecks_ = new java.util.ArrayList<io.grpc.xds.shaded.envoy.api.v2.core.HealthCheck>(healthChecks_);
        bitField0_ |= 0x00000200;
       }
    }

    private com.google.protobuf.RepeatedFieldBuilderV3<
        io.grpc.xds.shaded.envoy.api.v2.core.HealthCheck, io.grpc.xds.shaded.envoy.api.v2.core.HealthCheck.Builder, io.grpc.xds.shaded.envoy.api.v2.core.HealthCheckOrBuilder> healthChecksBuilder_;

    /**
     * <pre>
     * Optional :ref:`active health checking &lt;arch_overview_health_checking&gt;`
     * configuration for the cluster. If no
     * configuration is specified no health checking will be done and all cluster
     * members will be considered healthy at all times.
     * </pre>
     *
     * <code>repeated .envoy.api.v2.core.HealthCheck health_checks = 8;</code>
     */
    public java.util.List<io.grpc.xds.shaded.envoy.api.v2.core.HealthCheck> getHealthChecksList() {
      if (healthChecksBuilder_ == null) {
        return java.util.Collections.unmodifiableList(healthChecks_);
      } else {
        return healthChecksBuilder_.getMessageList();
      }
    }
    /**
     * <pre>
     * Optional :ref:`active health checking &lt;arch_overview_health_checking&gt;`
     * configuration for the cluster. If no
     * configuration is specified no health checking will be done and all cluster
     * members will be considered healthy at all times.
     * </pre>
     *
     * <code>repeated .envoy.api.v2.core.HealthCheck health_checks = 8;</code>
     */
    public int getHealthChecksCount() {
      if (healthChecksBuilder_ == null) {
        return healthChecks_.size();
      } else {
        return healthChecksBuilder_.getCount();
      }
    }
    /**
     * <pre>
     * Optional :ref:`active health checking &lt;arch_overview_health_checking&gt;`
     * configuration for the cluster. If no
     * configuration is specified no health checking will be done and all cluster
     * members will be considered healthy at all times.
     * </pre>
     *
     * <code>repeated .envoy.api.v2.core.HealthCheck health_checks = 8;</code>
     */
    public io.grpc.xds.shaded.envoy.api.v2.core.HealthCheck getHealthChecks(int index) {
      if (healthChecksBuilder_ == null) {
        return healthChecks_.get(index);
      } else {
        return healthChecksBuilder_.getMessage(index);
      }
    }
    /**
     * <pre>
     * Optional :ref:`active health checking &lt;arch_overview_health_checking&gt;`
     * configuration for the cluster. If no
     * configuration is specified no health checking will be done and all cluster
     * members will be considered healthy at all times.
     * </pre>
     *
     * <code>repeated .envoy.api.v2.core.HealthCheck health_checks = 8;</code>
     */
    public Builder setHealthChecks(
        int index, io.grpc.xds.shaded.envoy.api.v2.core.HealthCheck value) {
      if (healthChecksBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureHealthChecksIsMutable();
        healthChecks_.set(index, value);
        onChanged();
      } else {
        healthChecksBuilder_.setMessage(index, value);
      }
      return this;
    }
    /**
     * <pre>
     * Optional :ref:`active health checking &lt;arch_overview_health_checking&gt;`
     * configuration for the cluster. If no
     * configuration is specified no health checking will be done and all cluster
     * members will be considered healthy at all times.
     * </pre>
     *
     * <code>repeated .envoy.api.v2.core.HealthCheck health_checks = 8;</code>
     */
    public Builder setHealthChecks(
        int index, io.grpc.xds.shaded.envoy.api.v2.core.HealthCheck.Builder builderForValue) {
      if (healthChecksBuilder_ == null) {
        ensureHealthChecksIsMutable();
        healthChecks_.set(index, builderForValue.build());
        onChanged();
      } else {
        healthChecksBuilder_.setMessage(index, builderForValue.build());
      }
      return this;
    }
    /**
     * <pre>
     * Optional :ref:`active health checking &lt;arch_overview_health_checking&gt;`
     * configuration for the cluster. If no
     * configuration is specified no health checking will be done and all cluster
     * members will be considered healthy at all times.
     * </pre>
     *
     * <code>repeated .envoy.api.v2.core.HealthCheck health_checks = 8;</code>
     */
    public Builder addHealthChecks(io.grpc.xds.shaded.envoy.api.v2.core.HealthCheck value) {
      if (healthChecksBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureHealthChecksIsMutable();
        healthChecks_.add(value);
        onChanged();
      } else {
        healthChecksBuilder_.addMessage(value);
      }
      return this;
    }
    /**
     * <pre>
     * Optional :ref:`active health checking &lt;arch_overview_health_checking&gt;`
     * configuration for the cluster. If no
     * configuration is specified no health checking will be done and all cluster
     * members will be considered healthy at all times.
     * </pre>
     *
     * <code>repeated .envoy.api.v2.core.HealthCheck health_checks = 8;</code>
     */
    public Builder addHealthChecks(
        int index, io.grpc.xds.shaded.envoy.api.v2.core.HealthCheck value) {
      if (healthChecksBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureHealthChecksIsMutable();
        healthChecks_.add(index, value);
        onChanged();
      } else {
        healthChecksBuilder_.addMessage(index, value);
      }
      return this;
    }
    /**
     * <pre>
     * Optional :ref:`active health checking &lt;arch_overview_health_checking&gt;`
     * configuration for the cluster. If no
     * configuration is specified no health checking will be done and all cluster
     * members will be considered healthy at all times.
     * </pre>
     *
     * <code>repeated .envoy.api.v2.core.HealthCheck health_checks = 8;</code>
     */
    public Builder addHealthChecks(
        io.grpc.xds.shaded.envoy.api.v2.core.HealthCheck.Builder builderForValue) {
      if (healthChecksBuilder_ == null) {
        ensureHealthChecksIsMutable();
        healthChecks_.add(builderForValue.build());
        onChanged();
      } else {
        healthChecksBuilder_.addMessage(builderForValue.build());
      }
      return this;
    }
    /**
     * <pre>
     * Optional :ref:`active health checking &lt;arch_overview_health_checking&gt;`
     * configuration for the cluster. If no
     * configuration is specified no health checking will be done and all cluster
     * members will be considered healthy at all times.
     * </pre>
     *
     * <code>repeated .envoy.api.v2.core.HealthCheck health_checks = 8;</code>
     */
    public Builder addHealthChecks(
        int index, io.grpc.xds.shaded.envoy.api.v2.core.HealthCheck.Builder builderForValue) {
      if (healthChecksBuilder_ == null) {
        ensureHealthChecksIsMutable();
        healthChecks_.add(index, builderForValue.build());
        onChanged();
      } else {
        healthChecksBuilder_.addMessage(index, builderForValue.build());
      }
      return this;
    }
    /**
     * <pre>
     * Optional :ref:`active health checking &lt;arch_overview_health_checking&gt;`
     * configuration for the cluster. If no
     * configuration is specified no health checking will be done and all cluster
     * members will be considered healthy at all times.
     * </pre>
     *
     * <code>repeated .envoy.api.v2.core.HealthCheck health_checks = 8;</code>
     */
    public Builder addAllHealthChecks(
        java.lang.Iterable<? extends io.grpc.xds.shaded.envoy.api.v2.core.HealthCheck> values) {
      if (healthChecksBuilder_ == null) {
        ensureHealthChecksIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, healthChecks_);
        onChanged();
      } else {
        healthChecksBuilder_.addAllMessages(values);
      }
      return this;
    }
    /**
     * <pre>
     * Optional :ref:`active health checking &lt;arch_overview_health_checking&gt;`
     * configuration for the cluster. If no
     * configuration is specified no health checking will be done and all cluster
     * members will be considered healthy at all times.
     * </pre>
     *
     * <code>repeated .envoy.api.v2.core.HealthCheck health_checks = 8;</code>
     */
    public Builder clearHealthChecks() {
      if (healthChecksBuilder_ == null) {
        healthChecks_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x00000200);
        onChanged();
      } else {
        healthChecksBuilder_.clear();
      }
      return this;
    }
    /**
     * <pre>
     * Optional :ref:`active health checking &lt;arch_overview_health_checking&gt;`
     * configuration for the cluster. If no
     * configuration is specified no health checking will be done and all cluster
     * members will be considered healthy at all times.
     * </pre>
     *
     * <code>repeated .envoy.api.v2.core.HealthCheck health_checks = 8;</code>
     */
    public Builder removeHealthChecks(int index) {
      if (healthChecksBuilder_ == null) {
        ensureHealthChecksIsMutable();
        healthChecks_.remove(index);
        onChanged();
      } else {
        healthChecksBuilder_.remove(index);
      }
      return this;
    }
    /**
     * <pre>
     * Optional :ref:`active health checking &lt;arch_overview_health_checking&gt;`
     * configuration for the cluster. If no
     * configuration is specified no health checking will be done and all cluster
     * members will be considered healthy at all times.
     * </pre>
     *
     * <code>repeated .envoy.api.v2.core.HealthCheck health_checks = 8;</code>
     */
    public io.grpc.xds.shaded.envoy.api.v2.core.HealthCheck.Builder getHealthChecksBuilder(
        int index) {
      return getHealthChecksFieldBuilder().getBuilder(index);
    }
    /**
     * <pre>
     * Optional :ref:`active health checking &lt;arch_overview_health_checking&gt;`
     * configuration for the cluster. If no
     * configuration is specified no health checking will be done and all cluster
     * members will be considered healthy at all times.
     * </pre>
     *
     * <code>repeated .envoy.api.v2.core.HealthCheck health_checks = 8;</code>
     */
    public io.grpc.xds.shaded.envoy.api.v2.core.HealthCheckOrBuilder getHealthChecksOrBuilder(
        int index) {
      if (healthChecksBuilder_ == null) {
        return healthChecks_.get(index);  } else {
        return healthChecksBuilder_.getMessageOrBuilder(index);
      }
    }
    /**
     * <pre>
     * Optional :ref:`active health checking &lt;arch_overview_health_checking&gt;`
     * configuration for the cluster. If no
     * configuration is specified no health checking will be done and all cluster
     * members will be considered healthy at all times.
     * </pre>
     *
     * <code>repeated .envoy.api.v2.core.HealthCheck health_checks = 8;</code>
     */
    public java.util.List<? extends io.grpc.xds.shaded.envoy.api.v2.core.HealthCheckOrBuilder> 
         getHealthChecksOrBuilderList() {
      if (healthChecksBuilder_ != null) {
        return healthChecksBuilder_.getMessageOrBuilderList();
      } else {
        return java.util.Collections.unmodifiableList(healthChecks_);
      }
    }
    /**
     * <pre>
     * Optional :ref:`active health checking &lt;arch_overview_health_checking&gt;`
     * configuration for the cluster. If no
     * configuration is specified no health checking will be done and all cluster
     * members will be considered healthy at all times.
     * </pre>
     *
     * <code>repeated .envoy.api.v2.core.HealthCheck health_checks = 8;</code>
     */
    public io.grpc.xds.shaded.envoy.api.v2.core.HealthCheck.Builder addHealthChecksBuilder() {
      return getHealthChecksFieldBuilder().addBuilder(
          io.grpc.xds.shaded.envoy.api.v2.core.HealthCheck.getDefaultInstance());
    }
    /**
     * <pre>
     * Optional :ref:`active health checking &lt;arch_overview_health_checking&gt;`
     * configuration for the cluster. If no
     * configuration is specified no health checking will be done and all cluster
     * members will be considered healthy at all times.
     * </pre>
     *
     * <code>repeated .envoy.api.v2.core.HealthCheck health_checks = 8;</code>
     */
    public io.grpc.xds.shaded.envoy.api.v2.core.HealthCheck.Builder addHealthChecksBuilder(
        int index) {
      return getHealthChecksFieldBuilder().addBuilder(
          index, io.grpc.xds.shaded.envoy.api.v2.core.HealthCheck.getDefaultInstance());
    }
    /**
     * <pre>
     * Optional :ref:`active health checking &lt;arch_overview_health_checking&gt;`
     * configuration for the cluster. If no
     * configuration is specified no health checking will be done and all cluster
     * members will be considered healthy at all times.
     * </pre>
     *
     * <code>repeated .envoy.api.v2.core.HealthCheck health_checks = 8;</code>
     */
    public java.util.List<io.grpc.xds.shaded.envoy.api.v2.core.HealthCheck.Builder> 
         getHealthChecksBuilderList() {
      return getHealthChecksFieldBuilder().getBuilderList();
    }
    private com.google.protobuf.RepeatedFieldBuilderV3<
        io.grpc.xds.shaded.envoy.api.v2.core.HealthCheck, io.grpc.xds.shaded.envoy.api.v2.core.HealthCheck.Builder, io.grpc.xds.shaded.envoy.api.v2.core.HealthCheckOrBuilder> 
        getHealthChecksFieldBuilder() {
      if (healthChecksBuilder_ == null) {
        healthChecksBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
            io.grpc.xds.shaded.envoy.api.v2.core.HealthCheck, io.grpc.xds.shaded.envoy.api.v2.core.HealthCheck.Builder, io.grpc.xds.shaded.envoy.api.v2.core.HealthCheckOrBuilder>(
                healthChecks_,
                ((bitField0_ & 0x00000200) == 0x00000200),
                getParentForChildren(),
                isClean());
        healthChecks_ = null;
      }
      return healthChecksBuilder_;
    }

    private com.google.protobuf.UInt32Value maxRequestsPerConnection_ = null;
    private com.google.protobuf.SingleFieldBuilderV3<
        com.google.protobuf.UInt32Value, com.google.protobuf.UInt32Value.Builder, com.google.protobuf.UInt32ValueOrBuilder> maxRequestsPerConnectionBuilder_;
    /**
     * <pre>
     * Optional maximum requests for a single upstream connection. This parameter
     * is respected by both the HTTP/1.1 and HTTP/2 connection pool
     * implementations. If not specified, there is no limit. Setting this
     * parameter to 1 will effectively disable keep alive.
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value max_requests_per_connection = 9;</code>
     */
    public boolean hasMaxRequestsPerConnection() {
      return maxRequestsPerConnectionBuilder_ != null || maxRequestsPerConnection_ != null;
    }
    /**
     * <pre>
     * Optional maximum requests for a single upstream connection. This parameter
     * is respected by both the HTTP/1.1 and HTTP/2 connection pool
     * implementations. If not specified, there is no limit. Setting this
     * parameter to 1 will effectively disable keep alive.
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value max_requests_per_connection = 9;</code>
     */
    public com.google.protobuf.UInt32Value getMaxRequestsPerConnection() {
      if (maxRequestsPerConnectionBuilder_ == null) {
        return maxRequestsPerConnection_ == null ? com.google.protobuf.UInt32Value.getDefaultInstance() : maxRequestsPerConnection_;
      } else {
        return maxRequestsPerConnectionBuilder_.getMessage();
      }
    }
    /**
     * <pre>
     * Optional maximum requests for a single upstream connection. This parameter
     * is respected by both the HTTP/1.1 and HTTP/2 connection pool
     * implementations. If not specified, there is no limit. Setting this
     * parameter to 1 will effectively disable keep alive.
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value max_requests_per_connection = 9;</code>
     */
    public Builder setMaxRequestsPerConnection(com.google.protobuf.UInt32Value value) {
      if (maxRequestsPerConnectionBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        maxRequestsPerConnection_ = value;
        onChanged();
      } else {
        maxRequestsPerConnectionBuilder_.setMessage(value);
      }

      return this;
    }
    /**
     * <pre>
     * Optional maximum requests for a single upstream connection. This parameter
     * is respected by both the HTTP/1.1 and HTTP/2 connection pool
     * implementations. If not specified, there is no limit. Setting this
     * parameter to 1 will effectively disable keep alive.
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value max_requests_per_connection = 9;</code>
     */
    public Builder setMaxRequestsPerConnection(
        com.google.protobuf.UInt32Value.Builder builderForValue) {
      if (maxRequestsPerConnectionBuilder_ == null) {
        maxRequestsPerConnection_ = builderForValue.build();
        onChanged();
      } else {
        maxRequestsPerConnectionBuilder_.setMessage(builderForValue.build());
      }

      return this;
    }
    /**
     * <pre>
     * Optional maximum requests for a single upstream connection. This parameter
     * is respected by both the HTTP/1.1 and HTTP/2 connection pool
     * implementations. If not specified, there is no limit. Setting this
     * parameter to 1 will effectively disable keep alive.
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value max_requests_per_connection = 9;</code>
     */
    public Builder mergeMaxRequestsPerConnection(com.google.protobuf.UInt32Value value) {
      if (maxRequestsPerConnectionBuilder_ == null) {
        if (maxRequestsPerConnection_ != null) {
          maxRequestsPerConnection_ =
            com.google.protobuf.UInt32Value.newBuilder(maxRequestsPerConnection_).mergeFrom(value).buildPartial();
        } else {
          maxRequestsPerConnection_ = value;
        }
        onChanged();
      } else {
        maxRequestsPerConnectionBuilder_.mergeFrom(value);
      }

      return this;
    }
    /**
     * <pre>
     * Optional maximum requests for a single upstream connection. This parameter
     * is respected by both the HTTP/1.1 and HTTP/2 connection pool
     * implementations. If not specified, there is no limit. Setting this
     * parameter to 1 will effectively disable keep alive.
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value max_requests_per_connection = 9;</code>
     */
    public Builder clearMaxRequestsPerConnection() {
      if (maxRequestsPerConnectionBuilder_ == null) {
        maxRequestsPerConnection_ = null;
        onChanged();
      } else {
        maxRequestsPerConnection_ = null;
        maxRequestsPerConnectionBuilder_ = null;
      }

      return this;
    }
    /**
     * <pre>
     * Optional maximum requests for a single upstream connection. This parameter
     * is respected by both the HTTP/1.1 and HTTP/2 connection pool
     * implementations. If not specified, there is no limit. Setting this
     * parameter to 1 will effectively disable keep alive.
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value max_requests_per_connection = 9;</code>
     */
    public com.google.protobuf.UInt32Value.Builder getMaxRequestsPerConnectionBuilder() {
      
      onChanged();
      return getMaxRequestsPerConnectionFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * Optional maximum requests for a single upstream connection. This parameter
     * is respected by both the HTTP/1.1 and HTTP/2 connection pool
     * implementations. If not specified, there is no limit. Setting this
     * parameter to 1 will effectively disable keep alive.
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value max_requests_per_connection = 9;</code>
     */
    public com.google.protobuf.UInt32ValueOrBuilder getMaxRequestsPerConnectionOrBuilder() {
      if (maxRequestsPerConnectionBuilder_ != null) {
        return maxRequestsPerConnectionBuilder_.getMessageOrBuilder();
      } else {
        return maxRequestsPerConnection_ == null ?
            com.google.protobuf.UInt32Value.getDefaultInstance() : maxRequestsPerConnection_;
      }
    }
    /**
     * <pre>
     * Optional maximum requests for a single upstream connection. This parameter
     * is respected by both the HTTP/1.1 and HTTP/2 connection pool
     * implementations. If not specified, there is no limit. Setting this
     * parameter to 1 will effectively disable keep alive.
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value max_requests_per_connection = 9;</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        com.google.protobuf.UInt32Value, com.google.protobuf.UInt32Value.Builder, com.google.protobuf.UInt32ValueOrBuilder> 
        getMaxRequestsPerConnectionFieldBuilder() {
      if (maxRequestsPerConnectionBuilder_ == null) {
        maxRequestsPerConnectionBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            com.google.protobuf.UInt32Value, com.google.protobuf.UInt32Value.Builder, com.google.protobuf.UInt32ValueOrBuilder>(
                getMaxRequestsPerConnection(),
                getParentForChildren(),
                isClean());
        maxRequestsPerConnection_ = null;
      }
      return maxRequestsPerConnectionBuilder_;
    }

    private io.grpc.xds.shaded.envoy.api.v2.cluster.CircuitBreakers circuitBreakers_ = null;
    private com.google.protobuf.SingleFieldBuilderV3<
        io.grpc.xds.shaded.envoy.api.v2.cluster.CircuitBreakers, io.grpc.xds.shaded.envoy.api.v2.cluster.CircuitBreakers.Builder, io.grpc.xds.shaded.envoy.api.v2.cluster.CircuitBreakersOrBuilder> circuitBreakersBuilder_;
    /**
     * <pre>
     * Optional :ref:`circuit breaking &lt;arch_overview_circuit_break&gt;` for the cluster.
     * </pre>
     *
     * <code>.envoy.api.v2.cluster.CircuitBreakers circuit_breakers = 10;</code>
     */
    public boolean hasCircuitBreakers() {
      return circuitBreakersBuilder_ != null || circuitBreakers_ != null;
    }
    /**
     * <pre>
     * Optional :ref:`circuit breaking &lt;arch_overview_circuit_break&gt;` for the cluster.
     * </pre>
     *
     * <code>.envoy.api.v2.cluster.CircuitBreakers circuit_breakers = 10;</code>
     */
    public io.grpc.xds.shaded.envoy.api.v2.cluster.CircuitBreakers getCircuitBreakers() {
      if (circuitBreakersBuilder_ == null) {
        return circuitBreakers_ == null ? io.grpc.xds.shaded.envoy.api.v2.cluster.CircuitBreakers.getDefaultInstance() : circuitBreakers_;
      } else {
        return circuitBreakersBuilder_.getMessage();
      }
    }
    /**
     * <pre>
     * Optional :ref:`circuit breaking &lt;arch_overview_circuit_break&gt;` for the cluster.
     * </pre>
     *
     * <code>.envoy.api.v2.cluster.CircuitBreakers circuit_breakers = 10;</code>
     */
    public Builder setCircuitBreakers(io.grpc.xds.shaded.envoy.api.v2.cluster.CircuitBreakers value) {
      if (circuitBreakersBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        circuitBreakers_ = value;
        onChanged();
      } else {
        circuitBreakersBuilder_.setMessage(value);
      }

      return this;
    }
    /**
     * <pre>
     * Optional :ref:`circuit breaking &lt;arch_overview_circuit_break&gt;` for the cluster.
     * </pre>
     *
     * <code>.envoy.api.v2.cluster.CircuitBreakers circuit_breakers = 10;</code>
     */
    public Builder setCircuitBreakers(
        io.grpc.xds.shaded.envoy.api.v2.cluster.CircuitBreakers.Builder builderForValue) {
      if (circuitBreakersBuilder_ == null) {
        circuitBreakers_ = builderForValue.build();
        onChanged();
      } else {
        circuitBreakersBuilder_.setMessage(builderForValue.build());
      }

      return this;
    }
    /**
     * <pre>
     * Optional :ref:`circuit breaking &lt;arch_overview_circuit_break&gt;` for the cluster.
     * </pre>
     *
     * <code>.envoy.api.v2.cluster.CircuitBreakers circuit_breakers = 10;</code>
     */
    public Builder mergeCircuitBreakers(io.grpc.xds.shaded.envoy.api.v2.cluster.CircuitBreakers value) {
      if (circuitBreakersBuilder_ == null) {
        if (circuitBreakers_ != null) {
          circuitBreakers_ =
            io.grpc.xds.shaded.envoy.api.v2.cluster.CircuitBreakers.newBuilder(circuitBreakers_).mergeFrom(value).buildPartial();
        } else {
          circuitBreakers_ = value;
        }
        onChanged();
      } else {
        circuitBreakersBuilder_.mergeFrom(value);
      }

      return this;
    }
    /**
     * <pre>
     * Optional :ref:`circuit breaking &lt;arch_overview_circuit_break&gt;` for the cluster.
     * </pre>
     *
     * <code>.envoy.api.v2.cluster.CircuitBreakers circuit_breakers = 10;</code>
     */
    public Builder clearCircuitBreakers() {
      if (circuitBreakersBuilder_ == null) {
        circuitBreakers_ = null;
        onChanged();
      } else {
        circuitBreakers_ = null;
        circuitBreakersBuilder_ = null;
      }

      return this;
    }
    /**
     * <pre>
     * Optional :ref:`circuit breaking &lt;arch_overview_circuit_break&gt;` for the cluster.
     * </pre>
     *
     * <code>.envoy.api.v2.cluster.CircuitBreakers circuit_breakers = 10;</code>
     */
    public io.grpc.xds.shaded.envoy.api.v2.cluster.CircuitBreakers.Builder getCircuitBreakersBuilder() {
      
      onChanged();
      return getCircuitBreakersFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * Optional :ref:`circuit breaking &lt;arch_overview_circuit_break&gt;` for the cluster.
     * </pre>
     *
     * <code>.envoy.api.v2.cluster.CircuitBreakers circuit_breakers = 10;</code>
     */
    public io.grpc.xds.shaded.envoy.api.v2.cluster.CircuitBreakersOrBuilder getCircuitBreakersOrBuilder() {
      if (circuitBreakersBuilder_ != null) {
        return circuitBreakersBuilder_.getMessageOrBuilder();
      } else {
        return circuitBreakers_ == null ?
            io.grpc.xds.shaded.envoy.api.v2.cluster.CircuitBreakers.getDefaultInstance() : circuitBreakers_;
      }
    }
    /**
     * <pre>
     * Optional :ref:`circuit breaking &lt;arch_overview_circuit_break&gt;` for the cluster.
     * </pre>
     *
     * <code>.envoy.api.v2.cluster.CircuitBreakers circuit_breakers = 10;</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        io.grpc.xds.shaded.envoy.api.v2.cluster.CircuitBreakers, io.grpc.xds.shaded.envoy.api.v2.cluster.CircuitBreakers.Builder, io.grpc.xds.shaded.envoy.api.v2.cluster.CircuitBreakersOrBuilder> 
        getCircuitBreakersFieldBuilder() {
      if (circuitBreakersBuilder_ == null) {
        circuitBreakersBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            io.grpc.xds.shaded.envoy.api.v2.cluster.CircuitBreakers, io.grpc.xds.shaded.envoy.api.v2.cluster.CircuitBreakers.Builder, io.grpc.xds.shaded.envoy.api.v2.cluster.CircuitBreakersOrBuilder>(
                getCircuitBreakers(),
                getParentForChildren(),
                isClean());
        circuitBreakers_ = null;
      }
      return circuitBreakersBuilder_;
    }

    private io.grpc.xds.shaded.envoy.api.v2.auth.UpstreamTlsContext tlsContext_ = null;
    private com.google.protobuf.SingleFieldBuilderV3<
        io.grpc.xds.shaded.envoy.api.v2.auth.UpstreamTlsContext, io.grpc.xds.shaded.envoy.api.v2.auth.UpstreamTlsContext.Builder, io.grpc.xds.shaded.envoy.api.v2.auth.UpstreamTlsContextOrBuilder> tlsContextBuilder_;
    /**
     * <pre>
     * The TLS configuration for connections to the upstream cluster. If no TLS
     * configuration is specified, TLS will not be used for new connections.
     * .. attention::
     *   Server certificate verification is not enabled by default. Configure
     *   :ref:`trusted_ca&lt;envoy_api_field_auth.CertificateValidationContext.trusted_ca&gt;` to enable
     *   verification.
     * </pre>
     *
     * <code>.envoy.api.v2.auth.UpstreamTlsContext tls_context = 11;</code>
     */
    public boolean hasTlsContext() {
      return tlsContextBuilder_ != null || tlsContext_ != null;
    }
    /**
     * <pre>
     * The TLS configuration for connections to the upstream cluster. If no TLS
     * configuration is specified, TLS will not be used for new connections.
     * .. attention::
     *   Server certificate verification is not enabled by default. Configure
     *   :ref:`trusted_ca&lt;envoy_api_field_auth.CertificateValidationContext.trusted_ca&gt;` to enable
     *   verification.
     * </pre>
     *
     * <code>.envoy.api.v2.auth.UpstreamTlsContext tls_context = 11;</code>
     */
    public io.grpc.xds.shaded.envoy.api.v2.auth.UpstreamTlsContext getTlsContext() {
      if (tlsContextBuilder_ == null) {
        return tlsContext_ == null ? io.grpc.xds.shaded.envoy.api.v2.auth.UpstreamTlsContext.getDefaultInstance() : tlsContext_;
      } else {
        return tlsContextBuilder_.getMessage();
      }
    }
    /**
     * <pre>
     * The TLS configuration for connections to the upstream cluster. If no TLS
     * configuration is specified, TLS will not be used for new connections.
     * .. attention::
     *   Server certificate verification is not enabled by default. Configure
     *   :ref:`trusted_ca&lt;envoy_api_field_auth.CertificateValidationContext.trusted_ca&gt;` to enable
     *   verification.
     * </pre>
     *
     * <code>.envoy.api.v2.auth.UpstreamTlsContext tls_context = 11;</code>
     */
    public Builder setTlsContext(io.grpc.xds.shaded.envoy.api.v2.auth.UpstreamTlsContext value) {
      if (tlsContextBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        tlsContext_ = value;
        onChanged();
      } else {
        tlsContextBuilder_.setMessage(value);
      }

      return this;
    }
    /**
     * <pre>
     * The TLS configuration for connections to the upstream cluster. If no TLS
     * configuration is specified, TLS will not be used for new connections.
     * .. attention::
     *   Server certificate verification is not enabled by default. Configure
     *   :ref:`trusted_ca&lt;envoy_api_field_auth.CertificateValidationContext.trusted_ca&gt;` to enable
     *   verification.
     * </pre>
     *
     * <code>.envoy.api.v2.auth.UpstreamTlsContext tls_context = 11;</code>
     */
    public Builder setTlsContext(
        io.grpc.xds.shaded.envoy.api.v2.auth.UpstreamTlsContext.Builder builderForValue) {
      if (tlsContextBuilder_ == null) {
        tlsContext_ = builderForValue.build();
        onChanged();
      } else {
        tlsContextBuilder_.setMessage(builderForValue.build());
      }

      return this;
    }
    /**
     * <pre>
     * The TLS configuration for connections to the upstream cluster. If no TLS
     * configuration is specified, TLS will not be used for new connections.
     * .. attention::
     *   Server certificate verification is not enabled by default. Configure
     *   :ref:`trusted_ca&lt;envoy_api_field_auth.CertificateValidationContext.trusted_ca&gt;` to enable
     *   verification.
     * </pre>
     *
     * <code>.envoy.api.v2.auth.UpstreamTlsContext tls_context = 11;</code>
     */
    public Builder mergeTlsContext(io.grpc.xds.shaded.envoy.api.v2.auth.UpstreamTlsContext value) {
      if (tlsContextBuilder_ == null) {
        if (tlsContext_ != null) {
          tlsContext_ =
            io.grpc.xds.shaded.envoy.api.v2.auth.UpstreamTlsContext.newBuilder(tlsContext_).mergeFrom(value).buildPartial();
        } else {
          tlsContext_ = value;
        }
        onChanged();
      } else {
        tlsContextBuilder_.mergeFrom(value);
      }

      return this;
    }
    /**
     * <pre>
     * The TLS configuration for connections to the upstream cluster. If no TLS
     * configuration is specified, TLS will not be used for new connections.
     * .. attention::
     *   Server certificate verification is not enabled by default. Configure
     *   :ref:`trusted_ca&lt;envoy_api_field_auth.CertificateValidationContext.trusted_ca&gt;` to enable
     *   verification.
     * </pre>
     *
     * <code>.envoy.api.v2.auth.UpstreamTlsContext tls_context = 11;</code>
     */
    public Builder clearTlsContext() {
      if (tlsContextBuilder_ == null) {
        tlsContext_ = null;
        onChanged();
      } else {
        tlsContext_ = null;
        tlsContextBuilder_ = null;
      }

      return this;
    }
    /**
     * <pre>
     * The TLS configuration for connections to the upstream cluster. If no TLS
     * configuration is specified, TLS will not be used for new connections.
     * .. attention::
     *   Server certificate verification is not enabled by default. Configure
     *   :ref:`trusted_ca&lt;envoy_api_field_auth.CertificateValidationContext.trusted_ca&gt;` to enable
     *   verification.
     * </pre>
     *
     * <code>.envoy.api.v2.auth.UpstreamTlsContext tls_context = 11;</code>
     */
    public io.grpc.xds.shaded.envoy.api.v2.auth.UpstreamTlsContext.Builder getTlsContextBuilder() {
      
      onChanged();
      return getTlsContextFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * The TLS configuration for connections to the upstream cluster. If no TLS
     * configuration is specified, TLS will not be used for new connections.
     * .. attention::
     *   Server certificate verification is not enabled by default. Configure
     *   :ref:`trusted_ca&lt;envoy_api_field_auth.CertificateValidationContext.trusted_ca&gt;` to enable
     *   verification.
     * </pre>
     *
     * <code>.envoy.api.v2.auth.UpstreamTlsContext tls_context = 11;</code>
     */
    public io.grpc.xds.shaded.envoy.api.v2.auth.UpstreamTlsContextOrBuilder getTlsContextOrBuilder() {
      if (tlsContextBuilder_ != null) {
        return tlsContextBuilder_.getMessageOrBuilder();
      } else {
        return tlsContext_ == null ?
            io.grpc.xds.shaded.envoy.api.v2.auth.UpstreamTlsContext.getDefaultInstance() : tlsContext_;
      }
    }
    /**
     * <pre>
     * The TLS configuration for connections to the upstream cluster. If no TLS
     * configuration is specified, TLS will not be used for new connections.
     * .. attention::
     *   Server certificate verification is not enabled by default. Configure
     *   :ref:`trusted_ca&lt;envoy_api_field_auth.CertificateValidationContext.trusted_ca&gt;` to enable
     *   verification.
     * </pre>
     *
     * <code>.envoy.api.v2.auth.UpstreamTlsContext tls_context = 11;</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        io.grpc.xds.shaded.envoy.api.v2.auth.UpstreamTlsContext, io.grpc.xds.shaded.envoy.api.v2.auth.UpstreamTlsContext.Builder, io.grpc.xds.shaded.envoy.api.v2.auth.UpstreamTlsContextOrBuilder> 
        getTlsContextFieldBuilder() {
      if (tlsContextBuilder_ == null) {
        tlsContextBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            io.grpc.xds.shaded.envoy.api.v2.auth.UpstreamTlsContext, io.grpc.xds.shaded.envoy.api.v2.auth.UpstreamTlsContext.Builder, io.grpc.xds.shaded.envoy.api.v2.auth.UpstreamTlsContextOrBuilder>(
                getTlsContext(),
                getParentForChildren(),
                isClean());
        tlsContext_ = null;
      }
      return tlsContextBuilder_;
    }

    private io.grpc.xds.shaded.envoy.api.v2.core.HttpProtocolOptions commonHttpProtocolOptions_ = null;
    private com.google.protobuf.SingleFieldBuilderV3<
        io.grpc.xds.shaded.envoy.api.v2.core.HttpProtocolOptions, io.grpc.xds.shaded.envoy.api.v2.core.HttpProtocolOptions.Builder, io.grpc.xds.shaded.envoy.api.v2.core.HttpProtocolOptionsOrBuilder> commonHttpProtocolOptionsBuilder_;
    /**
     * <pre>
     * Additional options when handling HTTP requests. These options will be applicable to both
     * HTTP1 and HTTP2 requests.
     * </pre>
     *
     * <code>.envoy.api.v2.core.HttpProtocolOptions common_http_protocol_options = 29;</code>
     */
    public boolean hasCommonHttpProtocolOptions() {
      return commonHttpProtocolOptionsBuilder_ != null || commonHttpProtocolOptions_ != null;
    }
    /**
     * <pre>
     * Additional options when handling HTTP requests. These options will be applicable to both
     * HTTP1 and HTTP2 requests.
     * </pre>
     *
     * <code>.envoy.api.v2.core.HttpProtocolOptions common_http_protocol_options = 29;</code>
     */
    public io.grpc.xds.shaded.envoy.api.v2.core.HttpProtocolOptions getCommonHttpProtocolOptions() {
      if (commonHttpProtocolOptionsBuilder_ == null) {
        return commonHttpProtocolOptions_ == null ? io.grpc.xds.shaded.envoy.api.v2.core.HttpProtocolOptions.getDefaultInstance() : commonHttpProtocolOptions_;
      } else {
        return commonHttpProtocolOptionsBuilder_.getMessage();
      }
    }
    /**
     * <pre>
     * Additional options when handling HTTP requests. These options will be applicable to both
     * HTTP1 and HTTP2 requests.
     * </pre>
     *
     * <code>.envoy.api.v2.core.HttpProtocolOptions common_http_protocol_options = 29;</code>
     */
    public Builder setCommonHttpProtocolOptions(io.grpc.xds.shaded.envoy.api.v2.core.HttpProtocolOptions value) {
      if (commonHttpProtocolOptionsBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        commonHttpProtocolOptions_ = value;
        onChanged();
      } else {
        commonHttpProtocolOptionsBuilder_.setMessage(value);
      }

      return this;
    }
    /**
     * <pre>
     * Additional options when handling HTTP requests. These options will be applicable to both
     * HTTP1 and HTTP2 requests.
     * </pre>
     *
     * <code>.envoy.api.v2.core.HttpProtocolOptions common_http_protocol_options = 29;</code>
     */
    public Builder setCommonHttpProtocolOptions(
        io.grpc.xds.shaded.envoy.api.v2.core.HttpProtocolOptions.Builder builderForValue) {
      if (commonHttpProtocolOptionsBuilder_ == null) {
        commonHttpProtocolOptions_ = builderForValue.build();
        onChanged();
      } else {
        commonHttpProtocolOptionsBuilder_.setMessage(builderForValue.build());
      }

      return this;
    }
    /**
     * <pre>
     * Additional options when handling HTTP requests. These options will be applicable to both
     * HTTP1 and HTTP2 requests.
     * </pre>
     *
     * <code>.envoy.api.v2.core.HttpProtocolOptions common_http_protocol_options = 29;</code>
     */
    public Builder mergeCommonHttpProtocolOptions(io.grpc.xds.shaded.envoy.api.v2.core.HttpProtocolOptions value) {
      if (commonHttpProtocolOptionsBuilder_ == null) {
        if (commonHttpProtocolOptions_ != null) {
          commonHttpProtocolOptions_ =
            io.grpc.xds.shaded.envoy.api.v2.core.HttpProtocolOptions.newBuilder(commonHttpProtocolOptions_).mergeFrom(value).buildPartial();
        } else {
          commonHttpProtocolOptions_ = value;
        }
        onChanged();
      } else {
        commonHttpProtocolOptionsBuilder_.mergeFrom(value);
      }

      return this;
    }
    /**
     * <pre>
     * Additional options when handling HTTP requests. These options will be applicable to both
     * HTTP1 and HTTP2 requests.
     * </pre>
     *
     * <code>.envoy.api.v2.core.HttpProtocolOptions common_http_protocol_options = 29;</code>
     */
    public Builder clearCommonHttpProtocolOptions() {
      if (commonHttpProtocolOptionsBuilder_ == null) {
        commonHttpProtocolOptions_ = null;
        onChanged();
      } else {
        commonHttpProtocolOptions_ = null;
        commonHttpProtocolOptionsBuilder_ = null;
      }

      return this;
    }
    /**
     * <pre>
     * Additional options when handling HTTP requests. These options will be applicable to both
     * HTTP1 and HTTP2 requests.
     * </pre>
     *
     * <code>.envoy.api.v2.core.HttpProtocolOptions common_http_protocol_options = 29;</code>
     */
    public io.grpc.xds.shaded.envoy.api.v2.core.HttpProtocolOptions.Builder getCommonHttpProtocolOptionsBuilder() {
      
      onChanged();
      return getCommonHttpProtocolOptionsFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * Additional options when handling HTTP requests. These options will be applicable to both
     * HTTP1 and HTTP2 requests.
     * </pre>
     *
     * <code>.envoy.api.v2.core.HttpProtocolOptions common_http_protocol_options = 29;</code>
     */
    public io.grpc.xds.shaded.envoy.api.v2.core.HttpProtocolOptionsOrBuilder getCommonHttpProtocolOptionsOrBuilder() {
      if (commonHttpProtocolOptionsBuilder_ != null) {
        return commonHttpProtocolOptionsBuilder_.getMessageOrBuilder();
      } else {
        return commonHttpProtocolOptions_ == null ?
            io.grpc.xds.shaded.envoy.api.v2.core.HttpProtocolOptions.getDefaultInstance() : commonHttpProtocolOptions_;
      }
    }
    /**
     * <pre>
     * Additional options when handling HTTP requests. These options will be applicable to both
     * HTTP1 and HTTP2 requests.
     * </pre>
     *
     * <code>.envoy.api.v2.core.HttpProtocolOptions common_http_protocol_options = 29;</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        io.grpc.xds.shaded.envoy.api.v2.core.HttpProtocolOptions, io.grpc.xds.shaded.envoy.api.v2.core.HttpProtocolOptions.Builder, io.grpc.xds.shaded.envoy.api.v2.core.HttpProtocolOptionsOrBuilder> 
        getCommonHttpProtocolOptionsFieldBuilder() {
      if (commonHttpProtocolOptionsBuilder_ == null) {
        commonHttpProtocolOptionsBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            io.grpc.xds.shaded.envoy.api.v2.core.HttpProtocolOptions, io.grpc.xds.shaded.envoy.api.v2.core.HttpProtocolOptions.Builder, io.grpc.xds.shaded.envoy.api.v2.core.HttpProtocolOptionsOrBuilder>(
                getCommonHttpProtocolOptions(),
                getParentForChildren(),
                isClean());
        commonHttpProtocolOptions_ = null;
      }
      return commonHttpProtocolOptionsBuilder_;
    }

    private io.grpc.xds.shaded.envoy.api.v2.core.Http1ProtocolOptions httpProtocolOptions_ = null;
    private com.google.protobuf.SingleFieldBuilderV3<
        io.grpc.xds.shaded.envoy.api.v2.core.Http1ProtocolOptions, io.grpc.xds.shaded.envoy.api.v2.core.Http1ProtocolOptions.Builder, io.grpc.xds.shaded.envoy.api.v2.core.Http1ProtocolOptionsOrBuilder> httpProtocolOptionsBuilder_;
    /**
     * <pre>
     * Additional options when handling HTTP1 requests.
     * </pre>
     *
     * <code>.envoy.api.v2.core.Http1ProtocolOptions http_protocol_options = 13;</code>
     */
    public boolean hasHttpProtocolOptions() {
      return httpProtocolOptionsBuilder_ != null || httpProtocolOptions_ != null;
    }
    /**
     * <pre>
     * Additional options when handling HTTP1 requests.
     * </pre>
     *
     * <code>.envoy.api.v2.core.Http1ProtocolOptions http_protocol_options = 13;</code>
     */
    public io.grpc.xds.shaded.envoy.api.v2.core.Http1ProtocolOptions getHttpProtocolOptions() {
      if (httpProtocolOptionsBuilder_ == null) {
        return httpProtocolOptions_ == null ? io.grpc.xds.shaded.envoy.api.v2.core.Http1ProtocolOptions.getDefaultInstance() : httpProtocolOptions_;
      } else {
        return httpProtocolOptionsBuilder_.getMessage();
      }
    }
    /**
     * <pre>
     * Additional options when handling HTTP1 requests.
     * </pre>
     *
     * <code>.envoy.api.v2.core.Http1ProtocolOptions http_protocol_options = 13;</code>
     */
    public Builder setHttpProtocolOptions(io.grpc.xds.shaded.envoy.api.v2.core.Http1ProtocolOptions value) {
      if (httpProtocolOptionsBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        httpProtocolOptions_ = value;
        onChanged();
      } else {
        httpProtocolOptionsBuilder_.setMessage(value);
      }

      return this;
    }
    /**
     * <pre>
     * Additional options when handling HTTP1 requests.
     * </pre>
     *
     * <code>.envoy.api.v2.core.Http1ProtocolOptions http_protocol_options = 13;</code>
     */
    public Builder setHttpProtocolOptions(
        io.grpc.xds.shaded.envoy.api.v2.core.Http1ProtocolOptions.Builder builderForValue) {
      if (httpProtocolOptionsBuilder_ == null) {
        httpProtocolOptions_ = builderForValue.build();
        onChanged();
      } else {
        httpProtocolOptionsBuilder_.setMessage(builderForValue.build());
      }

      return this;
    }
    /**
     * <pre>
     * Additional options when handling HTTP1 requests.
     * </pre>
     *
     * <code>.envoy.api.v2.core.Http1ProtocolOptions http_protocol_options = 13;</code>
     */
    public Builder mergeHttpProtocolOptions(io.grpc.xds.shaded.envoy.api.v2.core.Http1ProtocolOptions value) {
      if (httpProtocolOptionsBuilder_ == null) {
        if (httpProtocolOptions_ != null) {
          httpProtocolOptions_ =
            io.grpc.xds.shaded.envoy.api.v2.core.Http1ProtocolOptions.newBuilder(httpProtocolOptions_).mergeFrom(value).buildPartial();
        } else {
          httpProtocolOptions_ = value;
        }
        onChanged();
      } else {
        httpProtocolOptionsBuilder_.mergeFrom(value);
      }

      return this;
    }
    /**
     * <pre>
     * Additional options when handling HTTP1 requests.
     * </pre>
     *
     * <code>.envoy.api.v2.core.Http1ProtocolOptions http_protocol_options = 13;</code>
     */
    public Builder clearHttpProtocolOptions() {
      if (httpProtocolOptionsBuilder_ == null) {
        httpProtocolOptions_ = null;
        onChanged();
      } else {
        httpProtocolOptions_ = null;
        httpProtocolOptionsBuilder_ = null;
      }

      return this;
    }
    /**
     * <pre>
     * Additional options when handling HTTP1 requests.
     * </pre>
     *
     * <code>.envoy.api.v2.core.Http1ProtocolOptions http_protocol_options = 13;</code>
     */
    public io.grpc.xds.shaded.envoy.api.v2.core.Http1ProtocolOptions.Builder getHttpProtocolOptionsBuilder() {
      
      onChanged();
      return getHttpProtocolOptionsFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * Additional options when handling HTTP1 requests.
     * </pre>
     *
     * <code>.envoy.api.v2.core.Http1ProtocolOptions http_protocol_options = 13;</code>
     */
    public io.grpc.xds.shaded.envoy.api.v2.core.Http1ProtocolOptionsOrBuilder getHttpProtocolOptionsOrBuilder() {
      if (httpProtocolOptionsBuilder_ != null) {
        return httpProtocolOptionsBuilder_.getMessageOrBuilder();
      } else {
        return httpProtocolOptions_ == null ?
            io.grpc.xds.shaded.envoy.api.v2.core.Http1ProtocolOptions.getDefaultInstance() : httpProtocolOptions_;
      }
    }
    /**
     * <pre>
     * Additional options when handling HTTP1 requests.
     * </pre>
     *
     * <code>.envoy.api.v2.core.Http1ProtocolOptions http_protocol_options = 13;</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        io.grpc.xds.shaded.envoy.api.v2.core.Http1ProtocolOptions, io.grpc.xds.shaded.envoy.api.v2.core.Http1ProtocolOptions.Builder, io.grpc.xds.shaded.envoy.api.v2.core.Http1ProtocolOptionsOrBuilder> 
        getHttpProtocolOptionsFieldBuilder() {
      if (httpProtocolOptionsBuilder_ == null) {
        httpProtocolOptionsBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            io.grpc.xds.shaded.envoy.api.v2.core.Http1ProtocolOptions, io.grpc.xds.shaded.envoy.api.v2.core.Http1ProtocolOptions.Builder, io.grpc.xds.shaded.envoy.api.v2.core.Http1ProtocolOptionsOrBuilder>(
                getHttpProtocolOptions(),
                getParentForChildren(),
                isClean());
        httpProtocolOptions_ = null;
      }
      return httpProtocolOptionsBuilder_;
    }

    private io.grpc.xds.shaded.envoy.api.v2.core.Http2ProtocolOptions http2ProtocolOptions_ = null;
    private com.google.protobuf.SingleFieldBuilderV3<
        io.grpc.xds.shaded.envoy.api.v2.core.Http2ProtocolOptions, io.grpc.xds.shaded.envoy.api.v2.core.Http2ProtocolOptions.Builder, io.grpc.xds.shaded.envoy.api.v2.core.Http2ProtocolOptionsOrBuilder> http2ProtocolOptionsBuilder_;
    /**
     * <pre>
     * Even if default HTTP2 protocol options are desired, this field must be
     * set so that Envoy will assume that the upstream supports HTTP/2 when
     * making new HTTP connection pool connections. Currently, Envoy only
     * supports prior knowledge for upstream connections. Even if TLS is used
     * with ALPN, `http2_protocol_options` must be specified. As an aside this allows HTTP/2
     * connections to happen over plain text.
     * </pre>
     *
     * <code>.envoy.api.v2.core.Http2ProtocolOptions http2_protocol_options = 14;</code>
     */
    public boolean hasHttp2ProtocolOptions() {
      return http2ProtocolOptionsBuilder_ != null || http2ProtocolOptions_ != null;
    }
    /**
     * <pre>
     * Even if default HTTP2 protocol options are desired, this field must be
     * set so that Envoy will assume that the upstream supports HTTP/2 when
     * making new HTTP connection pool connections. Currently, Envoy only
     * supports prior knowledge for upstream connections. Even if TLS is used
     * with ALPN, `http2_protocol_options` must be specified. As an aside this allows HTTP/2
     * connections to happen over plain text.
     * </pre>
     *
     * <code>.envoy.api.v2.core.Http2ProtocolOptions http2_protocol_options = 14;</code>
     */
    public io.grpc.xds.shaded.envoy.api.v2.core.Http2ProtocolOptions getHttp2ProtocolOptions() {
      if (http2ProtocolOptionsBuilder_ == null) {
        return http2ProtocolOptions_ == null ? io.grpc.xds.shaded.envoy.api.v2.core.Http2ProtocolOptions.getDefaultInstance() : http2ProtocolOptions_;
      } else {
        return http2ProtocolOptionsBuilder_.getMessage();
      }
    }
    /**
     * <pre>
     * Even if default HTTP2 protocol options are desired, this field must be
     * set so that Envoy will assume that the upstream supports HTTP/2 when
     * making new HTTP connection pool connections. Currently, Envoy only
     * supports prior knowledge for upstream connections. Even if TLS is used
     * with ALPN, `http2_protocol_options` must be specified. As an aside this allows HTTP/2
     * connections to happen over plain text.
     * </pre>
     *
     * <code>.envoy.api.v2.core.Http2ProtocolOptions http2_protocol_options = 14;</code>
     */
    public Builder setHttp2ProtocolOptions(io.grpc.xds.shaded.envoy.api.v2.core.Http2ProtocolOptions value) {
      if (http2ProtocolOptionsBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        http2ProtocolOptions_ = value;
        onChanged();
      } else {
        http2ProtocolOptionsBuilder_.setMessage(value);
      }

      return this;
    }
    /**
     * <pre>
     * Even if default HTTP2 protocol options are desired, this field must be
     * set so that Envoy will assume that the upstream supports HTTP/2 when
     * making new HTTP connection pool connections. Currently, Envoy only
     * supports prior knowledge for upstream connections. Even if TLS is used
     * with ALPN, `http2_protocol_options` must be specified. As an aside this allows HTTP/2
     * connections to happen over plain text.
     * </pre>
     *
     * <code>.envoy.api.v2.core.Http2ProtocolOptions http2_protocol_options = 14;</code>
     */
    public Builder setHttp2ProtocolOptions(
        io.grpc.xds.shaded.envoy.api.v2.core.Http2ProtocolOptions.Builder builderForValue) {
      if (http2ProtocolOptionsBuilder_ == null) {
        http2ProtocolOptions_ = builderForValue.build();
        onChanged();
      } else {
        http2ProtocolOptionsBuilder_.setMessage(builderForValue.build());
      }

      return this;
    }
    /**
     * <pre>
     * Even if default HTTP2 protocol options are desired, this field must be
     * set so that Envoy will assume that the upstream supports HTTP/2 when
     * making new HTTP connection pool connections. Currently, Envoy only
     * supports prior knowledge for upstream connections. Even if TLS is used
     * with ALPN, `http2_protocol_options` must be specified. As an aside this allows HTTP/2
     * connections to happen over plain text.
     * </pre>
     *
     * <code>.envoy.api.v2.core.Http2ProtocolOptions http2_protocol_options = 14;</code>
     */
    public Builder mergeHttp2ProtocolOptions(io.grpc.xds.shaded.envoy.api.v2.core.Http2ProtocolOptions value) {
      if (http2ProtocolOptionsBuilder_ == null) {
        if (http2ProtocolOptions_ != null) {
          http2ProtocolOptions_ =
            io.grpc.xds.shaded.envoy.api.v2.core.Http2ProtocolOptions.newBuilder(http2ProtocolOptions_).mergeFrom(value).buildPartial();
        } else {
          http2ProtocolOptions_ = value;
        }
        onChanged();
      } else {
        http2ProtocolOptionsBuilder_.mergeFrom(value);
      }

      return this;
    }
    /**
     * <pre>
     * Even if default HTTP2 protocol options are desired, this field must be
     * set so that Envoy will assume that the upstream supports HTTP/2 when
     * making new HTTP connection pool connections. Currently, Envoy only
     * supports prior knowledge for upstream connections. Even if TLS is used
     * with ALPN, `http2_protocol_options` must be specified. As an aside this allows HTTP/2
     * connections to happen over plain text.
     * </pre>
     *
     * <code>.envoy.api.v2.core.Http2ProtocolOptions http2_protocol_options = 14;</code>
     */
    public Builder clearHttp2ProtocolOptions() {
      if (http2ProtocolOptionsBuilder_ == null) {
        http2ProtocolOptions_ = null;
        onChanged();
      } else {
        http2ProtocolOptions_ = null;
        http2ProtocolOptionsBuilder_ = null;
      }

      return this;
    }
    /**
     * <pre>
     * Even if default HTTP2 protocol options are desired, this field must be
     * set so that Envoy will assume that the upstream supports HTTP/2 when
     * making new HTTP connection pool connections. Currently, Envoy only
     * supports prior knowledge for upstream connections. Even if TLS is used
     * with ALPN, `http2_protocol_options` must be specified. As an aside this allows HTTP/2
     * connections to happen over plain text.
     * </pre>
     *
     * <code>.envoy.api.v2.core.Http2ProtocolOptions http2_protocol_options = 14;</code>
     */
    public io.grpc.xds.shaded.envoy.api.v2.core.Http2ProtocolOptions.Builder getHttp2ProtocolOptionsBuilder() {
      
      onChanged();
      return getHttp2ProtocolOptionsFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * Even if default HTTP2 protocol options are desired, this field must be
     * set so that Envoy will assume that the upstream supports HTTP/2 when
     * making new HTTP connection pool connections. Currently, Envoy only
     * supports prior knowledge for upstream connections. Even if TLS is used
     * with ALPN, `http2_protocol_options` must be specified. As an aside this allows HTTP/2
     * connections to happen over plain text.
     * </pre>
     *
     * <code>.envoy.api.v2.core.Http2ProtocolOptions http2_protocol_options = 14;</code>
     */
    public io.grpc.xds.shaded.envoy.api.v2.core.Http2ProtocolOptionsOrBuilder getHttp2ProtocolOptionsOrBuilder() {
      if (http2ProtocolOptionsBuilder_ != null) {
        return http2ProtocolOptionsBuilder_.getMessageOrBuilder();
      } else {
        return http2ProtocolOptions_ == null ?
            io.grpc.xds.shaded.envoy.api.v2.core.Http2ProtocolOptions.getDefaultInstance() : http2ProtocolOptions_;
      }
    }
    /**
     * <pre>
     * Even if default HTTP2 protocol options are desired, this field must be
     * set so that Envoy will assume that the upstream supports HTTP/2 when
     * making new HTTP connection pool connections. Currently, Envoy only
     * supports prior knowledge for upstream connections. Even if TLS is used
     * with ALPN, `http2_protocol_options` must be specified. As an aside this allows HTTP/2
     * connections to happen over plain text.
     * </pre>
     *
     * <code>.envoy.api.v2.core.Http2ProtocolOptions http2_protocol_options = 14;</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        io.grpc.xds.shaded.envoy.api.v2.core.Http2ProtocolOptions, io.grpc.xds.shaded.envoy.api.v2.core.Http2ProtocolOptions.Builder, io.grpc.xds.shaded.envoy.api.v2.core.Http2ProtocolOptionsOrBuilder> 
        getHttp2ProtocolOptionsFieldBuilder() {
      if (http2ProtocolOptionsBuilder_ == null) {
        http2ProtocolOptionsBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            io.grpc.xds.shaded.envoy.api.v2.core.Http2ProtocolOptions, io.grpc.xds.shaded.envoy.api.v2.core.Http2ProtocolOptions.Builder, io.grpc.xds.shaded.envoy.api.v2.core.Http2ProtocolOptionsOrBuilder>(
                getHttp2ProtocolOptions(),
                getParentForChildren(),
                isClean());
        http2ProtocolOptions_ = null;
      }
      return http2ProtocolOptionsBuilder_;
    }

    private com.google.protobuf.MapField<
        java.lang.String, com.google.protobuf.Struct> extensionProtocolOptions_;
    private com.google.protobuf.MapField<java.lang.String, com.google.protobuf.Struct>
    internalGetExtensionProtocolOptions() {
      if (extensionProtocolOptions_ == null) {
        return com.google.protobuf.MapField.emptyMapField(
            ExtensionProtocolOptionsDefaultEntryHolder.defaultEntry);
      }
      return extensionProtocolOptions_;
    }
    private com.google.protobuf.MapField<java.lang.String, com.google.protobuf.Struct>
    internalGetMutableExtensionProtocolOptions() {
      onChanged();;
      if (extensionProtocolOptions_ == null) {
        extensionProtocolOptions_ = com.google.protobuf.MapField.newMapField(
            ExtensionProtocolOptionsDefaultEntryHolder.defaultEntry);
      }
      if (!extensionProtocolOptions_.isMutable()) {
        extensionProtocolOptions_ = extensionProtocolOptions_.copy();
      }
      return extensionProtocolOptions_;
    }

    public int getExtensionProtocolOptionsCount() {
      return internalGetExtensionProtocolOptions().getMap().size();
    }
    /**
     * <pre>
     * The extension_protocol_options field is used to provide extension-specific protocol options
     * for upstream connections. The key should match the extension filter name, such as
     * "envoy.filters.network.thrift_proxy". See the extension's documentation for details on
     * specific options.
     * </pre>
     *
     * <code>map&lt;string, .google.protobuf.Struct&gt; extension_protocol_options = 35;</code>
     */

    public boolean containsExtensionProtocolOptions(
        java.lang.String key) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      return internalGetExtensionProtocolOptions().getMap().containsKey(key);
    }
    /**
     * Use {@link #getExtensionProtocolOptionsMap()} instead.
     */
    @java.lang.Deprecated
    public java.util.Map<java.lang.String, com.google.protobuf.Struct> getExtensionProtocolOptions() {
      return getExtensionProtocolOptionsMap();
    }
    /**
     * <pre>
     * The extension_protocol_options field is used to provide extension-specific protocol options
     * for upstream connections. The key should match the extension filter name, such as
     * "envoy.filters.network.thrift_proxy". See the extension's documentation for details on
     * specific options.
     * </pre>
     *
     * <code>map&lt;string, .google.protobuf.Struct&gt; extension_protocol_options = 35;</code>
     */

    public java.util.Map<java.lang.String, com.google.protobuf.Struct> getExtensionProtocolOptionsMap() {
      return internalGetExtensionProtocolOptions().getMap();
    }
    /**
     * <pre>
     * The extension_protocol_options field is used to provide extension-specific protocol options
     * for upstream connections. The key should match the extension filter name, such as
     * "envoy.filters.network.thrift_proxy". See the extension's documentation for details on
     * specific options.
     * </pre>
     *
     * <code>map&lt;string, .google.protobuf.Struct&gt; extension_protocol_options = 35;</code>
     */

    public com.google.protobuf.Struct getExtensionProtocolOptionsOrDefault(
        java.lang.String key,
        com.google.protobuf.Struct defaultValue) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      java.util.Map<java.lang.String, com.google.protobuf.Struct> map =
          internalGetExtensionProtocolOptions().getMap();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }
    /**
     * <pre>
     * The extension_protocol_options field is used to provide extension-specific protocol options
     * for upstream connections. The key should match the extension filter name, such as
     * "envoy.filters.network.thrift_proxy". See the extension's documentation for details on
     * specific options.
     * </pre>
     *
     * <code>map&lt;string, .google.protobuf.Struct&gt; extension_protocol_options = 35;</code>
     */

    public com.google.protobuf.Struct getExtensionProtocolOptionsOrThrow(
        java.lang.String key) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      java.util.Map<java.lang.String, com.google.protobuf.Struct> map =
          internalGetExtensionProtocolOptions().getMap();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return map.get(key);
    }

    public Builder clearExtensionProtocolOptions() {
      internalGetMutableExtensionProtocolOptions().getMutableMap()
          .clear();
      return this;
    }
    /**
     * <pre>
     * The extension_protocol_options field is used to provide extension-specific protocol options
     * for upstream connections. The key should match the extension filter name, such as
     * "envoy.filters.network.thrift_proxy". See the extension's documentation for details on
     * specific options.
     * </pre>
     *
     * <code>map&lt;string, .google.protobuf.Struct&gt; extension_protocol_options = 35;</code>
     */

    public Builder removeExtensionProtocolOptions(
        java.lang.String key) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      internalGetMutableExtensionProtocolOptions().getMutableMap()
          .remove(key);
      return this;
    }
    /**
     * Use alternate mutation accessors instead.
     */
    @java.lang.Deprecated
    public java.util.Map<java.lang.String, com.google.protobuf.Struct>
    getMutableExtensionProtocolOptions() {
      return internalGetMutableExtensionProtocolOptions().getMutableMap();
    }
    /**
     * <pre>
     * The extension_protocol_options field is used to provide extension-specific protocol options
     * for upstream connections. The key should match the extension filter name, such as
     * "envoy.filters.network.thrift_proxy". See the extension's documentation for details on
     * specific options.
     * </pre>
     *
     * <code>map&lt;string, .google.protobuf.Struct&gt; extension_protocol_options = 35;</code>
     */
    public Builder putExtensionProtocolOptions(
        java.lang.String key,
        com.google.protobuf.Struct value) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      if (value == null) { throw new java.lang.NullPointerException(); }
      internalGetMutableExtensionProtocolOptions().getMutableMap()
          .put(key, value);
      return this;
    }
    /**
     * <pre>
     * The extension_protocol_options field is used to provide extension-specific protocol options
     * for upstream connections. The key should match the extension filter name, such as
     * "envoy.filters.network.thrift_proxy". See the extension's documentation for details on
     * specific options.
     * </pre>
     *
     * <code>map&lt;string, .google.protobuf.Struct&gt; extension_protocol_options = 35;</code>
     */

    public Builder putAllExtensionProtocolOptions(
        java.util.Map<java.lang.String, com.google.protobuf.Struct> values) {
      internalGetMutableExtensionProtocolOptions().getMutableMap()
          .putAll(values);
      return this;
    }

    private com.google.protobuf.MapField<
        java.lang.String, com.google.protobuf.Any> typedExtensionProtocolOptions_;
    private com.google.protobuf.MapField<java.lang.String, com.google.protobuf.Any>
    internalGetTypedExtensionProtocolOptions() {
      if (typedExtensionProtocolOptions_ == null) {
        return com.google.protobuf.MapField.emptyMapField(
            TypedExtensionProtocolOptionsDefaultEntryHolder.defaultEntry);
      }
      return typedExtensionProtocolOptions_;
    }
    private com.google.protobuf.MapField<java.lang.String, com.google.protobuf.Any>
    internalGetMutableTypedExtensionProtocolOptions() {
      onChanged();;
      if (typedExtensionProtocolOptions_ == null) {
        typedExtensionProtocolOptions_ = com.google.protobuf.MapField.newMapField(
            TypedExtensionProtocolOptionsDefaultEntryHolder.defaultEntry);
      }
      if (!typedExtensionProtocolOptions_.isMutable()) {
        typedExtensionProtocolOptions_ = typedExtensionProtocolOptions_.copy();
      }
      return typedExtensionProtocolOptions_;
    }

    public int getTypedExtensionProtocolOptionsCount() {
      return internalGetTypedExtensionProtocolOptions().getMap().size();
    }
    /**
     * <pre>
     * [#not-implemented-hide:]
     * The extension_protocol_options field is used to provide extension-specific protocol options
     * for upstream connections. The key should match the extension filter name, such as
     * "envoy.filters.network.thrift_proxy". See the extension's documentation for details on
     * specific options.
     * </pre>
     *
     * <code>map&lt;string, .google.protobuf.Any&gt; typed_extension_protocol_options = 36;</code>
     */

    public boolean containsTypedExtensionProtocolOptions(
        java.lang.String key) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      return internalGetTypedExtensionProtocolOptions().getMap().containsKey(key);
    }
    /**
     * Use {@link #getTypedExtensionProtocolOptionsMap()} instead.
     */
    @java.lang.Deprecated
    public java.util.Map<java.lang.String, com.google.protobuf.Any> getTypedExtensionProtocolOptions() {
      return getTypedExtensionProtocolOptionsMap();
    }
    /**
     * <pre>
     * [#not-implemented-hide:]
     * The extension_protocol_options field is used to provide extension-specific protocol options
     * for upstream connections. The key should match the extension filter name, such as
     * "envoy.filters.network.thrift_proxy". See the extension's documentation for details on
     * specific options.
     * </pre>
     *
     * <code>map&lt;string, .google.protobuf.Any&gt; typed_extension_protocol_options = 36;</code>
     */

    public java.util.Map<java.lang.String, com.google.protobuf.Any> getTypedExtensionProtocolOptionsMap() {
      return internalGetTypedExtensionProtocolOptions().getMap();
    }
    /**
     * <pre>
     * [#not-implemented-hide:]
     * The extension_protocol_options field is used to provide extension-specific protocol options
     * for upstream connections. The key should match the extension filter name, such as
     * "envoy.filters.network.thrift_proxy". See the extension's documentation for details on
     * specific options.
     * </pre>
     *
     * <code>map&lt;string, .google.protobuf.Any&gt; typed_extension_protocol_options = 36;</code>
     */

    public com.google.protobuf.Any getTypedExtensionProtocolOptionsOrDefault(
        java.lang.String key,
        com.google.protobuf.Any defaultValue) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      java.util.Map<java.lang.String, com.google.protobuf.Any> map =
          internalGetTypedExtensionProtocolOptions().getMap();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }
    /**
     * <pre>
     * [#not-implemented-hide:]
     * The extension_protocol_options field is used to provide extension-specific protocol options
     * for upstream connections. The key should match the extension filter name, such as
     * "envoy.filters.network.thrift_proxy". See the extension's documentation for details on
     * specific options.
     * </pre>
     *
     * <code>map&lt;string, .google.protobuf.Any&gt; typed_extension_protocol_options = 36;</code>
     */

    public com.google.protobuf.Any getTypedExtensionProtocolOptionsOrThrow(
        java.lang.String key) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      java.util.Map<java.lang.String, com.google.protobuf.Any> map =
          internalGetTypedExtensionProtocolOptions().getMap();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return map.get(key);
    }

    public Builder clearTypedExtensionProtocolOptions() {
      internalGetMutableTypedExtensionProtocolOptions().getMutableMap()
          .clear();
      return this;
    }
    /**
     * <pre>
     * [#not-implemented-hide:]
     * The extension_protocol_options field is used to provide extension-specific protocol options
     * for upstream connections. The key should match the extension filter name, such as
     * "envoy.filters.network.thrift_proxy". See the extension's documentation for details on
     * specific options.
     * </pre>
     *
     * <code>map&lt;string, .google.protobuf.Any&gt; typed_extension_protocol_options = 36;</code>
     */

    public Builder removeTypedExtensionProtocolOptions(
        java.lang.String key) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      internalGetMutableTypedExtensionProtocolOptions().getMutableMap()
          .remove(key);
      return this;
    }
    /**
     * Use alternate mutation accessors instead.
     */
    @java.lang.Deprecated
    public java.util.Map<java.lang.String, com.google.protobuf.Any>
    getMutableTypedExtensionProtocolOptions() {
      return internalGetMutableTypedExtensionProtocolOptions().getMutableMap();
    }
    /**
     * <pre>
     * [#not-implemented-hide:]
     * The extension_protocol_options field is used to provide extension-specific protocol options
     * for upstream connections. The key should match the extension filter name, such as
     * "envoy.filters.network.thrift_proxy". See the extension's documentation for details on
     * specific options.
     * </pre>
     *
     * <code>map&lt;string, .google.protobuf.Any&gt; typed_extension_protocol_options = 36;</code>
     */
    public Builder putTypedExtensionProtocolOptions(
        java.lang.String key,
        com.google.protobuf.Any value) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      if (value == null) { throw new java.lang.NullPointerException(); }
      internalGetMutableTypedExtensionProtocolOptions().getMutableMap()
          .put(key, value);
      return this;
    }
    /**
     * <pre>
     * [#not-implemented-hide:]
     * The extension_protocol_options field is used to provide extension-specific protocol options
     * for upstream connections. The key should match the extension filter name, such as
     * "envoy.filters.network.thrift_proxy". See the extension's documentation for details on
     * specific options.
     * </pre>
     *
     * <code>map&lt;string, .google.protobuf.Any&gt; typed_extension_protocol_options = 36;</code>
     */

    public Builder putAllTypedExtensionProtocolOptions(
        java.util.Map<java.lang.String, com.google.protobuf.Any> values) {
      internalGetMutableTypedExtensionProtocolOptions().getMutableMap()
          .putAll(values);
      return this;
    }

    private com.google.protobuf.Duration dnsRefreshRate_ = null;
    private com.google.protobuf.SingleFieldBuilderV3<
        com.google.protobuf.Duration, com.google.protobuf.Duration.Builder, com.google.protobuf.DurationOrBuilder> dnsRefreshRateBuilder_;
    /**
     * <pre>
     * If the DNS refresh rate is specified and the cluster type is either
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS&gt;`,
     * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS&gt;`,
     * this value is used as the clusters DNS refresh
     * rate. If this setting is not specified, the value defaults to 5000ms. For
     * cluster types other than
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS&gt;`
     * and :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS&gt;`
     * this setting is ignored.
     * </pre>
     *
     * <code>.google.protobuf.Duration dns_refresh_rate = 16 [(.validate.rules) = { ... }</code>
     */
    public boolean hasDnsRefreshRate() {
      return dnsRefreshRateBuilder_ != null || dnsRefreshRate_ != null;
    }
    /**
     * <pre>
     * If the DNS refresh rate is specified and the cluster type is either
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS&gt;`,
     * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS&gt;`,
     * this value is used as the clusters DNS refresh
     * rate. If this setting is not specified, the value defaults to 5000ms. For
     * cluster types other than
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS&gt;`
     * and :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS&gt;`
     * this setting is ignored.
     * </pre>
     *
     * <code>.google.protobuf.Duration dns_refresh_rate = 16 [(.validate.rules) = { ... }</code>
     */
    public com.google.protobuf.Duration getDnsRefreshRate() {
      if (dnsRefreshRateBuilder_ == null) {
        return dnsRefreshRate_ == null ? com.google.protobuf.Duration.getDefaultInstance() : dnsRefreshRate_;
      } else {
        return dnsRefreshRateBuilder_.getMessage();
      }
    }
    /**
     * <pre>
     * If the DNS refresh rate is specified and the cluster type is either
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS&gt;`,
     * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS&gt;`,
     * this value is used as the clusters DNS refresh
     * rate. If this setting is not specified, the value defaults to 5000ms. For
     * cluster types other than
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS&gt;`
     * and :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS&gt;`
     * this setting is ignored.
     * </pre>
     *
     * <code>.google.protobuf.Duration dns_refresh_rate = 16 [(.validate.rules) = { ... }</code>
     */
    public Builder setDnsRefreshRate(com.google.protobuf.Duration value) {
      if (dnsRefreshRateBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        dnsRefreshRate_ = value;
        onChanged();
      } else {
        dnsRefreshRateBuilder_.setMessage(value);
      }

      return this;
    }
    /**
     * <pre>
     * If the DNS refresh rate is specified and the cluster type is either
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS&gt;`,
     * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS&gt;`,
     * this value is used as the clusters DNS refresh
     * rate. If this setting is not specified, the value defaults to 5000ms. For
     * cluster types other than
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS&gt;`
     * and :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS&gt;`
     * this setting is ignored.
     * </pre>
     *
     * <code>.google.protobuf.Duration dns_refresh_rate = 16 [(.validate.rules) = { ... }</code>
     */
    public Builder setDnsRefreshRate(
        com.google.protobuf.Duration.Builder builderForValue) {
      if (dnsRefreshRateBuilder_ == null) {
        dnsRefreshRate_ = builderForValue.build();
        onChanged();
      } else {
        dnsRefreshRateBuilder_.setMessage(builderForValue.build());
      }

      return this;
    }
    /**
     * <pre>
     * If the DNS refresh rate is specified and the cluster type is either
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS&gt;`,
     * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS&gt;`,
     * this value is used as the clusters DNS refresh
     * rate. If this setting is not specified, the value defaults to 5000ms. For
     * cluster types other than
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS&gt;`
     * and :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS&gt;`
     * this setting is ignored.
     * </pre>
     *
     * <code>.google.protobuf.Duration dns_refresh_rate = 16 [(.validate.rules) = { ... }</code>
     */
    public Builder mergeDnsRefreshRate(com.google.protobuf.Duration value) {
      if (dnsRefreshRateBuilder_ == null) {
        if (dnsRefreshRate_ != null) {
          dnsRefreshRate_ =
            com.google.protobuf.Duration.newBuilder(dnsRefreshRate_).mergeFrom(value).buildPartial();
        } else {
          dnsRefreshRate_ = value;
        }
        onChanged();
      } else {
        dnsRefreshRateBuilder_.mergeFrom(value);
      }

      return this;
    }
    /**
     * <pre>
     * If the DNS refresh rate is specified and the cluster type is either
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS&gt;`,
     * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS&gt;`,
     * this value is used as the clusters DNS refresh
     * rate. If this setting is not specified, the value defaults to 5000ms. For
     * cluster types other than
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS&gt;`
     * and :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS&gt;`
     * this setting is ignored.
     * </pre>
     *
     * <code>.google.protobuf.Duration dns_refresh_rate = 16 [(.validate.rules) = { ... }</code>
     */
    public Builder clearDnsRefreshRate() {
      if (dnsRefreshRateBuilder_ == null) {
        dnsRefreshRate_ = null;
        onChanged();
      } else {
        dnsRefreshRate_ = null;
        dnsRefreshRateBuilder_ = null;
      }

      return this;
    }
    /**
     * <pre>
     * If the DNS refresh rate is specified and the cluster type is either
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS&gt;`,
     * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS&gt;`,
     * this value is used as the clusters DNS refresh
     * rate. If this setting is not specified, the value defaults to 5000ms. For
     * cluster types other than
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS&gt;`
     * and :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS&gt;`
     * this setting is ignored.
     * </pre>
     *
     * <code>.google.protobuf.Duration dns_refresh_rate = 16 [(.validate.rules) = { ... }</code>
     */
    public com.google.protobuf.Duration.Builder getDnsRefreshRateBuilder() {
      
      onChanged();
      return getDnsRefreshRateFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * If the DNS refresh rate is specified and the cluster type is either
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS&gt;`,
     * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS&gt;`,
     * this value is used as the clusters DNS refresh
     * rate. If this setting is not specified, the value defaults to 5000ms. For
     * cluster types other than
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS&gt;`
     * and :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS&gt;`
     * this setting is ignored.
     * </pre>
     *
     * <code>.google.protobuf.Duration dns_refresh_rate = 16 [(.validate.rules) = { ... }</code>
     */
    public com.google.protobuf.DurationOrBuilder getDnsRefreshRateOrBuilder() {
      if (dnsRefreshRateBuilder_ != null) {
        return dnsRefreshRateBuilder_.getMessageOrBuilder();
      } else {
        return dnsRefreshRate_ == null ?
            com.google.protobuf.Duration.getDefaultInstance() : dnsRefreshRate_;
      }
    }
    /**
     * <pre>
     * If the DNS refresh rate is specified and the cluster type is either
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS&gt;`,
     * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS&gt;`,
     * this value is used as the clusters DNS refresh
     * rate. If this setting is not specified, the value defaults to 5000ms. For
     * cluster types other than
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS&gt;`
     * and :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS&gt;`
     * this setting is ignored.
     * </pre>
     *
     * <code>.google.protobuf.Duration dns_refresh_rate = 16 [(.validate.rules) = { ... }</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        com.google.protobuf.Duration, com.google.protobuf.Duration.Builder, com.google.protobuf.DurationOrBuilder> 
        getDnsRefreshRateFieldBuilder() {
      if (dnsRefreshRateBuilder_ == null) {
        dnsRefreshRateBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            com.google.protobuf.Duration, com.google.protobuf.Duration.Builder, com.google.protobuf.DurationOrBuilder>(
                getDnsRefreshRate(),
                getParentForChildren(),
                isClean());
        dnsRefreshRate_ = null;
      }
      return dnsRefreshRateBuilder_;
    }

    private int dnsLookupFamily_ = 0;
    /**
     * <pre>
     * The DNS IP address resolution policy. If this setting is not specified, the
     * value defaults to
     * :ref:`AUTO&lt;envoy_api_enum_value_Cluster.DnsLookupFamily.AUTO&gt;`.
     * </pre>
     *
     * <code>.envoy.api.v2.Cluster.DnsLookupFamily dns_lookup_family = 17 [(.validate.rules) = { ... }</code>
     */
    public int getDnsLookupFamilyValue() {
      return dnsLookupFamily_;
    }
    /**
     * <pre>
     * The DNS IP address resolution policy. If this setting is not specified, the
     * value defaults to
     * :ref:`AUTO&lt;envoy_api_enum_value_Cluster.DnsLookupFamily.AUTO&gt;`.
     * </pre>
     *
     * <code>.envoy.api.v2.Cluster.DnsLookupFamily dns_lookup_family = 17 [(.validate.rules) = { ... }</code>
     */
    public Builder setDnsLookupFamilyValue(int value) {
      dnsLookupFamily_ = value;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * The DNS IP address resolution policy. If this setting is not specified, the
     * value defaults to
     * :ref:`AUTO&lt;envoy_api_enum_value_Cluster.DnsLookupFamily.AUTO&gt;`.
     * </pre>
     *
     * <code>.envoy.api.v2.Cluster.DnsLookupFamily dns_lookup_family = 17 [(.validate.rules) = { ... }</code>
     */
    public io.grpc.xds.shaded.envoy.api.v2.Cluster.DnsLookupFamily getDnsLookupFamily() {
      io.grpc.xds.shaded.envoy.api.v2.Cluster.DnsLookupFamily result = io.grpc.xds.shaded.envoy.api.v2.Cluster.DnsLookupFamily.valueOf(dnsLookupFamily_);
      return result == null ? io.grpc.xds.shaded.envoy.api.v2.Cluster.DnsLookupFamily.UNRECOGNIZED : result;
    }
    /**
     * <pre>
     * The DNS IP address resolution policy. If this setting is not specified, the
     * value defaults to
     * :ref:`AUTO&lt;envoy_api_enum_value_Cluster.DnsLookupFamily.AUTO&gt;`.
     * </pre>
     *
     * <code>.envoy.api.v2.Cluster.DnsLookupFamily dns_lookup_family = 17 [(.validate.rules) = { ... }</code>
     */
    public Builder setDnsLookupFamily(io.grpc.xds.shaded.envoy.api.v2.Cluster.DnsLookupFamily value) {
      if (value == null) {
        throw new NullPointerException();
      }
      
      dnsLookupFamily_ = value.getNumber();
      onChanged();
      return this;
    }
    /**
     * <pre>
     * The DNS IP address resolution policy. If this setting is not specified, the
     * value defaults to
     * :ref:`AUTO&lt;envoy_api_enum_value_Cluster.DnsLookupFamily.AUTO&gt;`.
     * </pre>
     *
     * <code>.envoy.api.v2.Cluster.DnsLookupFamily dns_lookup_family = 17 [(.validate.rules) = { ... }</code>
     */
    public Builder clearDnsLookupFamily() {
      
      dnsLookupFamily_ = 0;
      onChanged();
      return this;
    }

    private java.util.List<io.grpc.xds.shaded.envoy.api.v2.core.Address> dnsResolvers_ =
      java.util.Collections.emptyList();
    private void ensureDnsResolversIsMutable() {
      if (!((bitField0_ & 0x00100000) == 0x00100000)) {
        dnsResolvers_ = new java.util.ArrayList<io.grpc.xds.shaded.envoy.api.v2.core.Address>(dnsResolvers_);
        bitField0_ |= 0x00100000;
       }
    }

    private com.google.protobuf.RepeatedFieldBuilderV3<
        io.grpc.xds.shaded.envoy.api.v2.core.Address, io.grpc.xds.shaded.envoy.api.v2.core.Address.Builder, io.grpc.xds.shaded.envoy.api.v2.core.AddressOrBuilder> dnsResolversBuilder_;

    /**
     * <pre>
     * If DNS resolvers are specified and the cluster type is either
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS&gt;`,
     * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS&gt;`,
     * this value is used to specify the clusters dns resolvers.
     * If this setting is not specified, the value defaults to the default
     * resolver, which uses /etc/resolv.conf for configuration. For cluster types
     * other than
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS&gt;`
     * and :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS&gt;`
     * this setting is ignored.
     * </pre>
     *
     * <code>repeated .envoy.api.v2.core.Address dns_resolvers = 18;</code>
     */
    public java.util.List<io.grpc.xds.shaded.envoy.api.v2.core.Address> getDnsResolversList() {
      if (dnsResolversBuilder_ == null) {
        return java.util.Collections.unmodifiableList(dnsResolvers_);
      } else {
        return dnsResolversBuilder_.getMessageList();
      }
    }
    /**
     * <pre>
     * If DNS resolvers are specified and the cluster type is either
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS&gt;`,
     * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS&gt;`,
     * this value is used to specify the clusters dns resolvers.
     * If this setting is not specified, the value defaults to the default
     * resolver, which uses /etc/resolv.conf for configuration. For cluster types
     * other than
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS&gt;`
     * and :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS&gt;`
     * this setting is ignored.
     * </pre>
     *
     * <code>repeated .envoy.api.v2.core.Address dns_resolvers = 18;</code>
     */
    public int getDnsResolversCount() {
      if (dnsResolversBuilder_ == null) {
        return dnsResolvers_.size();
      } else {
        return dnsResolversBuilder_.getCount();
      }
    }
    /**
     * <pre>
     * If DNS resolvers are specified and the cluster type is either
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS&gt;`,
     * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS&gt;`,
     * this value is used to specify the clusters dns resolvers.
     * If this setting is not specified, the value defaults to the default
     * resolver, which uses /etc/resolv.conf for configuration. For cluster types
     * other than
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS&gt;`
     * and :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS&gt;`
     * this setting is ignored.
     * </pre>
     *
     * <code>repeated .envoy.api.v2.core.Address dns_resolvers = 18;</code>
     */
    public io.grpc.xds.shaded.envoy.api.v2.core.Address getDnsResolvers(int index) {
      if (dnsResolversBuilder_ == null) {
        return dnsResolvers_.get(index);
      } else {
        return dnsResolversBuilder_.getMessage(index);
      }
    }
    /**
     * <pre>
     * If DNS resolvers are specified and the cluster type is either
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS&gt;`,
     * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS&gt;`,
     * this value is used to specify the clusters dns resolvers.
     * If this setting is not specified, the value defaults to the default
     * resolver, which uses /etc/resolv.conf for configuration. For cluster types
     * other than
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS&gt;`
     * and :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS&gt;`
     * this setting is ignored.
     * </pre>
     *
     * <code>repeated .envoy.api.v2.core.Address dns_resolvers = 18;</code>
     */
    public Builder setDnsResolvers(
        int index, io.grpc.xds.shaded.envoy.api.v2.core.Address value) {
      if (dnsResolversBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureDnsResolversIsMutable();
        dnsResolvers_.set(index, value);
        onChanged();
      } else {
        dnsResolversBuilder_.setMessage(index, value);
      }
      return this;
    }
    /**
     * <pre>
     * If DNS resolvers are specified and the cluster type is either
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS&gt;`,
     * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS&gt;`,
     * this value is used to specify the clusters dns resolvers.
     * If this setting is not specified, the value defaults to the default
     * resolver, which uses /etc/resolv.conf for configuration. For cluster types
     * other than
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS&gt;`
     * and :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS&gt;`
     * this setting is ignored.
     * </pre>
     *
     * <code>repeated .envoy.api.v2.core.Address dns_resolvers = 18;</code>
     */
    public Builder setDnsResolvers(
        int index, io.grpc.xds.shaded.envoy.api.v2.core.Address.Builder builderForValue) {
      if (dnsResolversBuilder_ == null) {
        ensureDnsResolversIsMutable();
        dnsResolvers_.set(index, builderForValue.build());
        onChanged();
      } else {
        dnsResolversBuilder_.setMessage(index, builderForValue.build());
      }
      return this;
    }
    /**
     * <pre>
     * If DNS resolvers are specified and the cluster type is either
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS&gt;`,
     * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS&gt;`,
     * this value is used to specify the clusters dns resolvers.
     * If this setting is not specified, the value defaults to the default
     * resolver, which uses /etc/resolv.conf for configuration. For cluster types
     * other than
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS&gt;`
     * and :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS&gt;`
     * this setting is ignored.
     * </pre>
     *
     * <code>repeated .envoy.api.v2.core.Address dns_resolvers = 18;</code>
     */
    public Builder addDnsResolvers(io.grpc.xds.shaded.envoy.api.v2.core.Address value) {
      if (dnsResolversBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureDnsResolversIsMutable();
        dnsResolvers_.add(value);
        onChanged();
      } else {
        dnsResolversBuilder_.addMessage(value);
      }
      return this;
    }
    /**
     * <pre>
     * If DNS resolvers are specified and the cluster type is either
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS&gt;`,
     * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS&gt;`,
     * this value is used to specify the clusters dns resolvers.
     * If this setting is not specified, the value defaults to the default
     * resolver, which uses /etc/resolv.conf for configuration. For cluster types
     * other than
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS&gt;`
     * and :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS&gt;`
     * this setting is ignored.
     * </pre>
     *
     * <code>repeated .envoy.api.v2.core.Address dns_resolvers = 18;</code>
     */
    public Builder addDnsResolvers(
        int index, io.grpc.xds.shaded.envoy.api.v2.core.Address value) {
      if (dnsResolversBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureDnsResolversIsMutable();
        dnsResolvers_.add(index, value);
        onChanged();
      } else {
        dnsResolversBuilder_.addMessage(index, value);
      }
      return this;
    }
    /**
     * <pre>
     * If DNS resolvers are specified and the cluster type is either
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS&gt;`,
     * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS&gt;`,
     * this value is used to specify the clusters dns resolvers.
     * If this setting is not specified, the value defaults to the default
     * resolver, which uses /etc/resolv.conf for configuration. For cluster types
     * other than
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS&gt;`
     * and :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS&gt;`
     * this setting is ignored.
     * </pre>
     *
     * <code>repeated .envoy.api.v2.core.Address dns_resolvers = 18;</code>
     */
    public Builder addDnsResolvers(
        io.grpc.xds.shaded.envoy.api.v2.core.Address.Builder builderForValue) {
      if (dnsResolversBuilder_ == null) {
        ensureDnsResolversIsMutable();
        dnsResolvers_.add(builderForValue.build());
        onChanged();
      } else {
        dnsResolversBuilder_.addMessage(builderForValue.build());
      }
      return this;
    }
    /**
     * <pre>
     * If DNS resolvers are specified and the cluster type is either
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS&gt;`,
     * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS&gt;`,
     * this value is used to specify the clusters dns resolvers.
     * If this setting is not specified, the value defaults to the default
     * resolver, which uses /etc/resolv.conf for configuration. For cluster types
     * other than
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS&gt;`
     * and :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS&gt;`
     * this setting is ignored.
     * </pre>
     *
     * <code>repeated .envoy.api.v2.core.Address dns_resolvers = 18;</code>
     */
    public Builder addDnsResolvers(
        int index, io.grpc.xds.shaded.envoy.api.v2.core.Address.Builder builderForValue) {
      if (dnsResolversBuilder_ == null) {
        ensureDnsResolversIsMutable();
        dnsResolvers_.add(index, builderForValue.build());
        onChanged();
      } else {
        dnsResolversBuilder_.addMessage(index, builderForValue.build());
      }
      return this;
    }
    /**
     * <pre>
     * If DNS resolvers are specified and the cluster type is either
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS&gt;`,
     * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS&gt;`,
     * this value is used to specify the clusters dns resolvers.
     * If this setting is not specified, the value defaults to the default
     * resolver, which uses /etc/resolv.conf for configuration. For cluster types
     * other than
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS&gt;`
     * and :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS&gt;`
     * this setting is ignored.
     * </pre>
     *
     * <code>repeated .envoy.api.v2.core.Address dns_resolvers = 18;</code>
     */
    public Builder addAllDnsResolvers(
        java.lang.Iterable<? extends io.grpc.xds.shaded.envoy.api.v2.core.Address> values) {
      if (dnsResolversBuilder_ == null) {
        ensureDnsResolversIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, dnsResolvers_);
        onChanged();
      } else {
        dnsResolversBuilder_.addAllMessages(values);
      }
      return this;
    }
    /**
     * <pre>
     * If DNS resolvers are specified and the cluster type is either
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS&gt;`,
     * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS&gt;`,
     * this value is used to specify the clusters dns resolvers.
     * If this setting is not specified, the value defaults to the default
     * resolver, which uses /etc/resolv.conf for configuration. For cluster types
     * other than
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS&gt;`
     * and :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS&gt;`
     * this setting is ignored.
     * </pre>
     *
     * <code>repeated .envoy.api.v2.core.Address dns_resolvers = 18;</code>
     */
    public Builder clearDnsResolvers() {
      if (dnsResolversBuilder_ == null) {
        dnsResolvers_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x00100000);
        onChanged();
      } else {
        dnsResolversBuilder_.clear();
      }
      return this;
    }
    /**
     * <pre>
     * If DNS resolvers are specified and the cluster type is either
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS&gt;`,
     * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS&gt;`,
     * this value is used to specify the clusters dns resolvers.
     * If this setting is not specified, the value defaults to the default
     * resolver, which uses /etc/resolv.conf for configuration. For cluster types
     * other than
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS&gt;`
     * and :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS&gt;`
     * this setting is ignored.
     * </pre>
     *
     * <code>repeated .envoy.api.v2.core.Address dns_resolvers = 18;</code>
     */
    public Builder removeDnsResolvers(int index) {
      if (dnsResolversBuilder_ == null) {
        ensureDnsResolversIsMutable();
        dnsResolvers_.remove(index);
        onChanged();
      } else {
        dnsResolversBuilder_.remove(index);
      }
      return this;
    }
    /**
     * <pre>
     * If DNS resolvers are specified and the cluster type is either
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS&gt;`,
     * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS&gt;`,
     * this value is used to specify the clusters dns resolvers.
     * If this setting is not specified, the value defaults to the default
     * resolver, which uses /etc/resolv.conf for configuration. For cluster types
     * other than
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS&gt;`
     * and :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS&gt;`
     * this setting is ignored.
     * </pre>
     *
     * <code>repeated .envoy.api.v2.core.Address dns_resolvers = 18;</code>
     */
    public io.grpc.xds.shaded.envoy.api.v2.core.Address.Builder getDnsResolversBuilder(
        int index) {
      return getDnsResolversFieldBuilder().getBuilder(index);
    }
    /**
     * <pre>
     * If DNS resolvers are specified and the cluster type is either
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS&gt;`,
     * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS&gt;`,
     * this value is used to specify the clusters dns resolvers.
     * If this setting is not specified, the value defaults to the default
     * resolver, which uses /etc/resolv.conf for configuration. For cluster types
     * other than
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS&gt;`
     * and :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS&gt;`
     * this setting is ignored.
     * </pre>
     *
     * <code>repeated .envoy.api.v2.core.Address dns_resolvers = 18;</code>
     */
    public io.grpc.xds.shaded.envoy.api.v2.core.AddressOrBuilder getDnsResolversOrBuilder(
        int index) {
      if (dnsResolversBuilder_ == null) {
        return dnsResolvers_.get(index);  } else {
        return dnsResolversBuilder_.getMessageOrBuilder(index);
      }
    }
    /**
     * <pre>
     * If DNS resolvers are specified and the cluster type is either
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS&gt;`,
     * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS&gt;`,
     * this value is used to specify the clusters dns resolvers.
     * If this setting is not specified, the value defaults to the default
     * resolver, which uses /etc/resolv.conf for configuration. For cluster types
     * other than
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS&gt;`
     * and :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS&gt;`
     * this setting is ignored.
     * </pre>
     *
     * <code>repeated .envoy.api.v2.core.Address dns_resolvers = 18;</code>
     */
    public java.util.List<? extends io.grpc.xds.shaded.envoy.api.v2.core.AddressOrBuilder> 
         getDnsResolversOrBuilderList() {
      if (dnsResolversBuilder_ != null) {
        return dnsResolversBuilder_.getMessageOrBuilderList();
      } else {
        return java.util.Collections.unmodifiableList(dnsResolvers_);
      }
    }
    /**
     * <pre>
     * If DNS resolvers are specified and the cluster type is either
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS&gt;`,
     * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS&gt;`,
     * this value is used to specify the clusters dns resolvers.
     * If this setting is not specified, the value defaults to the default
     * resolver, which uses /etc/resolv.conf for configuration. For cluster types
     * other than
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS&gt;`
     * and :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS&gt;`
     * this setting is ignored.
     * </pre>
     *
     * <code>repeated .envoy.api.v2.core.Address dns_resolvers = 18;</code>
     */
    public io.grpc.xds.shaded.envoy.api.v2.core.Address.Builder addDnsResolversBuilder() {
      return getDnsResolversFieldBuilder().addBuilder(
          io.grpc.xds.shaded.envoy.api.v2.core.Address.getDefaultInstance());
    }
    /**
     * <pre>
     * If DNS resolvers are specified and the cluster type is either
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS&gt;`,
     * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS&gt;`,
     * this value is used to specify the clusters dns resolvers.
     * If this setting is not specified, the value defaults to the default
     * resolver, which uses /etc/resolv.conf for configuration. For cluster types
     * other than
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS&gt;`
     * and :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS&gt;`
     * this setting is ignored.
     * </pre>
     *
     * <code>repeated .envoy.api.v2.core.Address dns_resolvers = 18;</code>
     */
    public io.grpc.xds.shaded.envoy.api.v2.core.Address.Builder addDnsResolversBuilder(
        int index) {
      return getDnsResolversFieldBuilder().addBuilder(
          index, io.grpc.xds.shaded.envoy.api.v2.core.Address.getDefaultInstance());
    }
    /**
     * <pre>
     * If DNS resolvers are specified and the cluster type is either
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS&gt;`,
     * or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS&gt;`,
     * this value is used to specify the clusters dns resolvers.
     * If this setting is not specified, the value defaults to the default
     * resolver, which uses /etc/resolv.conf for configuration. For cluster types
     * other than
     * :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS&gt;`
     * and :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS&gt;`
     * this setting is ignored.
     * </pre>
     *
     * <code>repeated .envoy.api.v2.core.Address dns_resolvers = 18;</code>
     */
    public java.util.List<io.grpc.xds.shaded.envoy.api.v2.core.Address.Builder> 
         getDnsResolversBuilderList() {
      return getDnsResolversFieldBuilder().getBuilderList();
    }
    private com.google.protobuf.RepeatedFieldBuilderV3<
        io.grpc.xds.shaded.envoy.api.v2.core.Address, io.grpc.xds.shaded.envoy.api.v2.core.Address.Builder, io.grpc.xds.shaded.envoy.api.v2.core.AddressOrBuilder> 
        getDnsResolversFieldBuilder() {
      if (dnsResolversBuilder_ == null) {
        dnsResolversBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
            io.grpc.xds.shaded.envoy.api.v2.core.Address, io.grpc.xds.shaded.envoy.api.v2.core.Address.Builder, io.grpc.xds.shaded.envoy.api.v2.core.AddressOrBuilder>(
                dnsResolvers_,
                ((bitField0_ & 0x00100000) == 0x00100000),
                getParentForChildren(),
                isClean());
        dnsResolvers_ = null;
      }
      return dnsResolversBuilder_;
    }

    private io.grpc.xds.shaded.envoy.api.v2.cluster.OutlierDetection outlierDetection_ = null;
    private com.google.protobuf.SingleFieldBuilderV3<
        io.grpc.xds.shaded.envoy.api.v2.cluster.OutlierDetection, io.grpc.xds.shaded.envoy.api.v2.cluster.OutlierDetection.Builder, io.grpc.xds.shaded.envoy.api.v2.cluster.OutlierDetectionOrBuilder> outlierDetectionBuilder_;
    /**
     * <pre>
     * If specified, outlier detection will be enabled for this upstream cluster.
     * Each of the configuration values can be overridden via
     * :ref:`runtime values &lt;config_cluster_manager_cluster_runtime_outlier_detection&gt;`.
     * </pre>
     *
     * <code>.envoy.api.v2.cluster.OutlierDetection outlier_detection = 19;</code>
     */
    public boolean hasOutlierDetection() {
      return outlierDetectionBuilder_ != null || outlierDetection_ != null;
    }
    /**
     * <pre>
     * If specified, outlier detection will be enabled for this upstream cluster.
     * Each of the configuration values can be overridden via
     * :ref:`runtime values &lt;config_cluster_manager_cluster_runtime_outlier_detection&gt;`.
     * </pre>
     *
     * <code>.envoy.api.v2.cluster.OutlierDetection outlier_detection = 19;</code>
     */
    public io.grpc.xds.shaded.envoy.api.v2.cluster.OutlierDetection getOutlierDetection() {
      if (outlierDetectionBuilder_ == null) {
        return outlierDetection_ == null ? io.grpc.xds.shaded.envoy.api.v2.cluster.OutlierDetection.getDefaultInstance() : outlierDetection_;
      } else {
        return outlierDetectionBuilder_.getMessage();
      }
    }
    /**
     * <pre>
     * If specified, outlier detection will be enabled for this upstream cluster.
     * Each of the configuration values can be overridden via
     * :ref:`runtime values &lt;config_cluster_manager_cluster_runtime_outlier_detection&gt;`.
     * </pre>
     *
     * <code>.envoy.api.v2.cluster.OutlierDetection outlier_detection = 19;</code>
     */
    public Builder setOutlierDetection(io.grpc.xds.shaded.envoy.api.v2.cluster.OutlierDetection value) {
      if (outlierDetectionBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        outlierDetection_ = value;
        onChanged();
      } else {
        outlierDetectionBuilder_.setMessage(value);
      }

      return this;
    }
    /**
     * <pre>
     * If specified, outlier detection will be enabled for this upstream cluster.
     * Each of the configuration values can be overridden via
     * :ref:`runtime values &lt;config_cluster_manager_cluster_runtime_outlier_detection&gt;`.
     * </pre>
     *
     * <code>.envoy.api.v2.cluster.OutlierDetection outlier_detection = 19;</code>
     */
    public Builder setOutlierDetection(
        io.grpc.xds.shaded.envoy.api.v2.cluster.OutlierDetection.Builder builderForValue) {
      if (outlierDetectionBuilder_ == null) {
        outlierDetection_ = builderForValue.build();
        onChanged();
      } else {
        outlierDetectionBuilder_.setMessage(builderForValue.build());
      }

      return this;
    }
    /**
     * <pre>
     * If specified, outlier detection will be enabled for this upstream cluster.
     * Each of the configuration values can be overridden via
     * :ref:`runtime values &lt;config_cluster_manager_cluster_runtime_outlier_detection&gt;`.
     * </pre>
     *
     * <code>.envoy.api.v2.cluster.OutlierDetection outlier_detection = 19;</code>
     */
    public Builder mergeOutlierDetection(io.grpc.xds.shaded.envoy.api.v2.cluster.OutlierDetection value) {
      if (outlierDetectionBuilder_ == null) {
        if (outlierDetection_ != null) {
          outlierDetection_ =
            io.grpc.xds.shaded.envoy.api.v2.cluster.OutlierDetection.newBuilder(outlierDetection_).mergeFrom(value).buildPartial();
        } else {
          outlierDetection_ = value;
        }
        onChanged();
      } else {
        outlierDetectionBuilder_.mergeFrom(value);
      }

      return this;
    }
    /**
     * <pre>
     * If specified, outlier detection will be enabled for this upstream cluster.
     * Each of the configuration values can be overridden via
     * :ref:`runtime values &lt;config_cluster_manager_cluster_runtime_outlier_detection&gt;`.
     * </pre>
     *
     * <code>.envoy.api.v2.cluster.OutlierDetection outlier_detection = 19;</code>
     */
    public Builder clearOutlierDetection() {
      if (outlierDetectionBuilder_ == null) {
        outlierDetection_ = null;
        onChanged();
      } else {
        outlierDetection_ = null;
        outlierDetectionBuilder_ = null;
      }

      return this;
    }
    /**
     * <pre>
     * If specified, outlier detection will be enabled for this upstream cluster.
     * Each of the configuration values can be overridden via
     * :ref:`runtime values &lt;config_cluster_manager_cluster_runtime_outlier_detection&gt;`.
     * </pre>
     *
     * <code>.envoy.api.v2.cluster.OutlierDetection outlier_detection = 19;</code>
     */
    public io.grpc.xds.shaded.envoy.api.v2.cluster.OutlierDetection.Builder getOutlierDetectionBuilder() {
      
      onChanged();
      return getOutlierDetectionFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * If specified, outlier detection will be enabled for this upstream cluster.
     * Each of the configuration values can be overridden via
     * :ref:`runtime values &lt;config_cluster_manager_cluster_runtime_outlier_detection&gt;`.
     * </pre>
     *
     * <code>.envoy.api.v2.cluster.OutlierDetection outlier_detection = 19;</code>
     */
    public io.grpc.xds.shaded.envoy.api.v2.cluster.OutlierDetectionOrBuilder getOutlierDetectionOrBuilder() {
      if (outlierDetectionBuilder_ != null) {
        return outlierDetectionBuilder_.getMessageOrBuilder();
      } else {
        return outlierDetection_ == null ?
            io.grpc.xds.shaded.envoy.api.v2.cluster.OutlierDetection.getDefaultInstance() : outlierDetection_;
      }
    }
    /**
     * <pre>
     * If specified, outlier detection will be enabled for this upstream cluster.
     * Each of the configuration values can be overridden via
     * :ref:`runtime values &lt;config_cluster_manager_cluster_runtime_outlier_detection&gt;`.
     * </pre>
     *
     * <code>.envoy.api.v2.cluster.OutlierDetection outlier_detection = 19;</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        io.grpc.xds.shaded.envoy.api.v2.cluster.OutlierDetection, io.grpc.xds.shaded.envoy.api.v2.cluster.OutlierDetection.Builder, io.grpc.xds.shaded.envoy.api.v2.cluster.OutlierDetectionOrBuilder> 
        getOutlierDetectionFieldBuilder() {
      if (outlierDetectionBuilder_ == null) {
        outlierDetectionBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            io.grpc.xds.shaded.envoy.api.v2.cluster.OutlierDetection, io.grpc.xds.shaded.envoy.api.v2.cluster.OutlierDetection.Builder, io.grpc.xds.shaded.envoy.api.v2.cluster.OutlierDetectionOrBuilder>(
                getOutlierDetection(),
                getParentForChildren(),
                isClean());
        outlierDetection_ = null;
      }
      return outlierDetectionBuilder_;
    }

    private com.google.protobuf.Duration cleanupInterval_ = null;
    private com.google.protobuf.SingleFieldBuilderV3<
        com.google.protobuf.Duration, com.google.protobuf.Duration.Builder, com.google.protobuf.DurationOrBuilder> cleanupIntervalBuilder_;
    /**
     * <pre>
     * The interval for removing stale hosts from a cluster type
     * :ref:`ORIGINAL_DST&lt;envoy_api_enum_value_Cluster.DiscoveryType.ORIGINAL_DST&gt;`.
     * Hosts are considered stale if they have not been used
     * as upstream destinations during this interval. New hosts are added
     * to original destination clusters on demand as new connections are
     * redirected to Envoy, causing the number of hosts in the cluster to
     * grow over time. Hosts that are not stale (they are actively used as
     * destinations) are kept in the cluster, which allows connections to
     * them remain open, saving the latency that would otherwise be spent
     * on opening new connections. If this setting is not specified, the
     * value defaults to 5000ms. For cluster types other than
     * :ref:`ORIGINAL_DST&lt;envoy_api_enum_value_Cluster.DiscoveryType.ORIGINAL_DST&gt;`
     * this setting is ignored.
     * </pre>
     *
     * <code>.google.protobuf.Duration cleanup_interval = 20 [(.validate.rules) = { ... }</code>
     */
    public boolean hasCleanupInterval() {
      return cleanupIntervalBuilder_ != null || cleanupInterval_ != null;
    }
    /**
     * <pre>
     * The interval for removing stale hosts from a cluster type
     * :ref:`ORIGINAL_DST&lt;envoy_api_enum_value_Cluster.DiscoveryType.ORIGINAL_DST&gt;`.
     * Hosts are considered stale if they have not been used
     * as upstream destinations during this interval. New hosts are added
     * to original destination clusters on demand as new connections are
     * redirected to Envoy, causing the number of hosts in the cluster to
     * grow over time. Hosts that are not stale (they are actively used as
     * destinations) are kept in the cluster, which allows connections to
     * them remain open, saving the latency that would otherwise be spent
     * on opening new connections. If this setting is not specified, the
     * value defaults to 5000ms. For cluster types other than
     * :ref:`ORIGINAL_DST&lt;envoy_api_enum_value_Cluster.DiscoveryType.ORIGINAL_DST&gt;`
     * this setting is ignored.
     * </pre>
     *
     * <code>.google.protobuf.Duration cleanup_interval = 20 [(.validate.rules) = { ... }</code>
     */
    public com.google.protobuf.Duration getCleanupInterval() {
      if (cleanupIntervalBuilder_ == null) {
        return cleanupInterval_ == null ? com.google.protobuf.Duration.getDefaultInstance() : cleanupInterval_;
      } else {
        return cleanupIntervalBuilder_.getMessage();
      }
    }
    /**
     * <pre>
     * The interval for removing stale hosts from a cluster type
     * :ref:`ORIGINAL_DST&lt;envoy_api_enum_value_Cluster.DiscoveryType.ORIGINAL_DST&gt;`.
     * Hosts are considered stale if they have not been used
     * as upstream destinations during this interval. New hosts are added
     * to original destination clusters on demand as new connections are
     * redirected to Envoy, causing the number of hosts in the cluster to
     * grow over time. Hosts that are not stale (they are actively used as
     * destinations) are kept in the cluster, which allows connections to
     * them remain open, saving the latency that would otherwise be spent
     * on opening new connections. If this setting is not specified, the
     * value defaults to 5000ms. For cluster types other than
     * :ref:`ORIGINAL_DST&lt;envoy_api_enum_value_Cluster.DiscoveryType.ORIGINAL_DST&gt;`
     * this setting is ignored.
     * </pre>
     *
     * <code>.google.protobuf.Duration cleanup_interval = 20 [(.validate.rules) = { ... }</code>
     */
    public Builder setCleanupInterval(com.google.protobuf.Duration value) {
      if (cleanupIntervalBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        cleanupInterval_ = value;
        onChanged();
      } else {
        cleanupIntervalBuilder_.setMessage(value);
      }

      return this;
    }
    /**
     * <pre>
     * The interval for removing stale hosts from a cluster type
     * :ref:`ORIGINAL_DST&lt;envoy_api_enum_value_Cluster.DiscoveryType.ORIGINAL_DST&gt;`.
     * Hosts are considered stale if they have not been used
     * as upstream destinations during this interval. New hosts are added
     * to original destination clusters on demand as new connections are
     * redirected to Envoy, causing the number of hosts in the cluster to
     * grow over time. Hosts that are not stale (they are actively used as
     * destinations) are kept in the cluster, which allows connections to
     * them remain open, saving the latency that would otherwise be spent
     * on opening new connections. If this setting is not specified, the
     * value defaults to 5000ms. For cluster types other than
     * :ref:`ORIGINAL_DST&lt;envoy_api_enum_value_Cluster.DiscoveryType.ORIGINAL_DST&gt;`
     * this setting is ignored.
     * </pre>
     *
     * <code>.google.protobuf.Duration cleanup_interval = 20 [(.validate.rules) = { ... }</code>
     */
    public Builder setCleanupInterval(
        com.google.protobuf.Duration.Builder builderForValue) {
      if (cleanupIntervalBuilder_ == null) {
        cleanupInterval_ = builderForValue.build();
        onChanged();
      } else {
        cleanupIntervalBuilder_.setMessage(builderForValue.build());
      }

      return this;
    }
    /**
     * <pre>
     * The interval for removing stale hosts from a cluster type
     * :ref:`ORIGINAL_DST&lt;envoy_api_enum_value_Cluster.DiscoveryType.ORIGINAL_DST&gt;`.
     * Hosts are considered stale if they have not been used
     * as upstream destinations during this interval. New hosts are added
     * to original destination clusters on demand as new connections are
     * redirected to Envoy, causing the number of hosts in the cluster to
     * grow over time. Hosts that are not stale (they are actively used as
     * destinations) are kept in the cluster, which allows connections to
     * them remain open, saving the latency that would otherwise be spent
     * on opening new connections. If this setting is not specified, the
     * value defaults to 5000ms. For cluster types other than
     * :ref:`ORIGINAL_DST&lt;envoy_api_enum_value_Cluster.DiscoveryType.ORIGINAL_DST&gt;`
     * this setting is ignored.
     * </pre>
     *
     * <code>.google.protobuf.Duration cleanup_interval = 20 [(.validate.rules) = { ... }</code>
     */
    public Builder mergeCleanupInterval(com.google.protobuf.Duration value) {
      if (cleanupIntervalBuilder_ == null) {
        if (cleanupInterval_ != null) {
          cleanupInterval_ =
            com.google.protobuf.Duration.newBuilder(cleanupInterval_).mergeFrom(value).buildPartial();
        } else {
          cleanupInterval_ = value;
        }
        onChanged();
      } else {
        cleanupIntervalBuilder_.mergeFrom(value);
      }

      return this;
    }
    /**
     * <pre>
     * The interval for removing stale hosts from a cluster type
     * :ref:`ORIGINAL_DST&lt;envoy_api_enum_value_Cluster.DiscoveryType.ORIGINAL_DST&gt;`.
     * Hosts are considered stale if they have not been used
     * as upstream destinations during this interval. New hosts are added
     * to original destination clusters on demand as new connections are
     * redirected to Envoy, causing the number of hosts in the cluster to
     * grow over time. Hosts that are not stale (they are actively used as
     * destinations) are kept in the cluster, which allows connections to
     * them remain open, saving the latency that would otherwise be spent
     * on opening new connections. If this setting is not specified, the
     * value defaults to 5000ms. For cluster types other than
     * :ref:`ORIGINAL_DST&lt;envoy_api_enum_value_Cluster.DiscoveryType.ORIGINAL_DST&gt;`
     * this setting is ignored.
     * </pre>
     *
     * <code>.google.protobuf.Duration cleanup_interval = 20 [(.validate.rules) = { ... }</code>
     */
    public Builder clearCleanupInterval() {
      if (cleanupIntervalBuilder_ == null) {
        cleanupInterval_ = null;
        onChanged();
      } else {
        cleanupInterval_ = null;
        cleanupIntervalBuilder_ = null;
      }

      return this;
    }
    /**
     * <pre>
     * The interval for removing stale hosts from a cluster type
     * :ref:`ORIGINAL_DST&lt;envoy_api_enum_value_Cluster.DiscoveryType.ORIGINAL_DST&gt;`.
     * Hosts are considered stale if they have not been used
     * as upstream destinations during this interval. New hosts are added
     * to original destination clusters on demand as new connections are
     * redirected to Envoy, causing the number of hosts in the cluster to
     * grow over time. Hosts that are not stale (they are actively used as
     * destinations) are kept in the cluster, which allows connections to
     * them remain open, saving the latency that would otherwise be spent
     * on opening new connections. If this setting is not specified, the
     * value defaults to 5000ms. For cluster types other than
     * :ref:`ORIGINAL_DST&lt;envoy_api_enum_value_Cluster.DiscoveryType.ORIGINAL_DST&gt;`
     * this setting is ignored.
     * </pre>
     *
     * <code>.google.protobuf.Duration cleanup_interval = 20 [(.validate.rules) = { ... }</code>
     */
    public com.google.protobuf.Duration.Builder getCleanupIntervalBuilder() {
      
      onChanged();
      return getCleanupIntervalFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * The interval for removing stale hosts from a cluster type
     * :ref:`ORIGINAL_DST&lt;envoy_api_enum_value_Cluster.DiscoveryType.ORIGINAL_DST&gt;`.
     * Hosts are considered stale if they have not been used
     * as upstream destinations during this interval. New hosts are added
     * to original destination clusters on demand as new connections are
     * redirected to Envoy, causing the number of hosts in the cluster to
     * grow over time. Hosts that are not stale (they are actively used as
     * destinations) are kept in the cluster, which allows connections to
     * them remain open, saving the latency that would otherwise be spent
     * on opening new connections. If this setting is not specified, the
     * value defaults to 5000ms. For cluster types other than
     * :ref:`ORIGINAL_DST&lt;envoy_api_enum_value_Cluster.DiscoveryType.ORIGINAL_DST&gt;`
     * this setting is ignored.
     * </pre>
     *
     * <code>.google.protobuf.Duration cleanup_interval = 20 [(.validate.rules) = { ... }</code>
     */
    public com.google.protobuf.DurationOrBuilder getCleanupIntervalOrBuilder() {
      if (cleanupIntervalBuilder_ != null) {
        return cleanupIntervalBuilder_.getMessageOrBuilder();
      } else {
        return cleanupInterval_ == null ?
            com.google.protobuf.Duration.getDefaultInstance() : cleanupInterval_;
      }
    }
    /**
     * <pre>
     * The interval for removing stale hosts from a cluster type
     * :ref:`ORIGINAL_DST&lt;envoy_api_enum_value_Cluster.DiscoveryType.ORIGINAL_DST&gt;`.
     * Hosts are considered stale if they have not been used
     * as upstream destinations during this interval. New hosts are added
     * to original destination clusters on demand as new connections are
     * redirected to Envoy, causing the number of hosts in the cluster to
     * grow over time. Hosts that are not stale (they are actively used as
     * destinations) are kept in the cluster, which allows connections to
     * them remain open, saving the latency that would otherwise be spent
     * on opening new connections. If this setting is not specified, the
     * value defaults to 5000ms. For cluster types other than
     * :ref:`ORIGINAL_DST&lt;envoy_api_enum_value_Cluster.DiscoveryType.ORIGINAL_DST&gt;`
     * this setting is ignored.
     * </pre>
     *
     * <code>.google.protobuf.Duration cleanup_interval = 20 [(.validate.rules) = { ... }</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        com.google.protobuf.Duration, com.google.protobuf.Duration.Builder, com.google.protobuf.DurationOrBuilder> 
        getCleanupIntervalFieldBuilder() {
      if (cleanupIntervalBuilder_ == null) {
        cleanupIntervalBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            com.google.protobuf.Duration, com.google.protobuf.Duration.Builder, com.google.protobuf.DurationOrBuilder>(
                getCleanupInterval(),
                getParentForChildren(),
                isClean());
        cleanupInterval_ = null;
      }
      return cleanupIntervalBuilder_;
    }

    private io.grpc.xds.shaded.envoy.api.v2.core.BindConfig upstreamBindConfig_ = null;
    private com.google.protobuf.SingleFieldBuilderV3<
        io.grpc.xds.shaded.envoy.api.v2.core.BindConfig, io.grpc.xds.shaded.envoy.api.v2.core.BindConfig.Builder, io.grpc.xds.shaded.envoy.api.v2.core.BindConfigOrBuilder> upstreamBindConfigBuilder_;
    /**
     * <pre>
     * Optional configuration used to bind newly established upstream connections.
     * This overrides any bind_config specified in the bootstrap proto.
     * If the address and port are empty, no bind will be performed.
     * </pre>
     *
     * <code>.envoy.api.v2.core.BindConfig upstream_bind_config = 21;</code>
     */
    public boolean hasUpstreamBindConfig() {
      return upstreamBindConfigBuilder_ != null || upstreamBindConfig_ != null;
    }
    /**
     * <pre>
     * Optional configuration used to bind newly established upstream connections.
     * This overrides any bind_config specified in the bootstrap proto.
     * If the address and port are empty, no bind will be performed.
     * </pre>
     *
     * <code>.envoy.api.v2.core.BindConfig upstream_bind_config = 21;</code>
     */
    public io.grpc.xds.shaded.envoy.api.v2.core.BindConfig getUpstreamBindConfig() {
      if (upstreamBindConfigBuilder_ == null) {
        return upstreamBindConfig_ == null ? io.grpc.xds.shaded.envoy.api.v2.core.BindConfig.getDefaultInstance() : upstreamBindConfig_;
      } else {
        return upstreamBindConfigBuilder_.getMessage();
      }
    }
    /**
     * <pre>
     * Optional configuration used to bind newly established upstream connections.
     * This overrides any bind_config specified in the bootstrap proto.
     * If the address and port are empty, no bind will be performed.
     * </pre>
     *
     * <code>.envoy.api.v2.core.BindConfig upstream_bind_config = 21;</code>
     */
    public Builder setUpstreamBindConfig(io.grpc.xds.shaded.envoy.api.v2.core.BindConfig value) {
      if (upstreamBindConfigBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        upstreamBindConfig_ = value;
        onChanged();
      } else {
        upstreamBindConfigBuilder_.setMessage(value);
      }

      return this;
    }
    /**
     * <pre>
     * Optional configuration used to bind newly established upstream connections.
     * This overrides any bind_config specified in the bootstrap proto.
     * If the address and port are empty, no bind will be performed.
     * </pre>
     *
     * <code>.envoy.api.v2.core.BindConfig upstream_bind_config = 21;</code>
     */
    public Builder setUpstreamBindConfig(
        io.grpc.xds.shaded.envoy.api.v2.core.BindConfig.Builder builderForValue) {
      if (upstreamBindConfigBuilder_ == null) {
        upstreamBindConfig_ = builderForValue.build();
        onChanged();
      } else {
        upstreamBindConfigBuilder_.setMessage(builderForValue.build());
      }

      return this;
    }
    /**
     * <pre>
     * Optional configuration used to bind newly established upstream connections.
     * This overrides any bind_config specified in the bootstrap proto.
     * If the address and port are empty, no bind will be performed.
     * </pre>
     *
     * <code>.envoy.api.v2.core.BindConfig upstream_bind_config = 21;</code>
     */
    public Builder mergeUpstreamBindConfig(io.grpc.xds.shaded.envoy.api.v2.core.BindConfig value) {
      if (upstreamBindConfigBuilder_ == null) {
        if (upstreamBindConfig_ != null) {
          upstreamBindConfig_ =
            io.grpc.xds.shaded.envoy.api.v2.core.BindConfig.newBuilder(upstreamBindConfig_).mergeFrom(value).buildPartial();
        } else {
          upstreamBindConfig_ = value;
        }
        onChanged();
      } else {
        upstreamBindConfigBuilder_.mergeFrom(value);
      }

      return this;
    }
    /**
     * <pre>
     * Optional configuration used to bind newly established upstream connections.
     * This overrides any bind_config specified in the bootstrap proto.
     * If the address and port are empty, no bind will be performed.
     * </pre>
     *
     * <code>.envoy.api.v2.core.BindConfig upstream_bind_config = 21;</code>
     */
    public Builder clearUpstreamBindConfig() {
      if (upstreamBindConfigBuilder_ == null) {
        upstreamBindConfig_ = null;
        onChanged();
      } else {
        upstreamBindConfig_ = null;
        upstreamBindConfigBuilder_ = null;
      }

      return this;
    }
    /**
     * <pre>
     * Optional configuration used to bind newly established upstream connections.
     * This overrides any bind_config specified in the bootstrap proto.
     * If the address and port are empty, no bind will be performed.
     * </pre>
     *
     * <code>.envoy.api.v2.core.BindConfig upstream_bind_config = 21;</code>
     */
    public io.grpc.xds.shaded.envoy.api.v2.core.BindConfig.Builder getUpstreamBindConfigBuilder() {
      
      onChanged();
      return getUpstreamBindConfigFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * Optional configuration used to bind newly established upstream connections.
     * This overrides any bind_config specified in the bootstrap proto.
     * If the address and port are empty, no bind will be performed.
     * </pre>
     *
     * <code>.envoy.api.v2.core.BindConfig upstream_bind_config = 21;</code>
     */
    public io.grpc.xds.shaded.envoy.api.v2.core.BindConfigOrBuilder getUpstreamBindConfigOrBuilder() {
      if (upstreamBindConfigBuilder_ != null) {
        return upstreamBindConfigBuilder_.getMessageOrBuilder();
      } else {
        return upstreamBindConfig_ == null ?
            io.grpc.xds.shaded.envoy.api.v2.core.BindConfig.getDefaultInstance() : upstreamBindConfig_;
      }
    }
    /**
     * <pre>
     * Optional configuration used to bind newly established upstream connections.
     * This overrides any bind_config specified in the bootstrap proto.
     * If the address and port are empty, no bind will be performed.
     * </pre>
     *
     * <code>.envoy.api.v2.core.BindConfig upstream_bind_config = 21;</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        io.grpc.xds.shaded.envoy.api.v2.core.BindConfig, io.grpc.xds.shaded.envoy.api.v2.core.BindConfig.Builder, io.grpc.xds.shaded.envoy.api.v2.core.BindConfigOrBuilder> 
        getUpstreamBindConfigFieldBuilder() {
      if (upstreamBindConfigBuilder_ == null) {
        upstreamBindConfigBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            io.grpc.xds.shaded.envoy.api.v2.core.BindConfig, io.grpc.xds.shaded.envoy.api.v2.core.BindConfig.Builder, io.grpc.xds.shaded.envoy.api.v2.core.BindConfigOrBuilder>(
                getUpstreamBindConfig(),
                getParentForChildren(),
                isClean());
        upstreamBindConfig_ = null;
      }
      return upstreamBindConfigBuilder_;
    }

    private io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfig lbSubsetConfig_ = null;
    private com.google.protobuf.SingleFieldBuilderV3<
        io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfig, io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfig.Builder, io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfigOrBuilder> lbSubsetConfigBuilder_;
    /**
     * <pre>
     * Configuration for load balancing subsetting.
     * </pre>
     *
     * <code>.envoy.api.v2.Cluster.LbSubsetConfig lb_subset_config = 22;</code>
     */
    public boolean hasLbSubsetConfig() {
      return lbSubsetConfigBuilder_ != null || lbSubsetConfig_ != null;
    }
    /**
     * <pre>
     * Configuration for load balancing subsetting.
     * </pre>
     *
     * <code>.envoy.api.v2.Cluster.LbSubsetConfig lb_subset_config = 22;</code>
     */
    public io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfig getLbSubsetConfig() {
      if (lbSubsetConfigBuilder_ == null) {
        return lbSubsetConfig_ == null ? io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfig.getDefaultInstance() : lbSubsetConfig_;
      } else {
        return lbSubsetConfigBuilder_.getMessage();
      }
    }
    /**
     * <pre>
     * Configuration for load balancing subsetting.
     * </pre>
     *
     * <code>.envoy.api.v2.Cluster.LbSubsetConfig lb_subset_config = 22;</code>
     */
    public Builder setLbSubsetConfig(io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfig value) {
      if (lbSubsetConfigBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        lbSubsetConfig_ = value;
        onChanged();
      } else {
        lbSubsetConfigBuilder_.setMessage(value);
      }

      return this;
    }
    /**
     * <pre>
     * Configuration for load balancing subsetting.
     * </pre>
     *
     * <code>.envoy.api.v2.Cluster.LbSubsetConfig lb_subset_config = 22;</code>
     */
    public Builder setLbSubsetConfig(
        io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfig.Builder builderForValue) {
      if (lbSubsetConfigBuilder_ == null) {
        lbSubsetConfig_ = builderForValue.build();
        onChanged();
      } else {
        lbSubsetConfigBuilder_.setMessage(builderForValue.build());
      }

      return this;
    }
    /**
     * <pre>
     * Configuration for load balancing subsetting.
     * </pre>
     *
     * <code>.envoy.api.v2.Cluster.LbSubsetConfig lb_subset_config = 22;</code>
     */
    public Builder mergeLbSubsetConfig(io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfig value) {
      if (lbSubsetConfigBuilder_ == null) {
        if (lbSubsetConfig_ != null) {
          lbSubsetConfig_ =
            io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfig.newBuilder(lbSubsetConfig_).mergeFrom(value).buildPartial();
        } else {
          lbSubsetConfig_ = value;
        }
        onChanged();
      } else {
        lbSubsetConfigBuilder_.mergeFrom(value);
      }

      return this;
    }
    /**
     * <pre>
     * Configuration for load balancing subsetting.
     * </pre>
     *
     * <code>.envoy.api.v2.Cluster.LbSubsetConfig lb_subset_config = 22;</code>
     */
    public Builder clearLbSubsetConfig() {
      if (lbSubsetConfigBuilder_ == null) {
        lbSubsetConfig_ = null;
        onChanged();
      } else {
        lbSubsetConfig_ = null;
        lbSubsetConfigBuilder_ = null;
      }

      return this;
    }
    /**
     * <pre>
     * Configuration for load balancing subsetting.
     * </pre>
     *
     * <code>.envoy.api.v2.Cluster.LbSubsetConfig lb_subset_config = 22;</code>
     */
    public io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfig.Builder getLbSubsetConfigBuilder() {
      
      onChanged();
      return getLbSubsetConfigFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * Configuration for load balancing subsetting.
     * </pre>
     *
     * <code>.envoy.api.v2.Cluster.LbSubsetConfig lb_subset_config = 22;</code>
     */
    public io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfigOrBuilder getLbSubsetConfigOrBuilder() {
      if (lbSubsetConfigBuilder_ != null) {
        return lbSubsetConfigBuilder_.getMessageOrBuilder();
      } else {
        return lbSubsetConfig_ == null ?
            io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfig.getDefaultInstance() : lbSubsetConfig_;
      }
    }
    /**
     * <pre>
     * Configuration for load balancing subsetting.
     * </pre>
     *
     * <code>.envoy.api.v2.Cluster.LbSubsetConfig lb_subset_config = 22;</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfig, io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfig.Builder, io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfigOrBuilder> 
        getLbSubsetConfigFieldBuilder() {
      if (lbSubsetConfigBuilder_ == null) {
        lbSubsetConfigBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfig, io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfig.Builder, io.grpc.xds.shaded.envoy.api.v2.Cluster.LbSubsetConfigOrBuilder>(
                getLbSubsetConfig(),
                getParentForChildren(),
                isClean());
        lbSubsetConfig_ = null;
      }
      return lbSubsetConfigBuilder_;
    }

    private com.google.protobuf.SingleFieldBuilderV3<
        io.grpc.xds.shaded.envoy.api.v2.Cluster.RingHashLbConfig, io.grpc.xds.shaded.envoy.api.v2.Cluster.RingHashLbConfig.Builder, io.grpc.xds.shaded.envoy.api.v2.Cluster.RingHashLbConfigOrBuilder> ringHashLbConfigBuilder_;
    /**
     * <pre>
     * Optional configuration for the Ring Hash load balancing policy.
     * </pre>
     *
     * <code>.envoy.api.v2.Cluster.RingHashLbConfig ring_hash_lb_config = 23;</code>
     */
    public boolean hasRingHashLbConfig() {
      return lbConfigCase_ == 23;
    }
    /**
     * <pre>
     * Optional configuration for the Ring Hash load balancing policy.
     * </pre>
     *
     * <code>.envoy.api.v2.Cluster.RingHashLbConfig ring_hash_lb_config = 23;</code>
     */
    public io.grpc.xds.shaded.envoy.api.v2.Cluster.RingHashLbConfig getRingHashLbConfig() {
      if (ringHashLbConfigBuilder_ == null) {
        if (lbConfigCase_ == 23) {
          return (io.grpc.xds.shaded.envoy.api.v2.Cluster.RingHashLbConfig) lbConfig_;
        }
        return io.grpc.xds.shaded.envoy.api.v2.Cluster.RingHashLbConfig.getDefaultInstance();
      } else {
        if (lbConfigCase_ == 23) {
          return ringHashLbConfigBuilder_.getMessage();
        }
        return io.grpc.xds.shaded.envoy.api.v2.Cluster.RingHashLbConfig.getDefaultInstance();
      }
    }
    /**
     * <pre>
     * Optional configuration for the Ring Hash load balancing policy.
     * </pre>
     *
     * <code>.envoy.api.v2.Cluster.RingHashLbConfig ring_hash_lb_config = 23;</code>
     */
    public Builder setRingHashLbConfig(io.grpc.xds.shaded.envoy.api.v2.Cluster.RingHashLbConfig value) {
      if (ringHashLbConfigBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        lbConfig_ = value;
        onChanged();
      } else {
        ringHashLbConfigBuilder_.setMessage(value);
      }
      lbConfigCase_ = 23;
      return this;
    }
    /**
     * <pre>
     * Optional configuration for the Ring Hash load balancing policy.
     * </pre>
     *
     * <code>.envoy.api.v2.Cluster.RingHashLbConfig ring_hash_lb_config = 23;</code>
     */
    public Builder setRingHashLbConfig(
        io.grpc.xds.shaded.envoy.api.v2.Cluster.RingHashLbConfig.Builder builderForValue) {
      if (ringHashLbConfigBuilder_ == null) {
        lbConfig_ = builderForValue.build();
        onChanged();
      } else {
        ringHashLbConfigBuilder_.setMessage(builderForValue.build());
      }
      lbConfigCase_ = 23;
      return this;
    }
    /**
     * <pre>
     * Optional configuration for the Ring Hash load balancing policy.
     * </pre>
     *
     * <code>.envoy.api.v2.Cluster.RingHashLbConfig ring_hash_lb_config = 23;</code>
     */
    public Builder mergeRingHashLbConfig(io.grpc.xds.shaded.envoy.api.v2.Cluster.RingHashLbConfig value) {
      if (ringHashLbConfigBuilder_ == null) {
        if (lbConfigCase_ == 23 &&
            lbConfig_ != io.grpc.xds.shaded.envoy.api.v2.Cluster.RingHashLbConfig.getDefaultInstance()) {
          lbConfig_ = io.grpc.xds.shaded.envoy.api.v2.Cluster.RingHashLbConfig.newBuilder((io.grpc.xds.shaded.envoy.api.v2.Cluster.RingHashLbConfig) lbConfig_)
              .mergeFrom(value).buildPartial();
        } else {
          lbConfig_ = value;
        }
        onChanged();
      } else {
        if (lbConfigCase_ == 23) {
          ringHashLbConfigBuilder_.mergeFrom(value);
        }
        ringHashLbConfigBuilder_.setMessage(value);
      }
      lbConfigCase_ = 23;
      return this;
    }
    /**
     * <pre>
     * Optional configuration for the Ring Hash load balancing policy.
     * </pre>
     *
     * <code>.envoy.api.v2.Cluster.RingHashLbConfig ring_hash_lb_config = 23;</code>
     */
    public Builder clearRingHashLbConfig() {
      if (ringHashLbConfigBuilder_ == null) {
        if (lbConfigCase_ == 23) {
          lbConfigCase_ = 0;
          lbConfig_ = null;
          onChanged();
        }
      } else {
        if (lbConfigCase_ == 23) {
          lbConfigCase_ = 0;
          lbConfig_ = null;
        }
        ringHashLbConfigBuilder_.clear();
      }
      return this;
    }
    /**
     * <pre>
     * Optional configuration for the Ring Hash load balancing policy.
     * </pre>
     *
     * <code>.envoy.api.v2.Cluster.RingHashLbConfig ring_hash_lb_config = 23;</code>
     */
    public io.grpc.xds.shaded.envoy.api.v2.Cluster.RingHashLbConfig.Builder getRingHashLbConfigBuilder() {
      return getRingHashLbConfigFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * Optional configuration for the Ring Hash load balancing policy.
     * </pre>
     *
     * <code>.envoy.api.v2.Cluster.RingHashLbConfig ring_hash_lb_config = 23;</code>
     */
    public io.grpc.xds.shaded.envoy.api.v2.Cluster.RingHashLbConfigOrBuilder getRingHashLbConfigOrBuilder() {
      if ((lbConfigCase_ == 23) && (ringHashLbConfigBuilder_ != null)) {
        return ringHashLbConfigBuilder_.getMessageOrBuilder();
      } else {
        if (lbConfigCase_ == 23) {
          return (io.grpc.xds.shaded.envoy.api.v2.Cluster.RingHashLbConfig) lbConfig_;
        }
        return io.grpc.xds.shaded.envoy.api.v2.Cluster.RingHashLbConfig.getDefaultInstance();
      }
    }
    /**
     * <pre>
     * Optional configuration for the Ring Hash load balancing policy.
     * </pre>
     *
     * <code>.envoy.api.v2.Cluster.RingHashLbConfig ring_hash_lb_config = 23;</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        io.grpc.xds.shaded.envoy.api.v2.Cluster.RingHashLbConfig, io.grpc.xds.shaded.envoy.api.v2.Cluster.RingHashLbConfig.Builder, io.grpc.xds.shaded.envoy.api.v2.Cluster.RingHashLbConfigOrBuilder> 
        getRingHashLbConfigFieldBuilder() {
      if (ringHashLbConfigBuilder_ == null) {
        if (!(lbConfigCase_ == 23)) {
          lbConfig_ = io.grpc.xds.shaded.envoy.api.v2.Cluster.RingHashLbConfig.getDefaultInstance();
        }
        ringHashLbConfigBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            io.grpc.xds.shaded.envoy.api.v2.Cluster.RingHashLbConfig, io.grpc.xds.shaded.envoy.api.v2.Cluster.RingHashLbConfig.Builder, io.grpc.xds.shaded.envoy.api.v2.Cluster.RingHashLbConfigOrBuilder>(
                (io.grpc.xds.shaded.envoy.api.v2.Cluster.RingHashLbConfig) lbConfig_,
                getParentForChildren(),
                isClean());
        lbConfig_ = null;
      }
      lbConfigCase_ = 23;
      onChanged();;
      return ringHashLbConfigBuilder_;
    }

    private com.google.protobuf.SingleFieldBuilderV3<
        io.grpc.xds.shaded.envoy.api.v2.Cluster.OriginalDstLbConfig, io.grpc.xds.shaded.envoy.api.v2.Cluster.OriginalDstLbConfig.Builder, io.grpc.xds.shaded.envoy.api.v2.Cluster.OriginalDstLbConfigOrBuilder> originalDstLbConfigBuilder_;
    /**
     * <pre>
     * Optional configuration for the Original Destination load balancing policy.
     * </pre>
     *
     * <code>.envoy.api.v2.Cluster.OriginalDstLbConfig original_dst_lb_config = 34;</code>
     */
    public boolean hasOriginalDstLbConfig() {
      return lbConfigCase_ == 34;
    }
    /**
     * <pre>
     * Optional configuration for the Original Destination load balancing policy.
     * </pre>
     *
     * <code>.envoy.api.v2.Cluster.OriginalDstLbConfig original_dst_lb_config = 34;</code>
     */
    public io.grpc.xds.shaded.envoy.api.v2.Cluster.OriginalDstLbConfig getOriginalDstLbConfig() {
      if (originalDstLbConfigBuilder_ == null) {
        if (lbConfigCase_ == 34) {
          return (io.grpc.xds.shaded.envoy.api.v2.Cluster.OriginalDstLbConfig) lbConfig_;
        }
        return io.grpc.xds.shaded.envoy.api.v2.Cluster.OriginalDstLbConfig.getDefaultInstance();
      } else {
        if (lbConfigCase_ == 34) {
          return originalDstLbConfigBuilder_.getMessage();
        }
        return io.grpc.xds.shaded.envoy.api.v2.Cluster.OriginalDstLbConfig.getDefaultInstance();
      }
    }
    /**
     * <pre>
     * Optional configuration for the Original Destination load balancing policy.
     * </pre>
     *
     * <code>.envoy.api.v2.Cluster.OriginalDstLbConfig original_dst_lb_config = 34;</code>
     */
    public Builder setOriginalDstLbConfig(io.grpc.xds.shaded.envoy.api.v2.Cluster.OriginalDstLbConfig value) {
      if (originalDstLbConfigBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        lbConfig_ = value;
        onChanged();
      } else {
        originalDstLbConfigBuilder_.setMessage(value);
      }
      lbConfigCase_ = 34;
      return this;
    }
    /**
     * <pre>
     * Optional configuration for the Original Destination load balancing policy.
     * </pre>
     *
     * <code>.envoy.api.v2.Cluster.OriginalDstLbConfig original_dst_lb_config = 34;</code>
     */
    public Builder setOriginalDstLbConfig(
        io.grpc.xds.shaded.envoy.api.v2.Cluster.OriginalDstLbConfig.Builder builderForValue) {
      if (originalDstLbConfigBuilder_ == null) {
        lbConfig_ = builderForValue.build();
        onChanged();
      } else {
        originalDstLbConfigBuilder_.setMessage(builderForValue.build());
      }
      lbConfigCase_ = 34;
      return this;
    }
    /**
     * <pre>
     * Optional configuration for the Original Destination load balancing policy.
     * </pre>
     *
     * <code>.envoy.api.v2.Cluster.OriginalDstLbConfig original_dst_lb_config = 34;</code>
     */
    public Builder mergeOriginalDstLbConfig(io.grpc.xds.shaded.envoy.api.v2.Cluster.OriginalDstLbConfig value) {
      if (originalDstLbConfigBuilder_ == null) {
        if (lbConfigCase_ == 34 &&
            lbConfig_ != io.grpc.xds.shaded.envoy.api.v2.Cluster.OriginalDstLbConfig.getDefaultInstance()) {
          lbConfig_ = io.grpc.xds.shaded.envoy.api.v2.Cluster.OriginalDstLbConfig.newBuilder((io.grpc.xds.shaded.envoy.api.v2.Cluster.OriginalDstLbConfig) lbConfig_)
              .mergeFrom(value).buildPartial();
        } else {
          lbConfig_ = value;
        }
        onChanged();
      } else {
        if (lbConfigCase_ == 34) {
          originalDstLbConfigBuilder_.mergeFrom(value);
        }
        originalDstLbConfigBuilder_.setMessage(value);
      }
      lbConfigCase_ = 34;
      return this;
    }
    /**
     * <pre>
     * Optional configuration for the Original Destination load balancing policy.
     * </pre>
     *
     * <code>.envoy.api.v2.Cluster.OriginalDstLbConfig original_dst_lb_config = 34;</code>
     */
    public Builder clearOriginalDstLbConfig() {
      if (originalDstLbConfigBuilder_ == null) {
        if (lbConfigCase_ == 34) {
          lbConfigCase_ = 0;
          lbConfig_ = null;
          onChanged();
        }
      } else {
        if (lbConfigCase_ == 34) {
          lbConfigCase_ = 0;
          lbConfig_ = null;
        }
        originalDstLbConfigBuilder_.clear();
      }
      return this;
    }
    /**
     * <pre>
     * Optional configuration for the Original Destination load balancing policy.
     * </pre>
     *
     * <code>.envoy.api.v2.Cluster.OriginalDstLbConfig original_dst_lb_config = 34;</code>
     */
    public io.grpc.xds.shaded.envoy.api.v2.Cluster.OriginalDstLbConfig.Builder getOriginalDstLbConfigBuilder() {
      return getOriginalDstLbConfigFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * Optional configuration for the Original Destination load balancing policy.
     * </pre>
     *
     * <code>.envoy.api.v2.Cluster.OriginalDstLbConfig original_dst_lb_config = 34;</code>
     */
    public io.grpc.xds.shaded.envoy.api.v2.Cluster.OriginalDstLbConfigOrBuilder getOriginalDstLbConfigOrBuilder() {
      if ((lbConfigCase_ == 34) && (originalDstLbConfigBuilder_ != null)) {
        return originalDstLbConfigBuilder_.getMessageOrBuilder();
      } else {
        if (lbConfigCase_ == 34) {
          return (io.grpc.xds.shaded.envoy.api.v2.Cluster.OriginalDstLbConfig) lbConfig_;
        }
        return io.grpc.xds.shaded.envoy.api.v2.Cluster.OriginalDstLbConfig.getDefaultInstance();
      }
    }
    /**
     * <pre>
     * Optional configuration for the Original Destination load balancing policy.
     * </pre>
     *
     * <code>.envoy.api.v2.Cluster.OriginalDstLbConfig original_dst_lb_config = 34;</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        io.grpc.xds.shaded.envoy.api.v2.Cluster.OriginalDstLbConfig, io.grpc.xds.shaded.envoy.api.v2.Cluster.OriginalDstLbConfig.Builder, io.grpc.xds.shaded.envoy.api.v2.Cluster.OriginalDstLbConfigOrBuilder> 
        getOriginalDstLbConfigFieldBuilder() {
      if (originalDstLbConfigBuilder_ == null) {
        if (!(lbConfigCase_ == 34)) {
          lbConfig_ = io.grpc.xds.shaded.envoy.api.v2.Cluster.OriginalDstLbConfig.getDefaultInstance();
        }
        originalDstLbConfigBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            io.grpc.xds.shaded.envoy.api.v2.Cluster.OriginalDstLbConfig, io.grpc.xds.shaded.envoy.api.v2.Cluster.OriginalDstLbConfig.Builder, io.grpc.xds.shaded.envoy.api.v2.Cluster.OriginalDstLbConfigOrBuilder>(
                (io.grpc.xds.shaded.envoy.api.v2.Cluster.OriginalDstLbConfig) lbConfig_,
                getParentForChildren(),
                isClean());
        lbConfig_ = null;
      }
      lbConfigCase_ = 34;
      onChanged();;
      return originalDstLbConfigBuilder_;
    }

    private com.google.protobuf.SingleFieldBuilderV3<
        io.grpc.xds.shaded.envoy.api.v2.Cluster.LeastRequestLbConfig, io.grpc.xds.shaded.envoy.api.v2.Cluster.LeastRequestLbConfig.Builder, io.grpc.xds.shaded.envoy.api.v2.Cluster.LeastRequestLbConfigOrBuilder> leastRequestLbConfigBuilder_;
    /**
     * <pre>
     * Optional configuration for the LeastRequest load balancing policy.
     * </pre>
     *
     * <code>.envoy.api.v2.Cluster.LeastRequestLbConfig least_request_lb_config = 37;</code>
     */
    public boolean hasLeastRequestLbConfig() {
      return lbConfigCase_ == 37;
    }
    /**
     * <pre>
     * Optional configuration for the LeastRequest load balancing policy.
     * </pre>
     *
     * <code>.envoy.api.v2.Cluster.LeastRequestLbConfig least_request_lb_config = 37;</code>
     */
    public io.grpc.xds.shaded.envoy.api.v2.Cluster.LeastRequestLbConfig getLeastRequestLbConfig() {
      if (leastRequestLbConfigBuilder_ == null) {
        if (lbConfigCase_ == 37) {
          return (io.grpc.xds.shaded.envoy.api.v2.Cluster.LeastRequestLbConfig) lbConfig_;
        }
        return io.grpc.xds.shaded.envoy.api.v2.Cluster.LeastRequestLbConfig.getDefaultInstance();
      } else {
        if (lbConfigCase_ == 37) {
          return leastRequestLbConfigBuilder_.getMessage();
        }
        return io.grpc.xds.shaded.envoy.api.v2.Cluster.LeastRequestLbConfig.getDefaultInstance();
      }
    }
    /**
     * <pre>
     * Optional configuration for the LeastRequest load balancing policy.
     * </pre>
     *
     * <code>.envoy.api.v2.Cluster.LeastRequestLbConfig least_request_lb_config = 37;</code>
     */
    public Builder setLeastRequestLbConfig(io.grpc.xds.shaded.envoy.api.v2.Cluster.LeastRequestLbConfig value) {
      if (leastRequestLbConfigBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        lbConfig_ = value;
        onChanged();
      } else {
        leastRequestLbConfigBuilder_.setMessage(value);
      }
      lbConfigCase_ = 37;
      return this;
    }
    /**
     * <pre>
     * Optional configuration for the LeastRequest load balancing policy.
     * </pre>
     *
     * <code>.envoy.api.v2.Cluster.LeastRequestLbConfig least_request_lb_config = 37;</code>
     */
    public Builder setLeastRequestLbConfig(
        io.grpc.xds.shaded.envoy.api.v2.Cluster.LeastRequestLbConfig.Builder builderForValue) {
      if (leastRequestLbConfigBuilder_ == null) {
        lbConfig_ = builderForValue.build();
        onChanged();
      } else {
        leastRequestLbConfigBuilder_.setMessage(builderForValue.build());
      }
      lbConfigCase_ = 37;
      return this;
    }
    /**
     * <pre>
     * Optional configuration for the LeastRequest load balancing policy.
     * </pre>
     *
     * <code>.envoy.api.v2.Cluster.LeastRequestLbConfig least_request_lb_config = 37;</code>
     */
    public Builder mergeLeastRequestLbConfig(io.grpc.xds.shaded.envoy.api.v2.Cluster.LeastRequestLbConfig value) {
      if (leastRequestLbConfigBuilder_ == null) {
        if (lbConfigCase_ == 37 &&
            lbConfig_ != io.grpc.xds.shaded.envoy.api.v2.Cluster.LeastRequestLbConfig.getDefaultInstance()) {
          lbConfig_ = io.grpc.xds.shaded.envoy.api.v2.Cluster.LeastRequestLbConfig.newBuilder((io.grpc.xds.shaded.envoy.api.v2.Cluster.LeastRequestLbConfig) lbConfig_)
              .mergeFrom(value).buildPartial();
        } else {
          lbConfig_ = value;
        }
        onChanged();
      } else {
        if (lbConfigCase_ == 37) {
          leastRequestLbConfigBuilder_.mergeFrom(value);
        }
        leastRequestLbConfigBuilder_.setMessage(value);
      }
      lbConfigCase_ = 37;
      return this;
    }
    /**
     * <pre>
     * Optional configuration for the LeastRequest load balancing policy.
     * </pre>
     *
     * <code>.envoy.api.v2.Cluster.LeastRequestLbConfig least_request_lb_config = 37;</code>
     */
    public Builder clearLeastRequestLbConfig() {
      if (leastRequestLbConfigBuilder_ == null) {
        if (lbConfigCase_ == 37) {
          lbConfigCase_ = 0;
          lbConfig_ = null;
          onChanged();
        }
      } else {
        if (lbConfigCase_ == 37) {
          lbConfigCase_ = 0;
          lbConfig_ = null;
        }
        leastRequestLbConfigBuilder_.clear();
      }
      return this;
    }
    /**
     * <pre>
     * Optional configuration for the LeastRequest load balancing policy.
     * </pre>
     *
     * <code>.envoy.api.v2.Cluster.LeastRequestLbConfig least_request_lb_config = 37;</code>
     */
    public io.grpc.xds.shaded.envoy.api.v2.Cluster.LeastRequestLbConfig.Builder getLeastRequestLbConfigBuilder() {
      return getLeastRequestLbConfigFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * Optional configuration for the LeastRequest load balancing policy.
     * </pre>
     *
     * <code>.envoy.api.v2.Cluster.LeastRequestLbConfig least_request_lb_config = 37;</code>
     */
    public io.grpc.xds.shaded.envoy.api.v2.Cluster.LeastRequestLbConfigOrBuilder getLeastRequestLbConfigOrBuilder() {
      if ((lbConfigCase_ == 37) && (leastRequestLbConfigBuilder_ != null)) {
        return leastRequestLbConfigBuilder_.getMessageOrBuilder();
      } else {
        if (lbConfigCase_ == 37) {
          return (io.grpc.xds.shaded.envoy.api.v2.Cluster.LeastRequestLbConfig) lbConfig_;
        }
        return io.grpc.xds.shaded.envoy.api.v2.Cluster.LeastRequestLbConfig.getDefaultInstance();
      }
    }
    /**
     * <pre>
     * Optional configuration for the LeastRequest load balancing policy.
     * </pre>
     *
     * <code>.envoy.api.v2.Cluster.LeastRequestLbConfig least_request_lb_config = 37;</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        io.grpc.xds.shaded.envoy.api.v2.Cluster.LeastRequestLbConfig, io.grpc.xds.shaded.envoy.api.v2.Cluster.LeastRequestLbConfig.Builder, io.grpc.xds.shaded.envoy.api.v2.Cluster.LeastRequestLbConfigOrBuilder> 
        getLeastRequestLbConfigFieldBuilder() {
      if (leastRequestLbConfigBuilder_ == null) {
        if (!(lbConfigCase_ == 37)) {
          lbConfig_ = io.grpc.xds.shaded.envoy.api.v2.Cluster.LeastRequestLbConfig.getDefaultInstance();
        }
        leastRequestLbConfigBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            io.grpc.xds.shaded.envoy.api.v2.Cluster.LeastRequestLbConfig, io.grpc.xds.shaded.envoy.api.v2.Cluster.LeastRequestLbConfig.Builder, io.grpc.xds.shaded.envoy.api.v2.Cluster.LeastRequestLbConfigOrBuilder>(
                (io.grpc.xds.shaded.envoy.api.v2.Cluster.LeastRequestLbConfig) lbConfig_,
                getParentForChildren(),
                isClean());
        lbConfig_ = null;
      }
      lbConfigCase_ = 37;
      onChanged();;
      return leastRequestLbConfigBuilder_;
    }

    private io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig commonLbConfig_ = null;
    private com.google.protobuf.SingleFieldBuilderV3<
        io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig, io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.Builder, io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfigOrBuilder> commonLbConfigBuilder_;
    /**
     * <pre>
     * Common configuration for all load balancer implementations.
     * </pre>
     *
     * <code>.envoy.api.v2.Cluster.CommonLbConfig common_lb_config = 27;</code>
     */
    public boolean hasCommonLbConfig() {
      return commonLbConfigBuilder_ != null || commonLbConfig_ != null;
    }
    /**
     * <pre>
     * Common configuration for all load balancer implementations.
     * </pre>
     *
     * <code>.envoy.api.v2.Cluster.CommonLbConfig common_lb_config = 27;</code>
     */
    public io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig getCommonLbConfig() {
      if (commonLbConfigBuilder_ == null) {
        return commonLbConfig_ == null ? io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.getDefaultInstance() : commonLbConfig_;
      } else {
        return commonLbConfigBuilder_.getMessage();
      }
    }
    /**
     * <pre>
     * Common configuration for all load balancer implementations.
     * </pre>
     *
     * <code>.envoy.api.v2.Cluster.CommonLbConfig common_lb_config = 27;</code>
     */
    public Builder setCommonLbConfig(io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig value) {
      if (commonLbConfigBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        commonLbConfig_ = value;
        onChanged();
      } else {
        commonLbConfigBuilder_.setMessage(value);
      }

      return this;
    }
    /**
     * <pre>
     * Common configuration for all load balancer implementations.
     * </pre>
     *
     * <code>.envoy.api.v2.Cluster.CommonLbConfig common_lb_config = 27;</code>
     */
    public Builder setCommonLbConfig(
        io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.Builder builderForValue) {
      if (commonLbConfigBuilder_ == null) {
        commonLbConfig_ = builderForValue.build();
        onChanged();
      } else {
        commonLbConfigBuilder_.setMessage(builderForValue.build());
      }

      return this;
    }
    /**
     * <pre>
     * Common configuration for all load balancer implementations.
     * </pre>
     *
     * <code>.envoy.api.v2.Cluster.CommonLbConfig common_lb_config = 27;</code>
     */
    public Builder mergeCommonLbConfig(io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig value) {
      if (commonLbConfigBuilder_ == null) {
        if (commonLbConfig_ != null) {
          commonLbConfig_ =
            io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.newBuilder(commonLbConfig_).mergeFrom(value).buildPartial();
        } else {
          commonLbConfig_ = value;
        }
        onChanged();
      } else {
        commonLbConfigBuilder_.mergeFrom(value);
      }

      return this;
    }
    /**
     * <pre>
     * Common configuration for all load balancer implementations.
     * </pre>
     *
     * <code>.envoy.api.v2.Cluster.CommonLbConfig common_lb_config = 27;</code>
     */
    public Builder clearCommonLbConfig() {
      if (commonLbConfigBuilder_ == null) {
        commonLbConfig_ = null;
        onChanged();
      } else {
        commonLbConfig_ = null;
        commonLbConfigBuilder_ = null;
      }

      return this;
    }
    /**
     * <pre>
     * Common configuration for all load balancer implementations.
     * </pre>
     *
     * <code>.envoy.api.v2.Cluster.CommonLbConfig common_lb_config = 27;</code>
     */
    public io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.Builder getCommonLbConfigBuilder() {
      
      onChanged();
      return getCommonLbConfigFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * Common configuration for all load balancer implementations.
     * </pre>
     *
     * <code>.envoy.api.v2.Cluster.CommonLbConfig common_lb_config = 27;</code>
     */
    public io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfigOrBuilder getCommonLbConfigOrBuilder() {
      if (commonLbConfigBuilder_ != null) {
        return commonLbConfigBuilder_.getMessageOrBuilder();
      } else {
        return commonLbConfig_ == null ?
            io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.getDefaultInstance() : commonLbConfig_;
      }
    }
    /**
     * <pre>
     * Common configuration for all load balancer implementations.
     * </pre>
     *
     * <code>.envoy.api.v2.Cluster.CommonLbConfig common_lb_config = 27;</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig, io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.Builder, io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfigOrBuilder> 
        getCommonLbConfigFieldBuilder() {
      if (commonLbConfigBuilder_ == null) {
        commonLbConfigBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig, io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfig.Builder, io.grpc.xds.shaded.envoy.api.v2.Cluster.CommonLbConfigOrBuilder>(
                getCommonLbConfig(),
                getParentForChildren(),
                isClean());
        commonLbConfig_ = null;
      }
      return commonLbConfigBuilder_;
    }

    private io.grpc.xds.shaded.envoy.api.v2.core.TransportSocket transportSocket_ = null;
    private com.google.protobuf.SingleFieldBuilderV3<
        io.grpc.xds.shaded.envoy.api.v2.core.TransportSocket, io.grpc.xds.shaded.envoy.api.v2.core.TransportSocket.Builder, io.grpc.xds.shaded.envoy.api.v2.core.TransportSocketOrBuilder> transportSocketBuilder_;
    /**
     * <pre>
     * Optional custom transport socket implementation to use for upstream connections.
     * </pre>
     *
     * <code>.envoy.api.v2.core.TransportSocket transport_socket = 24;</code>
     */
    public boolean hasTransportSocket() {
      return transportSocketBuilder_ != null || transportSocket_ != null;
    }
    /**
     * <pre>
     * Optional custom transport socket implementation to use for upstream connections.
     * </pre>
     *
     * <code>.envoy.api.v2.core.TransportSocket transport_socket = 24;</code>
     */
    public io.grpc.xds.shaded.envoy.api.v2.core.TransportSocket getTransportSocket() {
      if (transportSocketBuilder_ == null) {
        return transportSocket_ == null ? io.grpc.xds.shaded.envoy.api.v2.core.TransportSocket.getDefaultInstance() : transportSocket_;
      } else {
        return transportSocketBuilder_.getMessage();
      }
    }
    /**
     * <pre>
     * Optional custom transport socket implementation to use for upstream connections.
     * </pre>
     *
     * <code>.envoy.api.v2.core.TransportSocket transport_socket = 24;</code>
     */
    public Builder setTransportSocket(io.grpc.xds.shaded.envoy.api.v2.core.TransportSocket value) {
      if (transportSocketBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        transportSocket_ = value;
        onChanged();
      } else {
        transportSocketBuilder_.setMessage(value);
      }

      return this;
    }
    /**
     * <pre>
     * Optional custom transport socket implementation to use for upstream connections.
     * </pre>
     *
     * <code>.envoy.api.v2.core.TransportSocket transport_socket = 24;</code>
     */
    public Builder setTransportSocket(
        io.grpc.xds.shaded.envoy.api.v2.core.TransportSocket.Builder builderForValue) {
      if (transportSocketBuilder_ == null) {
        transportSocket_ = builderForValue.build();
        onChanged();
      } else {
        transportSocketBuilder_.setMessage(builderForValue.build());
      }

      return this;
    }
    /**
     * <pre>
     * Optional custom transport socket implementation to use for upstream connections.
     * </pre>
     *
     * <code>.envoy.api.v2.core.TransportSocket transport_socket = 24;</code>
     */
    public Builder mergeTransportSocket(io.grpc.xds.shaded.envoy.api.v2.core.TransportSocket value) {
      if (transportSocketBuilder_ == null) {
        if (transportSocket_ != null) {
          transportSocket_ =
            io.grpc.xds.shaded.envoy.api.v2.core.TransportSocket.newBuilder(transportSocket_).mergeFrom(value).buildPartial();
        } else {
          transportSocket_ = value;
        }
        onChanged();
      } else {
        transportSocketBuilder_.mergeFrom(value);
      }

      return this;
    }
    /**
     * <pre>
     * Optional custom transport socket implementation to use for upstream connections.
     * </pre>
     *
     * <code>.envoy.api.v2.core.TransportSocket transport_socket = 24;</code>
     */
    public Builder clearTransportSocket() {
      if (transportSocketBuilder_ == null) {
        transportSocket_ = null;
        onChanged();
      } else {
        transportSocket_ = null;
        transportSocketBuilder_ = null;
      }

      return this;
    }
    /**
     * <pre>
     * Optional custom transport socket implementation to use for upstream connections.
     * </pre>
     *
     * <code>.envoy.api.v2.core.TransportSocket transport_socket = 24;</code>
     */
    public io.grpc.xds.shaded.envoy.api.v2.core.TransportSocket.Builder getTransportSocketBuilder() {
      
      onChanged();
      return getTransportSocketFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * Optional custom transport socket implementation to use for upstream connections.
     * </pre>
     *
     * <code>.envoy.api.v2.core.TransportSocket transport_socket = 24;</code>
     */
    public io.grpc.xds.shaded.envoy.api.v2.core.TransportSocketOrBuilder getTransportSocketOrBuilder() {
      if (transportSocketBuilder_ != null) {
        return transportSocketBuilder_.getMessageOrBuilder();
      } else {
        return transportSocket_ == null ?
            io.grpc.xds.shaded.envoy.api.v2.core.TransportSocket.getDefaultInstance() : transportSocket_;
      }
    }
    /**
     * <pre>
     * Optional custom transport socket implementation to use for upstream connections.
     * </pre>
     *
     * <code>.envoy.api.v2.core.TransportSocket transport_socket = 24;</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        io.grpc.xds.shaded.envoy.api.v2.core.TransportSocket, io.grpc.xds.shaded.envoy.api.v2.core.TransportSocket.Builder, io.grpc.xds.shaded.envoy.api.v2.core.TransportSocketOrBuilder> 
        getTransportSocketFieldBuilder() {
      if (transportSocketBuilder_ == null) {
        transportSocketBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            io.grpc.xds.shaded.envoy.api.v2.core.TransportSocket, io.grpc.xds.shaded.envoy.api.v2.core.TransportSocket.Builder, io.grpc.xds.shaded.envoy.api.v2.core.TransportSocketOrBuilder>(
                getTransportSocket(),
                getParentForChildren(),
                isClean());
        transportSocket_ = null;
      }
      return transportSocketBuilder_;
    }

    private io.grpc.xds.shaded.envoy.api.v2.core.Metadata metadata_ = null;
    private com.google.protobuf.SingleFieldBuilderV3<
        io.grpc.xds.shaded.envoy.api.v2.core.Metadata, io.grpc.xds.shaded.envoy.api.v2.core.Metadata.Builder, io.grpc.xds.shaded.envoy.api.v2.core.MetadataOrBuilder> metadataBuilder_;
    /**
     * <pre>
     * The Metadata field can be used to provide additional information about the
     * cluster. It can be used for stats, logging, and varying filter behavior.
     * Fields should use reverse DNS notation to denote which entity within Envoy
     * will need the information. For instance, if the metadata is intended for
     * the Router filter, the filter name should be specified as *envoy.router*.
     * </pre>
     *
     * <code>.envoy.api.v2.core.Metadata metadata = 25;</code>
     */
    public boolean hasMetadata() {
      return metadataBuilder_ != null || metadata_ != null;
    }
    /**
     * <pre>
     * The Metadata field can be used to provide additional information about the
     * cluster. It can be used for stats, logging, and varying filter behavior.
     * Fields should use reverse DNS notation to denote which entity within Envoy
     * will need the information. For instance, if the metadata is intended for
     * the Router filter, the filter name should be specified as *envoy.router*.
     * </pre>
     *
     * <code>.envoy.api.v2.core.Metadata metadata = 25;</code>
     */
    public io.grpc.xds.shaded.envoy.api.v2.core.Metadata getMetadata() {
      if (metadataBuilder_ == null) {
        return metadata_ == null ? io.grpc.xds.shaded.envoy.api.v2.core.Metadata.getDefaultInstance() : metadata_;
      } else {
        return metadataBuilder_.getMessage();
      }
    }
    /**
     * <pre>
     * The Metadata field can be used to provide additional information about the
     * cluster. It can be used for stats, logging, and varying filter behavior.
     * Fields should use reverse DNS notation to denote which entity within Envoy
     * will need the information. For instance, if the metadata is intended for
     * the Router filter, the filter name should be specified as *envoy.router*.
     * </pre>
     *
     * <code>.envoy.api.v2.core.Metadata metadata = 25;</code>
     */
    public Builder setMetadata(io.grpc.xds.shaded.envoy.api.v2.core.Metadata value) {
      if (metadataBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        metadata_ = value;
        onChanged();
      } else {
        metadataBuilder_.setMessage(value);
      }

      return this;
    }
    /**
     * <pre>
     * The Metadata field can be used to provide additional information about the
     * cluster. It can be used for stats, logging, and varying filter behavior.
     * Fields should use reverse DNS notation to denote which entity within Envoy
     * will need the information. For instance, if the metadata is intended for
     * the Router filter, the filter name should be specified as *envoy.router*.
     * </pre>
     *
     * <code>.envoy.api.v2.core.Metadata metadata = 25;</code>
     */
    public Builder setMetadata(
        io.grpc.xds.shaded.envoy.api.v2.core.Metadata.Builder builderForValue) {
      if (metadataBuilder_ == null) {
        metadata_ = builderForValue.build();
        onChanged();
      } else {
        metadataBuilder_.setMessage(builderForValue.build());
      }

      return this;
    }
    /**
     * <pre>
     * The Metadata field can be used to provide additional information about the
     * cluster. It can be used for stats, logging, and varying filter behavior.
     * Fields should use reverse DNS notation to denote which entity within Envoy
     * will need the information. For instance, if the metadata is intended for
     * the Router filter, the filter name should be specified as *envoy.router*.
     * </pre>
     *
     * <code>.envoy.api.v2.core.Metadata metadata = 25;</code>
     */
    public Builder mergeMetadata(io.grpc.xds.shaded.envoy.api.v2.core.Metadata value) {
      if (metadataBuilder_ == null) {
        if (metadata_ != null) {
          metadata_ =
            io.grpc.xds.shaded.envoy.api.v2.core.Metadata.newBuilder(metadata_).mergeFrom(value).buildPartial();
        } else {
          metadata_ = value;
        }
        onChanged();
      } else {
        metadataBuilder_.mergeFrom(value);
      }

      return this;
    }
    /**
     * <pre>
     * The Metadata field can be used to provide additional information about the
     * cluster. It can be used for stats, logging, and varying filter behavior.
     * Fields should use reverse DNS notation to denote which entity within Envoy
     * will need the information. For instance, if the metadata is intended for
     * the Router filter, the filter name should be specified as *envoy.router*.
     * </pre>
     *
     * <code>.envoy.api.v2.core.Metadata metadata = 25;</code>
     */
    public Builder clearMetadata() {
      if (metadataBuilder_ == null) {
        metadata_ = null;
        onChanged();
      } else {
        metadata_ = null;
        metadataBuilder_ = null;
      }

      return this;
    }
    /**
     * <pre>
     * The Metadata field can be used to provide additional information about the
     * cluster. It can be used for stats, logging, and varying filter behavior.
     * Fields should use reverse DNS notation to denote which entity within Envoy
     * will need the information. For instance, if the metadata is intended for
     * the Router filter, the filter name should be specified as *envoy.router*.
     * </pre>
     *
     * <code>.envoy.api.v2.core.Metadata metadata = 25;</code>
     */
    public io.grpc.xds.shaded.envoy.api.v2.core.Metadata.Builder getMetadataBuilder() {
      
      onChanged();
      return getMetadataFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * The Metadata field can be used to provide additional information about the
     * cluster. It can be used for stats, logging, and varying filter behavior.
     * Fields should use reverse DNS notation to denote which entity within Envoy
     * will need the information. For instance, if the metadata is intended for
     * the Router filter, the filter name should be specified as *envoy.router*.
     * </pre>
     *
     * <code>.envoy.api.v2.core.Metadata metadata = 25;</code>
     */
    public io.grpc.xds.shaded.envoy.api.v2.core.MetadataOrBuilder getMetadataOrBuilder() {
      if (metadataBuilder_ != null) {
        return metadataBuilder_.getMessageOrBuilder();
      } else {
        return metadata_ == null ?
            io.grpc.xds.shaded.envoy.api.v2.core.Metadata.getDefaultInstance() : metadata_;
      }
    }
    /**
     * <pre>
     * The Metadata field can be used to provide additional information about the
     * cluster. It can be used for stats, logging, and varying filter behavior.
     * Fields should use reverse DNS notation to denote which entity within Envoy
     * will need the information. For instance, if the metadata is intended for
     * the Router filter, the filter name should be specified as *envoy.router*.
     * </pre>
     *
     * <code>.envoy.api.v2.core.Metadata metadata = 25;</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        io.grpc.xds.shaded.envoy.api.v2.core.Metadata, io.grpc.xds.shaded.envoy.api.v2.core.Metadata.Builder, io.grpc.xds.shaded.envoy.api.v2.core.MetadataOrBuilder> 
        getMetadataFieldBuilder() {
      if (metadataBuilder_ == null) {
        metadataBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            io.grpc.xds.shaded.envoy.api.v2.core.Metadata, io.grpc.xds.shaded.envoy.api.v2.core.Metadata.Builder, io.grpc.xds.shaded.envoy.api.v2.core.MetadataOrBuilder>(
                getMetadata(),
                getParentForChildren(),
                isClean());
        metadata_ = null;
      }
      return metadataBuilder_;
    }

    private int protocolSelection_ = 0;
    /**
     * <pre>
     * Determines how Envoy selects the protocol used to speak to upstream hosts.
     * </pre>
     *
     * <code>.envoy.api.v2.Cluster.ClusterProtocolSelection protocol_selection = 26;</code>
     */
    public int getProtocolSelectionValue() {
      return protocolSelection_;
    }
    /**
     * <pre>
     * Determines how Envoy selects the protocol used to speak to upstream hosts.
     * </pre>
     *
     * <code>.envoy.api.v2.Cluster.ClusterProtocolSelection protocol_selection = 26;</code>
     */
    public Builder setProtocolSelectionValue(int value) {
      protocolSelection_ = value;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Determines how Envoy selects the protocol used to speak to upstream hosts.
     * </pre>
     *
     * <code>.envoy.api.v2.Cluster.ClusterProtocolSelection protocol_selection = 26;</code>
     */
    public io.grpc.xds.shaded.envoy.api.v2.Cluster.ClusterProtocolSelection getProtocolSelection() {
      io.grpc.xds.shaded.envoy.api.v2.Cluster.ClusterProtocolSelection result = io.grpc.xds.shaded.envoy.api.v2.Cluster.ClusterProtocolSelection.valueOf(protocolSelection_);
      return result == null ? io.grpc.xds.shaded.envoy.api.v2.Cluster.ClusterProtocolSelection.UNRECOGNIZED : result;
    }
    /**
     * <pre>
     * Determines how Envoy selects the protocol used to speak to upstream hosts.
     * </pre>
     *
     * <code>.envoy.api.v2.Cluster.ClusterProtocolSelection protocol_selection = 26;</code>
     */
    public Builder setProtocolSelection(io.grpc.xds.shaded.envoy.api.v2.Cluster.ClusterProtocolSelection value) {
      if (value == null) {
        throw new NullPointerException();
      }
      
      protocolSelection_ = value.getNumber();
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Determines how Envoy selects the protocol used to speak to upstream hosts.
     * </pre>
     *
     * <code>.envoy.api.v2.Cluster.ClusterProtocolSelection protocol_selection = 26;</code>
     */
    public Builder clearProtocolSelection() {
      
      protocolSelection_ = 0;
      onChanged();
      return this;
    }

    private io.grpc.xds.shaded.envoy.api.v2.UpstreamConnectionOptions upstreamConnectionOptions_ = null;
    private com.google.protobuf.SingleFieldBuilderV3<
        io.grpc.xds.shaded.envoy.api.v2.UpstreamConnectionOptions, io.grpc.xds.shaded.envoy.api.v2.UpstreamConnectionOptions.Builder, io.grpc.xds.shaded.envoy.api.v2.UpstreamConnectionOptionsOrBuilder> upstreamConnectionOptionsBuilder_;
    /**
     * <pre>
     * Optional options for upstream connections.
     * </pre>
     *
     * <code>.envoy.api.v2.UpstreamConnectionOptions upstream_connection_options = 30;</code>
     */
    public boolean hasUpstreamConnectionOptions() {
      return upstreamConnectionOptionsBuilder_ != null || upstreamConnectionOptions_ != null;
    }
    /**
     * <pre>
     * Optional options for upstream connections.
     * </pre>
     *
     * <code>.envoy.api.v2.UpstreamConnectionOptions upstream_connection_options = 30;</code>
     */
    public io.grpc.xds.shaded.envoy.api.v2.UpstreamConnectionOptions getUpstreamConnectionOptions() {
      if (upstreamConnectionOptionsBuilder_ == null) {
        return upstreamConnectionOptions_ == null ? io.grpc.xds.shaded.envoy.api.v2.UpstreamConnectionOptions.getDefaultInstance() : upstreamConnectionOptions_;
      } else {
        return upstreamConnectionOptionsBuilder_.getMessage();
      }
    }
    /**
     * <pre>
     * Optional options for upstream connections.
     * </pre>
     *
     * <code>.envoy.api.v2.UpstreamConnectionOptions upstream_connection_options = 30;</code>
     */
    public Builder setUpstreamConnectionOptions(io.grpc.xds.shaded.envoy.api.v2.UpstreamConnectionOptions value) {
      if (upstreamConnectionOptionsBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        upstreamConnectionOptions_ = value;
        onChanged();
      } else {
        upstreamConnectionOptionsBuilder_.setMessage(value);
      }

      return this;
    }
    /**
     * <pre>
     * Optional options for upstream connections.
     * </pre>
     *
     * <code>.envoy.api.v2.UpstreamConnectionOptions upstream_connection_options = 30;</code>
     */
    public Builder setUpstreamConnectionOptions(
        io.grpc.xds.shaded.envoy.api.v2.UpstreamConnectionOptions.Builder builderForValue) {
      if (upstreamConnectionOptionsBuilder_ == null) {
        upstreamConnectionOptions_ = builderForValue.build();
        onChanged();
      } else {
        upstreamConnectionOptionsBuilder_.setMessage(builderForValue.build());
      }

      return this;
    }
    /**
     * <pre>
     * Optional options for upstream connections.
     * </pre>
     *
     * <code>.envoy.api.v2.UpstreamConnectionOptions upstream_connection_options = 30;</code>
     */
    public Builder mergeUpstreamConnectionOptions(io.grpc.xds.shaded.envoy.api.v2.UpstreamConnectionOptions value) {
      if (upstreamConnectionOptionsBuilder_ == null) {
        if (upstreamConnectionOptions_ != null) {
          upstreamConnectionOptions_ =
            io.grpc.xds.shaded.envoy.api.v2.UpstreamConnectionOptions.newBuilder(upstreamConnectionOptions_).mergeFrom(value).buildPartial();
        } else {
          upstreamConnectionOptions_ = value;
        }
        onChanged();
      } else {
        upstreamConnectionOptionsBuilder_.mergeFrom(value);
      }

      return this;
    }
    /**
     * <pre>
     * Optional options for upstream connections.
     * </pre>
     *
     * <code>.envoy.api.v2.UpstreamConnectionOptions upstream_connection_options = 30;</code>
     */
    public Builder clearUpstreamConnectionOptions() {
      if (upstreamConnectionOptionsBuilder_ == null) {
        upstreamConnectionOptions_ = null;
        onChanged();
      } else {
        upstreamConnectionOptions_ = null;
        upstreamConnectionOptionsBuilder_ = null;
      }

      return this;
    }
    /**
     * <pre>
     * Optional options for upstream connections.
     * </pre>
     *
     * <code>.envoy.api.v2.UpstreamConnectionOptions upstream_connection_options = 30;</code>
     */
    public io.grpc.xds.shaded.envoy.api.v2.UpstreamConnectionOptions.Builder getUpstreamConnectionOptionsBuilder() {
      
      onChanged();
      return getUpstreamConnectionOptionsFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * Optional options for upstream connections.
     * </pre>
     *
     * <code>.envoy.api.v2.UpstreamConnectionOptions upstream_connection_options = 30;</code>
     */
    public io.grpc.xds.shaded.envoy.api.v2.UpstreamConnectionOptionsOrBuilder getUpstreamConnectionOptionsOrBuilder() {
      if (upstreamConnectionOptionsBuilder_ != null) {
        return upstreamConnectionOptionsBuilder_.getMessageOrBuilder();
      } else {
        return upstreamConnectionOptions_ == null ?
            io.grpc.xds.shaded.envoy.api.v2.UpstreamConnectionOptions.getDefaultInstance() : upstreamConnectionOptions_;
      }
    }
    /**
     * <pre>
     * Optional options for upstream connections.
     * </pre>
     *
     * <code>.envoy.api.v2.UpstreamConnectionOptions upstream_connection_options = 30;</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        io.grpc.xds.shaded.envoy.api.v2.UpstreamConnectionOptions, io.grpc.xds.shaded.envoy.api.v2.UpstreamConnectionOptions.Builder, io.grpc.xds.shaded.envoy.api.v2.UpstreamConnectionOptionsOrBuilder> 
        getUpstreamConnectionOptionsFieldBuilder() {
      if (upstreamConnectionOptionsBuilder_ == null) {
        upstreamConnectionOptionsBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            io.grpc.xds.shaded.envoy.api.v2.UpstreamConnectionOptions, io.grpc.xds.shaded.envoy.api.v2.UpstreamConnectionOptions.Builder, io.grpc.xds.shaded.envoy.api.v2.UpstreamConnectionOptionsOrBuilder>(
                getUpstreamConnectionOptions(),
                getParentForChildren(),
                isClean());
        upstreamConnectionOptions_ = null;
      }
      return upstreamConnectionOptionsBuilder_;
    }

    private boolean closeConnectionsOnHostHealthFailure_ ;
    /**
     * <pre>
     * If an upstream host becomes unhealthy (as determined by the configured health checks
     * or outlier detection), immediately close all connections to the failed host.
     * .. note::
     *   This is currently only supported for connections created by tcp_proxy.
     * .. note::
     *   The current implementation of this feature closes all connections immediately when
     *   the unhealthy status is detected. If there are a large number of connections open
     *   to an upstream host that becomes unhealthy, Envoy may spend a substantial amount of
     *   time exclusively closing these connections, and not processing any other traffic.
     * </pre>
     *
     * <code>bool close_connections_on_host_health_failure = 31;</code>
     */
    public boolean getCloseConnectionsOnHostHealthFailure() {
      return closeConnectionsOnHostHealthFailure_;
    }
    /**
     * <pre>
     * If an upstream host becomes unhealthy (as determined by the configured health checks
     * or outlier detection), immediately close all connections to the failed host.
     * .. note::
     *   This is currently only supported for connections created by tcp_proxy.
     * .. note::
     *   The current implementation of this feature closes all connections immediately when
     *   the unhealthy status is detected. If there are a large number of connections open
     *   to an upstream host that becomes unhealthy, Envoy may spend a substantial amount of
     *   time exclusively closing these connections, and not processing any other traffic.
     * </pre>
     *
     * <code>bool close_connections_on_host_health_failure = 31;</code>
     */
    public Builder setCloseConnectionsOnHostHealthFailure(boolean value) {
      
      closeConnectionsOnHostHealthFailure_ = value;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * If an upstream host becomes unhealthy (as determined by the configured health checks
     * or outlier detection), immediately close all connections to the failed host.
     * .. note::
     *   This is currently only supported for connections created by tcp_proxy.
     * .. note::
     *   The current implementation of this feature closes all connections immediately when
     *   the unhealthy status is detected. If there are a large number of connections open
     *   to an upstream host that becomes unhealthy, Envoy may spend a substantial amount of
     *   time exclusively closing these connections, and not processing any other traffic.
     * </pre>
     *
     * <code>bool close_connections_on_host_health_failure = 31;</code>
     */
    public Builder clearCloseConnectionsOnHostHealthFailure() {
      
      closeConnectionsOnHostHealthFailure_ = false;
      onChanged();
      return this;
    }

    private boolean drainConnectionsOnHostRemoval_ ;
    /**
     * <pre>
     * If this cluster uses EDS or STRICT_DNS to configure its hosts, immediately drain
     * connections from any hosts that are removed from service discovery.
     * This only affects behavior for hosts that are being actively health checked.
     * If this flag is not set to true, Envoy will wait until the hosts fail active health
     * checking before removing it from the cluster.
     * </pre>
     *
     * <code>bool drain_connections_on_host_removal = 32;</code>
     */
    public boolean getDrainConnectionsOnHostRemoval() {
      return drainConnectionsOnHostRemoval_;
    }
    /**
     * <pre>
     * If this cluster uses EDS or STRICT_DNS to configure its hosts, immediately drain
     * connections from any hosts that are removed from service discovery.
     * This only affects behavior for hosts that are being actively health checked.
     * If this flag is not set to true, Envoy will wait until the hosts fail active health
     * checking before removing it from the cluster.
     * </pre>
     *
     * <code>bool drain_connections_on_host_removal = 32;</code>
     */
    public Builder setDrainConnectionsOnHostRemoval(boolean value) {
      
      drainConnectionsOnHostRemoval_ = value;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * If this cluster uses EDS or STRICT_DNS to configure its hosts, immediately drain
     * connections from any hosts that are removed from service discovery.
     * This only affects behavior for hosts that are being actively health checked.
     * If this flag is not set to true, Envoy will wait until the hosts fail active health
     * checking before removing it from the cluster.
     * </pre>
     *
     * <code>bool drain_connections_on_host_removal = 32;</code>
     */
    public Builder clearDrainConnectionsOnHostRemoval() {
      
      drainConnectionsOnHostRemoval_ = false;
      onChanged();
      return this;
    }
    public final Builder setUnknownFields(
        final com.google.protobuf.UnknownFieldSet unknownFields) {
      return super.setUnknownFieldsProto3(unknownFields);
    }

    public final Builder mergeUnknownFields(
        final com.google.protobuf.UnknownFieldSet unknownFields) {
      return super.mergeUnknownFields(unknownFields);
    }


    // @@protoc_insertion_point(builder_scope:envoy.api.v2.Cluster)
  }

  // @@protoc_insertion_point(class_scope:envoy.api.v2.Cluster)
  private static final io.grpc.xds.shaded.envoy.api.v2.Cluster DEFAULT_INSTANCE;
  static {
    DEFAULT_INSTANCE = new io.grpc.xds.shaded.envoy.api.v2.Cluster();
  }

  public static io.grpc.xds.shaded.envoy.api.v2.Cluster getDefaultInstance() {
    return DEFAULT_INSTANCE;
  }

  private static final com.google.protobuf.Parser<Cluster>
      PARSER = new com.google.protobuf.AbstractParser<Cluster>() {
    public Cluster parsePartialFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return new Cluster(input, extensionRegistry);
    }
  };

  public static com.google.protobuf.Parser<Cluster> parser() {
    return PARSER;
  }

  @java.lang.Override
  public com.google.protobuf.Parser<Cluster> getParserForType() {
    return PARSER;
  }

  public io.grpc.xds.shaded.envoy.api.v2.Cluster getDefaultInstanceForType() {
    return DEFAULT_INSTANCE;
  }

}

