// Code generated by protoc-gen-go.
// source: control.proto
// DO NOT EDIT!

/*
Package grpc_testing is a generated protocol buffer package.

It is generated from these files:
	control.proto
	messages.proto
	payloads.proto
	services.proto
	stats.proto

It has these top-level messages:
	PoissonParams
	ClosedLoopParams
	LoadParams
	SecurityParams
	ClientConfig
	ClientStatus
	Mark
	ClientArgs
	ServerConfig
	ServerArgs
	ServerStatus
	CoreRequest
	CoreResponse
	Void
	Scenario
	Scenarios
	ScenarioResultSummary
	ScenarioResult
	Payload
	EchoStatus
	SimpleRequest
	SimpleResponse
	StreamingInputCallRequest
	StreamingInputCallResponse
	ResponseParameters
	StreamingOutputCallRequest
	StreamingOutputCallResponse
	ReconnectParams
	ReconnectInfo
	ByteBufferParams
	SimpleProtoParams
	ComplexProtoParams
	PayloadConfig
	ServerStats
	HistogramParams
	HistogramData
	ClientStats
*/
package grpc_testing

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
const _ = proto.ProtoPackageIsVersion1

type ClientType int32

const (
	// Many languages support a basic distinction between using
	// sync or async client, and this allows the specification
	ClientType_SYNC_CLIENT  ClientType = 0
	ClientType_ASYNC_CLIENT ClientType = 1
	ClientType_OTHER_CLIENT ClientType = 2
)

var ClientType_name = map[int32]string{
	0: "SYNC_CLIENT",
	1: "ASYNC_CLIENT",
	2: "OTHER_CLIENT",
}
var ClientType_value = map[string]int32{
	"SYNC_CLIENT":  0,
	"ASYNC_CLIENT": 1,
	"OTHER_CLIENT": 2,
}

func (x ClientType) String() string {
	return proto.EnumName(ClientType_name, int32(x))
}
func (ClientType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type ServerType int32

const (
	ServerType_SYNC_SERVER          ServerType = 0
	ServerType_ASYNC_SERVER         ServerType = 1
	ServerType_ASYNC_GENERIC_SERVER ServerType = 2
	ServerType_OTHER_SERVER         ServerType = 3
)

var ServerType_name = map[int32]string{
	0: "SYNC_SERVER",
	1: "ASYNC_SERVER",
	2: "ASYNC_GENERIC_SERVER",
	3: "OTHER_SERVER",
}
var ServerType_value = map[string]int32{
	"SYNC_SERVER":          0,
	"ASYNC_SERVER":         1,
	"ASYNC_GENERIC_SERVER": 2,
	"OTHER_SERVER":         3,
}

func (x ServerType) String() string {
	return proto.EnumName(ServerType_name, int32(x))
}
func (ServerType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

type RpcType int32

const (
	RpcType_UNARY     RpcType = 0
	RpcType_STREAMING RpcType = 1
)

var RpcType_name = map[int32]string{
	0: "UNARY",
	1: "STREAMING",
}
var RpcType_value = map[string]int32{
	"UNARY":     0,
	"STREAMING": 1,
}

func (x RpcType) String() string {
	return proto.EnumName(RpcType_name, int32(x))
}
func (RpcType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

// Parameters of poisson process distribution, which is a good representation
// of activity coming in from independent identical stationary sources.
type PoissonParams struct {
	// The rate of arrivals (a.k.a. lambda parameter of the exp distribution).
	OfferedLoad float64 `protobuf:"fixed64,1,opt,name=offered_load,json=offeredLoad" json:"offered_load,omitempty"`
}

func (m *PoissonParams) Reset()                    { *m = PoissonParams{} }
func (m *PoissonParams) String() string            { return proto.CompactTextString(m) }
func (*PoissonParams) ProtoMessage()               {}
func (*PoissonParams) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

// Once an RPC finishes, immediately start a new one.
// No configuration parameters needed.
type ClosedLoopParams struct {
}

func (m *ClosedLoopParams) Reset()                    { *m = ClosedLoopParams{} }
func (m *ClosedLoopParams) String() string            { return proto.CompactTextString(m) }
func (*ClosedLoopParams) ProtoMessage()               {}
func (*ClosedLoopParams) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

type LoadParams struct {
	// Types that are valid to be assigned to Load:
	//	*LoadParams_ClosedLoop
	//	*LoadParams_Poisson
	Load isLoadParams_Load `protobuf_oneof:"load"`
}

func (m *LoadParams) Reset()                    { *m = LoadParams{} }
func (m *LoadParams) String() string            { return proto.CompactTextString(m) }
func (*LoadParams) ProtoMessage()               {}
func (*LoadParams) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

type isLoadParams_Load interface {
	isLoadParams_Load()
}

type LoadParams_ClosedLoop struct {
	ClosedLoop *ClosedLoopParams `protobuf:"bytes,1,opt,name=closed_loop,json=closedLoop,oneof"`
}
type LoadParams_Poisson struct {
	Poisson *PoissonParams `protobuf:"bytes,2,opt,name=poisson,oneof"`
}

func (*LoadParams_ClosedLoop) isLoadParams_Load() {}
func (*LoadParams_Poisson) isLoadParams_Load()    {}

func (m *LoadParams) GetLoad() isLoadParams_Load {
	if m != nil {
		return m.Load
	}
	return nil
}

func (m *LoadParams) GetClosedLoop() *ClosedLoopParams {
	if x, ok := m.GetLoad().(*LoadParams_ClosedLoop); ok {
		return x.ClosedLoop
	}
	return nil
}

func (m *LoadParams) GetPoisson() *PoissonParams {
	if x, ok := m.GetLoad().(*LoadParams_Poisson); ok {
		return x.Poisson
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*LoadParams) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _LoadParams_OneofMarshaler, _LoadParams_OneofUnmarshaler, _LoadParams_OneofSizer, []interface{}{
		(*LoadParams_ClosedLoop)(nil),
		(*LoadParams_Poisson)(nil),
	}
}

func _LoadParams_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*LoadParams)
	// load
	switch x := m.Load.(type) {
	case *LoadParams_ClosedLoop:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ClosedLoop); err != nil {
			return err
		}
	case *LoadParams_Poisson:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Poisson); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("LoadParams.Load has unexpected type %T", x)
	}
	return nil
}

func _LoadParams_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*LoadParams)
	switch tag {
	case 1: // load.closed_loop
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ClosedLoopParams)
		err := b.DecodeMessage(msg)
		m.Load = &LoadParams_ClosedLoop{msg}
		return true, err
	case 2: // load.poisson
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(PoissonParams)
		err := b.DecodeMessage(msg)
		m.Load = &LoadParams_Poisson{msg}
		return true, err
	default:
		return false, nil
	}
}

func _LoadParams_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*LoadParams)
	// load
	switch x := m.Load.(type) {
	case *LoadParams_ClosedLoop:
		s := proto.Size(x.ClosedLoop)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *LoadParams_Poisson:
		s := proto.Size(x.Poisson)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// presence of SecurityParams implies use of TLS
type SecurityParams struct {
	UseTestCa          bool   `protobuf:"varint,1,opt,name=use_test_ca,json=useTestCa" json:"use_test_ca,omitempty"`
	ServerHostOverride string `protobuf:"bytes,2,opt,name=server_host_override,json=serverHostOverride" json:"server_host_override,omitempty"`
}

func (m *SecurityParams) Reset()                    { *m = SecurityParams{} }
func (m *SecurityParams) String() string            { return proto.CompactTextString(m) }
func (*SecurityParams) ProtoMessage()               {}
func (*SecurityParams) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

type ClientConfig struct {
	// List of targets to connect to. At least one target needs to be specified.
	ServerTargets  []string        `protobuf:"bytes,1,rep,name=server_targets,json=serverTargets" json:"server_targets,omitempty"`
	ClientType     ClientType      `protobuf:"varint,2,opt,name=client_type,json=clientType,enum=grpc.testing.ClientType" json:"client_type,omitempty"`
	SecurityParams *SecurityParams `protobuf:"bytes,3,opt,name=security_params,json=securityParams" json:"security_params,omitempty"`
	// How many concurrent RPCs to start for each channel.
	// For synchronous client, use a separate thread for each outstanding RPC.
	OutstandingRpcsPerChannel int32 `protobuf:"varint,4,opt,name=outstanding_rpcs_per_channel,json=outstandingRpcsPerChannel" json:"outstanding_rpcs_per_channel,omitempty"`
	// Number of independent client channels to create.
	// i-th channel will connect to server_target[i % server_targets.size()]
	ClientChannels int32 `protobuf:"varint,5,opt,name=client_channels,json=clientChannels" json:"client_channels,omitempty"`
	// Only for async client. Number of threads to use to start/manage RPCs.
	AsyncClientThreads int32   `protobuf:"varint,7,opt,name=async_client_threads,json=asyncClientThreads" json:"async_client_threads,omitempty"`
	RpcType            RpcType `protobuf:"varint,8,opt,name=rpc_type,json=rpcType,enum=grpc.testing.RpcType" json:"rpc_type,omitempty"`
	// The requested load for the entire client (aggregated over all the threads).
	LoadParams      *LoadParams      `protobuf:"bytes,10,opt,name=load_params,json=loadParams" json:"load_params,omitempty"`
	PayloadConfig   *PayloadConfig   `protobuf:"bytes,11,opt,name=payload_config,json=payloadConfig" json:"payload_config,omitempty"`
	HistogramParams *HistogramParams `protobuf:"bytes,12,opt,name=histogram_params,json=histogramParams" json:"histogram_params,omitempty"`
	// Specify the cores we should run the client on, if desired
	CoreList  []int32 `protobuf:"varint,13,rep,name=core_list,json=coreList" json:"core_list,omitempty"`
	CoreLimit int32   `protobuf:"varint,14,opt,name=core_limit,json=coreLimit" json:"core_limit,omitempty"`
	// If we use an OTHER_CLIENT client_type, this string gives more detail
	OtherClientApi string `protobuf:"bytes,15,opt,name=other_client_api,json=otherClientApi" json:"other_client_api,omitempty"`
}

func (m *ClientConfig) Reset()                    { *m = ClientConfig{} }
func (m *ClientConfig) String() string            { return proto.CompactTextString(m) }
func (*ClientConfig) ProtoMessage()               {}
func (*ClientConfig) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *ClientConfig) GetSecurityParams() *SecurityParams {
	if m != nil {
		return m.SecurityParams
	}
	return nil
}

func (m *ClientConfig) GetLoadParams() *LoadParams {
	if m != nil {
		return m.LoadParams
	}
	return nil
}

func (m *ClientConfig) GetPayloadConfig() *PayloadConfig {
	if m != nil {
		return m.PayloadConfig
	}
	return nil
}

func (m *ClientConfig) GetHistogramParams() *HistogramParams {
	if m != nil {
		return m.HistogramParams
	}
	return nil
}

type ClientStatus struct {
	Stats *ClientStats `protobuf:"bytes,1,opt,name=stats" json:"stats,omitempty"`
}

func (m *ClientStatus) Reset()                    { *m = ClientStatus{} }
func (m *ClientStatus) String() string            { return proto.CompactTextString(m) }
func (*ClientStatus) ProtoMessage()               {}
func (*ClientStatus) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *ClientStatus) GetStats() *ClientStats {
	if m != nil {
		return m.Stats
	}
	return nil
}

// Request current stats
type Mark struct {
	// if true, the stats will be reset after taking their snapshot.
	Reset_ bool `protobuf:"varint,1,opt,name=reset" json:"reset,omitempty"`
}

func (m *Mark) Reset()                    { *m = Mark{} }
func (m *Mark) String() string            { return proto.CompactTextString(m) }
func (*Mark) ProtoMessage()               {}
func (*Mark) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

type ClientArgs struct {
	// Types that are valid to be assigned to Argtype:
	//	*ClientArgs_Setup
	//	*ClientArgs_Mark
	Argtype isClientArgs_Argtype `protobuf_oneof:"argtype"`
}

func (m *ClientArgs) Reset()                    { *m = ClientArgs{} }
func (m *ClientArgs) String() string            { return proto.CompactTextString(m) }
func (*ClientArgs) ProtoMessage()               {}
func (*ClientArgs) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

type isClientArgs_Argtype interface {
	isClientArgs_Argtype()
}

type ClientArgs_Setup struct {
	Setup *ClientConfig `protobuf:"bytes,1,opt,name=setup,oneof"`
}
type ClientArgs_Mark struct {
	Mark *Mark `protobuf:"bytes,2,opt,name=mark,oneof"`
}

func (*ClientArgs_Setup) isClientArgs_Argtype() {}
func (*ClientArgs_Mark) isClientArgs_Argtype()  {}

func (m *ClientArgs) GetArgtype() isClientArgs_Argtype {
	if m != nil {
		return m.Argtype
	}
	return nil
}

func (m *ClientArgs) GetSetup() *ClientConfig {
	if x, ok := m.GetArgtype().(*ClientArgs_Setup); ok {
		return x.Setup
	}
	return nil
}

func (m *ClientArgs) GetMark() *Mark {
	if x, ok := m.GetArgtype().(*ClientArgs_Mark); ok {
		return x.Mark
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ClientArgs) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ClientArgs_OneofMarshaler, _ClientArgs_OneofUnmarshaler, _ClientArgs_OneofSizer, []interface{}{
		(*ClientArgs_Setup)(nil),
		(*ClientArgs_Mark)(nil),
	}
}

func _ClientArgs_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ClientArgs)
	// argtype
	switch x := m.Argtype.(type) {
	case *ClientArgs_Setup:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Setup); err != nil {
			return err
		}
	case *ClientArgs_Mark:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Mark); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("ClientArgs.Argtype has unexpected type %T", x)
	}
	return nil
}

func _ClientArgs_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ClientArgs)
	switch tag {
	case 1: // argtype.setup
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ClientConfig)
		err := b.DecodeMessage(msg)
		m.Argtype = &ClientArgs_Setup{msg}
		return true, err
	case 2: // argtype.mark
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Mark)
		err := b.DecodeMessage(msg)
		m.Argtype = &ClientArgs_Mark{msg}
		return true, err
	default:
		return false, nil
	}
}

func _ClientArgs_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ClientArgs)
	// argtype
	switch x := m.Argtype.(type) {
	case *ClientArgs_Setup:
		s := proto.Size(x.Setup)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ClientArgs_Mark:
		s := proto.Size(x.Mark)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type ServerConfig struct {
	ServerType     ServerType      `protobuf:"varint,1,opt,name=server_type,json=serverType,enum=grpc.testing.ServerType" json:"server_type,omitempty"`
	SecurityParams *SecurityParams `protobuf:"bytes,2,opt,name=security_params,json=securityParams" json:"security_params,omitempty"`
	// Port on which to listen. Zero means pick unused port.
	Port int32 `protobuf:"varint,4,opt,name=port" json:"port,omitempty"`
	// Only for async server. Number of threads used to serve the requests.
	AsyncServerThreads int32 `protobuf:"varint,7,opt,name=async_server_threads,json=asyncServerThreads" json:"async_server_threads,omitempty"`
	// Specify the number of cores to limit server to, if desired
	CoreLimit int32 `protobuf:"varint,8,opt,name=core_limit,json=coreLimit" json:"core_limit,omitempty"`
	// payload config, used in generic server
	PayloadConfig *PayloadConfig `protobuf:"bytes,9,opt,name=payload_config,json=payloadConfig" json:"payload_config,omitempty"`
	// Specify the cores we should run the server on, if desired
	CoreList []int32 `protobuf:"varint,10,rep,name=core_list,json=coreList" json:"core_list,omitempty"`
	// If we use an OTHER_SERVER client_type, this string gives more detail
	OtherServerApi string `protobuf:"bytes,11,opt,name=other_server_api,json=otherServerApi" json:"other_server_api,omitempty"`
}

func (m *ServerConfig) Reset()                    { *m = ServerConfig{} }
func (m *ServerConfig) String() string            { return proto.CompactTextString(m) }
func (*ServerConfig) ProtoMessage()               {}
func (*ServerConfig) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *ServerConfig) GetSecurityParams() *SecurityParams {
	if m != nil {
		return m.SecurityParams
	}
	return nil
}

func (m *ServerConfig) GetPayloadConfig() *PayloadConfig {
	if m != nil {
		return m.PayloadConfig
	}
	return nil
}

type ServerArgs struct {
	// Types that are valid to be assigned to Argtype:
	//	*ServerArgs_Setup
	//	*ServerArgs_Mark
	Argtype isServerArgs_Argtype `protobuf_oneof:"argtype"`
}

func (m *ServerArgs) Reset()                    { *m = ServerArgs{} }
func (m *ServerArgs) String() string            { return proto.CompactTextString(m) }
func (*ServerArgs) ProtoMessage()               {}
func (*ServerArgs) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

type isServerArgs_Argtype interface {
	isServerArgs_Argtype()
}

type ServerArgs_Setup struct {
	Setup *ServerConfig `protobuf:"bytes,1,opt,name=setup,oneof"`
}
type ServerArgs_Mark struct {
	Mark *Mark `protobuf:"bytes,2,opt,name=mark,oneof"`
}

func (*ServerArgs_Setup) isServerArgs_Argtype() {}
func (*ServerArgs_Mark) isServerArgs_Argtype()  {}

func (m *ServerArgs) GetArgtype() isServerArgs_Argtype {
	if m != nil {
		return m.Argtype
	}
	return nil
}

func (m *ServerArgs) GetSetup() *ServerConfig {
	if x, ok := m.GetArgtype().(*ServerArgs_Setup); ok {
		return x.Setup
	}
	return nil
}

func (m *ServerArgs) GetMark() *Mark {
	if x, ok := m.GetArgtype().(*ServerArgs_Mark); ok {
		return x.Mark
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ServerArgs) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ServerArgs_OneofMarshaler, _ServerArgs_OneofUnmarshaler, _ServerArgs_OneofSizer, []interface{}{
		(*ServerArgs_Setup)(nil),
		(*ServerArgs_Mark)(nil),
	}
}

func _ServerArgs_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ServerArgs)
	// argtype
	switch x := m.Argtype.(type) {
	case *ServerArgs_Setup:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Setup); err != nil {
			return err
		}
	case *ServerArgs_Mark:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Mark); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("ServerArgs.Argtype has unexpected type %T", x)
	}
	return nil
}

func _ServerArgs_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ServerArgs)
	switch tag {
	case 1: // argtype.setup
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ServerConfig)
		err := b.DecodeMessage(msg)
		m.Argtype = &ServerArgs_Setup{msg}
		return true, err
	case 2: // argtype.mark
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Mark)
		err := b.DecodeMessage(msg)
		m.Argtype = &ServerArgs_Mark{msg}
		return true, err
	default:
		return false, nil
	}
}

func _ServerArgs_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ServerArgs)
	// argtype
	switch x := m.Argtype.(type) {
	case *ServerArgs_Setup:
		s := proto.Size(x.Setup)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ServerArgs_Mark:
		s := proto.Size(x.Mark)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type ServerStatus struct {
	Stats *ServerStats `protobuf:"bytes,1,opt,name=stats" json:"stats,omitempty"`
	// the port bound by the server
	Port int32 `protobuf:"varint,2,opt,name=port" json:"port,omitempty"`
	// Number of cores available to the server
	Cores int32 `protobuf:"varint,3,opt,name=cores" json:"cores,omitempty"`
}

func (m *ServerStatus) Reset()                    { *m = ServerStatus{} }
func (m *ServerStatus) String() string            { return proto.CompactTextString(m) }
func (*ServerStatus) ProtoMessage()               {}
func (*ServerStatus) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *ServerStatus) GetStats() *ServerStats {
	if m != nil {
		return m.Stats
	}
	return nil
}

type CoreRequest struct {
}

func (m *CoreRequest) Reset()                    { *m = CoreRequest{} }
func (m *CoreRequest) String() string            { return proto.CompactTextString(m) }
func (*CoreRequest) ProtoMessage()               {}
func (*CoreRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

type CoreResponse struct {
	// Number of cores available on the server
	Cores int32 `protobuf:"varint,1,opt,name=cores" json:"cores,omitempty"`
}

func (m *CoreResponse) Reset()                    { *m = CoreResponse{} }
func (m *CoreResponse) String() string            { return proto.CompactTextString(m) }
func (*CoreResponse) ProtoMessage()               {}
func (*CoreResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

type Void struct {
}

func (m *Void) Reset()                    { *m = Void{} }
func (m *Void) String() string            { return proto.CompactTextString(m) }
func (*Void) ProtoMessage()               {}
func (*Void) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

// A single performance scenario: input to qps_json_driver
type Scenario struct {
	// Human readable name for this scenario
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// Client configuration
	ClientConfig *ClientConfig `protobuf:"bytes,2,opt,name=client_config,json=clientConfig" json:"client_config,omitempty"`
	// Number of clients to start for the test
	NumClients int32 `protobuf:"varint,3,opt,name=num_clients,json=numClients" json:"num_clients,omitempty"`
	// Server configuration
	ServerConfig *ServerConfig `protobuf:"bytes,4,opt,name=server_config,json=serverConfig" json:"server_config,omitempty"`
	// Number of servers to start for the test
	NumServers int32 `protobuf:"varint,5,opt,name=num_servers,json=numServers" json:"num_servers,omitempty"`
	// Warmup period, in seconds
	WarmupSeconds int32 `protobuf:"varint,6,opt,name=warmup_seconds,json=warmupSeconds" json:"warmup_seconds,omitempty"`
	// Benchmark time, in seconds
	BenchmarkSeconds int32 `protobuf:"varint,7,opt,name=benchmark_seconds,json=benchmarkSeconds" json:"benchmark_seconds,omitempty"`
	// Number of workers to spawn locally (usually zero)
	SpawnLocalWorkerCount int32 `protobuf:"varint,8,opt,name=spawn_local_worker_count,json=spawnLocalWorkerCount" json:"spawn_local_worker_count,omitempty"`
}

func (m *Scenario) Reset()                    { *m = Scenario{} }
func (m *Scenario) String() string            { return proto.CompactTextString(m) }
func (*Scenario) ProtoMessage()               {}
func (*Scenario) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func (m *Scenario) GetClientConfig() *ClientConfig {
	if m != nil {
		return m.ClientConfig
	}
	return nil
}

func (m *Scenario) GetServerConfig() *ServerConfig {
	if m != nil {
		return m.ServerConfig
	}
	return nil
}

// A set of scenarios to be run with qps_json_driver
type Scenarios struct {
	Scenarios []*Scenario `protobuf:"bytes,1,rep,name=scenarios" json:"scenarios,omitempty"`
}

func (m *Scenarios) Reset()                    { *m = Scenarios{} }
func (m *Scenarios) String() string            { return proto.CompactTextString(m) }
func (*Scenarios) ProtoMessage()               {}
func (*Scenarios) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

func (m *Scenarios) GetScenarios() []*Scenario {
	if m != nil {
		return m.Scenarios
	}
	return nil
}

// Basic summary that can be computed from ClientStats and ServerStats
// once the scenario has finished.
type ScenarioResultSummary struct {
	// Total number of operations per second over all clients.
	Qps float64 `protobuf:"fixed64,1,opt,name=qps" json:"qps,omitempty"`
	// QPS per one server core.
	QpsPerServerCore float64 `protobuf:"fixed64,2,opt,name=qps_per_server_core,json=qpsPerServerCore" json:"qps_per_server_core,omitempty"`
	// server load based on system_time (0.85 => 85%)
	ServerSystemTime float64 `protobuf:"fixed64,3,opt,name=server_system_time,json=serverSystemTime" json:"server_system_time,omitempty"`
	// server load based on user_time (0.85 => 85%)
	ServerUserTime float64 `protobuf:"fixed64,4,opt,name=server_user_time,json=serverUserTime" json:"server_user_time,omitempty"`
	// client load based on system_time (0.85 => 85%)
	ClientSystemTime float64 `protobuf:"fixed64,5,opt,name=client_system_time,json=clientSystemTime" json:"client_system_time,omitempty"`
	// client load based on user_time (0.85 => 85%)
	ClientUserTime float64 `protobuf:"fixed64,6,opt,name=client_user_time,json=clientUserTime" json:"client_user_time,omitempty"`
	// X% latency percentiles (in nanoseconds)
	Latency_50  float64 `protobuf:"fixed64,7,opt,name=latency_50,json=latency50" json:"latency_50,omitempty"`
	Latency_90  float64 `protobuf:"fixed64,8,opt,name=latency_90,json=latency90" json:"latency_90,omitempty"`
	Latency_95  float64 `protobuf:"fixed64,9,opt,name=latency_95,json=latency95" json:"latency_95,omitempty"`
	Latency_99  float64 `protobuf:"fixed64,10,opt,name=latency_99,json=latency99" json:"latency_99,omitempty"`
	Latency_999 float64 `protobuf:"fixed64,11,opt,name=latency_999,json=latency999" json:"latency_999,omitempty"`
}

func (m *ScenarioResultSummary) Reset()                    { *m = ScenarioResultSummary{} }
func (m *ScenarioResultSummary) String() string            { return proto.CompactTextString(m) }
func (*ScenarioResultSummary) ProtoMessage()               {}
func (*ScenarioResultSummary) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16} }

// Results of a single benchmark scenario.
type ScenarioResult struct {
	// Inputs used to run the scenario.
	Scenario *Scenario `protobuf:"bytes,1,opt,name=scenario" json:"scenario,omitempty"`
	// Histograms from all clients merged into one histogram.
	Latencies *HistogramData `protobuf:"bytes,2,opt,name=latencies" json:"latencies,omitempty"`
	// Client stats for each client
	ClientStats []*ClientStats `protobuf:"bytes,3,rep,name=client_stats,json=clientStats" json:"client_stats,omitempty"`
	// Server stats for each server
	ServerStats []*ServerStats `protobuf:"bytes,4,rep,name=server_stats,json=serverStats" json:"server_stats,omitempty"`
	// Number of cores available to each server
	ServerCores []int32 `protobuf:"varint,5,rep,name=server_cores,json=serverCores" json:"server_cores,omitempty"`
	// An after-the-fact computed summary
	Summary *ScenarioResultSummary `protobuf:"bytes,6,opt,name=summary" json:"summary,omitempty"`
}

func (m *ScenarioResult) Reset()                    { *m = ScenarioResult{} }
func (m *ScenarioResult) String() string            { return proto.CompactTextString(m) }
func (*ScenarioResult) ProtoMessage()               {}
func (*ScenarioResult) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{17} }

func (m *ScenarioResult) GetScenario() *Scenario {
	if m != nil {
		return m.Scenario
	}
	return nil
}

func (m *ScenarioResult) GetLatencies() *HistogramData {
	if m != nil {
		return m.Latencies
	}
	return nil
}

func (m *ScenarioResult) GetClientStats() []*ClientStats {
	if m != nil {
		return m.ClientStats
	}
	return nil
}

func (m *ScenarioResult) GetServerStats() []*ServerStats {
	if m != nil {
		return m.ServerStats
	}
	return nil
}

func (m *ScenarioResult) GetSummary() *ScenarioResultSummary {
	if m != nil {
		return m.Summary
	}
	return nil
}

func init() {
	proto.RegisterType((*PoissonParams)(nil), "grpc.testing.PoissonParams")
	proto.RegisterType((*ClosedLoopParams)(nil), "grpc.testing.ClosedLoopParams")
	proto.RegisterType((*LoadParams)(nil), "grpc.testing.LoadParams")
	proto.RegisterType((*SecurityParams)(nil), "grpc.testing.SecurityParams")
	proto.RegisterType((*ClientConfig)(nil), "grpc.testing.ClientConfig")
	proto.RegisterType((*ClientStatus)(nil), "grpc.testing.ClientStatus")
	proto.RegisterType((*Mark)(nil), "grpc.testing.Mark")
	proto.RegisterType((*ClientArgs)(nil), "grpc.testing.ClientArgs")
	proto.RegisterType((*ServerConfig)(nil), "grpc.testing.ServerConfig")
	proto.RegisterType((*ServerArgs)(nil), "grpc.testing.ServerArgs")
	proto.RegisterType((*ServerStatus)(nil), "grpc.testing.ServerStatus")
	proto.RegisterType((*CoreRequest)(nil), "grpc.testing.CoreRequest")
	proto.RegisterType((*CoreResponse)(nil), "grpc.testing.CoreResponse")
	proto.RegisterType((*Void)(nil), "grpc.testing.Void")
	proto.RegisterType((*Scenario)(nil), "grpc.testing.Scenario")
	proto.RegisterType((*Scenarios)(nil), "grpc.testing.Scenarios")
	proto.RegisterType((*ScenarioResultSummary)(nil), "grpc.testing.ScenarioResultSummary")
	proto.RegisterType((*ScenarioResult)(nil), "grpc.testing.ScenarioResult")
	proto.RegisterEnum("grpc.testing.ClientType", ClientType_name, ClientType_value)
	proto.RegisterEnum("grpc.testing.ServerType", ServerType_name, ServerType_value)
	proto.RegisterEnum("grpc.testing.RpcType", RpcType_name, RpcType_value)
}

var fileDescriptor0 = []byte{
	// 1346 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xa4, 0x57, 0x6d, 0x8f, 0xdb, 0xc4,
	0x13, 0xaf, 0xf3, 0x70, 0x97, 0x8c, 0x93, 0x5c, 0xfe, 0xfb, 0x6f, 0x91, 0xfb, 0x08, 0x75, 0x41,
	0x54, 0x05, 0x8e, 0x53, 0xe0, 0x54, 0x45, 0x02, 0x55, 0x69, 0x88, 0x7a, 0x95, 0xae, 0xd7, 0xd3,
	0x26, 0x2d, 0xaa, 0x78, 0x61, 0xb9, 0xbe, 0x6d, 0x62, 0x35, 0xb1, 0x5d, 0xaf, 0x4d, 0x95, 0x77,
	0x7c, 0x04, 0xbe, 0x04, 0xdf, 0x80, 0xaf, 0xc3, 0x67, 0xe0, 0x2b, 0x30, 0xfb, 0xe4, 0xd8, 0x21,
	0xa5, 0x3c, 0xbc, 0x8a, 0x77, 0xe6, 0x37, 0xb3, 0xb3, 0x33, 0xbf, 0x99, 0xdd, 0x40, 0x37, 0x88,
	0xa3, 0x2c, 0x8d, 0x97, 0x87, 0x49, 0x1a, 0x67, 0x31, 0xe9, 0xcc, 0xd3, 0x24, 0x38, 0xcc, 0x18,
	0xcf, 0xc2, 0x68, 0x7e, 0xad, 0x97, 0xf8, 0xeb, 0x65, 0xec, 0x5f, 0x70, 0xa5, 0xbd, 0x66, 0xf3,
	0xcc, 0xcf, 0xf4, 0xc2, 0x1d, 0x40, 0xf7, 0x3c, 0x0e, 0x39, 0x8f, 0xa3, 0x73, 0x3f, 0xf5, 0x57,
	0x9c, 0xdc, 0x86, 0x4e, 0xfc, 0xea, 0x15, 0x4b, 0xd9, 0x85, 0x27, 0x8c, 0x1c, 0xeb, 0x23, 0xeb,
	0xae, 0x45, 0x6d, 0x2d, 0x3b, 0x45, 0x91, 0x4b, 0xa0, 0x3f, 0x5e, 0xc6, 0x5c, 0xac, 0xe2, 0x44,
	0x99, 0xb9, 0x3f, 0x5b, 0x00, 0x42, 0xa9, 0xbd, 0x8c, 0xc0, 0x0e, 0x24, 0x04, 0x9d, 0xc4, 0x89,
	0x74, 0x62, 0x0f, 0x6e, 0x1d, 0x96, 0xe3, 0x3a, 0xdc, 0xf6, 0x71, 0x72, 0x89, 0x42, 0x50, 0xc8,
	0xc8, 0x7d, 0xd8, 0x4f, 0x54, 0x64, 0x4e, 0x4d, 0x9a, 0x5f, 0xaf, 0x9a, 0x57, 0xc2, 0x46, 0x5b,
	0x83, 0x7e, 0xb8, 0x07, 0x0d, 0x11, 0xb9, 0xfb, 0x12, 0x7a, 0x53, 0x16, 0xe4, 0x69, 0x98, 0xad,
	0x75, 0x54, 0xb7, 0xc0, 0xce, 0x39, 0xf3, 0x84, 0x07, 0x2f, 0xf0, 0x65, 0x54, 0x2d, 0xda, 0x46,
	0xd1, 0x0c, 0x25, 0x63, 0x9f, 0x1c, 0xc1, 0x65, 0xce, 0xd2, 0x1f, 0x59, 0xea, 0x2d, 0x62, 0x84,
	0xc4, 0xf8, 0x95, 0x86, 0x17, 0x4c, 0xee, 0xdf, 0xa6, 0x44, 0xe9, 0x4e, 0x50, 0xf5, 0x54, 0x6b,
	0xdc, 0x5f, 0x9b, 0xd0, 0x19, 0x2f, 0x43, 0x16, 0x65, 0xe3, 0x38, 0x7a, 0x15, 0xce, 0xc9, 0x27,
	0xd0, 0xd3, 0x2e, 0x32, 0x3f, 0x9d, 0xb3, 0x8c, 0xe3, 0x2e, 0x75, 0x34, 0xee, 0x2a, 0xe9, 0x4c,
	0x09, 0xc9, 0x50, 0xe4, 0x47, 0x98, 0x79, 0xd9, 0x3a, 0x51, 0x1b, 0xf4, 0x06, 0xce, 0x76, 0x7e,
	0x04, 0x60, 0x86, 0x7a, 0x91, 0x17, 0xf3, 0x4d, 0x26, 0x70, 0xc0, 0xf5, 0xb1, 0xbc, 0x44, 0x9e,
	0xcb, 0xa9, 0xcb, 0xfc, 0xdc, 0xa8, 0x9a, 0x57, 0xcf, 0x4e, 0x7b, 0xbc, 0x9a, 0x8b, 0x07, 0x70,
	0x23, 0xce, 0x33, 0xa4, 0x42, 0x74, 0x81, 0x68, 0x0f, 0x2d, 0xb9, 0x97, 0x60, 0xd8, 0xc1, 0xc2,
	0x8f, 0x22, 0xb6, 0x74, 0x1a, 0xe8, 0xb3, 0x49, 0xaf, 0x96, 0x30, 0x14, 0x21, 0xe7, 0x2c, 0x1d,
	0x2b, 0x00, 0xf9, 0x14, 0x0e, 0xf4, 0x11, 0xb4, 0x09, 0x77, 0x9a, 0xd2, 0xa6, 0xa7, 0xc4, 0x1a,
	0xc7, 0x45, 0x56, 0x7d, 0xbe, 0x8e, 0x02, 0xcf, 0x9c, 0x78, 0x91, 0x32, 0x64, 0xa3, 0xb3, 0x2f,
	0xd1, 0x44, 0xea, 0xf4, 0x59, 0x95, 0x06, 0x2d, 0x5a, 0x18, 0x8f, 0x4a, 0x4d, 0x4b, 0xa6, 0xe6,
	0x4a, 0xf5, 0x6c, 0x18, 0x8a, 0xcc, 0xcb, 0x7e, 0xaa, 0x3e, 0x44, 0x3e, 0x45, 0xcd, 0x4d, 0x42,
	0x40, 0x26, 0x64, 0x2b, 0x9f, 0x1b, 0x7a, 0x52, 0x58, 0x6e, 0xa8, 0xfa, 0x10, 0x4c, 0x83, 0x78,
	0x81, 0xac, 0xa1, 0x63, 0xef, 0xa4, 0x9b, 0xc2, 0xa8, 0x32, 0xd3, 0x6e, 0x52, 0x5e, 0x92, 0x13,
	0xe8, 0x2f, 0x42, 0x9e, 0xc5, 0x73, 0xf4, 0x68, 0x62, 0xe8, 0x48, 0x2f, 0x37, 0xab, 0x5e, 0x4e,
	0x0c, 0x4a, 0x07, 0x72, 0xb0, 0xa8, 0x0a, 0xc8, 0x75, 0x68, 0x07, 0x71, 0xca, 0xbc, 0x25, 0xca,
	0x9d, 0x2e, 0x52, 0xa7, 0x49, 0x5b, 0x42, 0x70, 0x8a, 0x6b, 0x72, 0x13, 0x40, 0x2b, 0x57, 0x61,
	0xe6, 0xf4, 0x64, 0xfe, 0xda, 0x4a, 0x8b, 0x02, 0x72, 0x17, 0xfa, 0x71, 0xb6, 0x10, 0x35, 0x54,
	0x89, 0xf6, 0x93, 0xd0, 0x39, 0x90, 0xd4, 0xed, 0x49, 0xb9, 0x4a, 0xf2, 0x28, 0x09, 0xdd, 0x07,
	0x86, 0xb5, 0x53, 0x1c, 0x05, 0x39, 0x27, 0x5f, 0x42, 0x53, 0x0e, 0x05, 0xdd, 0xa8, 0x57, 0x77,
	0x11, 0x51, 0x40, 0x39, 0x55, 0x38, 0xf7, 0x06, 0x34, 0x9e, 0xf8, 0xe9, 0x6b, 0x72, 0x19, 0x9a,
	0x29, 0xe3, 0x2c, 0xd3, 0xbd, 0xa4, 0x16, 0x6e, 0x0e, 0xa0, 0xf7, 0x4a, 0xe7, 0x9c, 0x0c, 0xd0,
	0x39, 0xcb, 0x72, 0x33, 0x05, 0xae, 0xed, 0x72, 0xae, 0xf2, 0x88, 0x5d, 0xac, 0xa0, 0x78, 0x94,
	0xc6, 0x0a, 0xfd, 0xeb, 0xce, 0x27, 0x55, 0x13, 0xb1, 0x33, 0x42, 0x25, 0xe2, 0x61, 0x1b, 0xf6,
	0xb1, 0xa7, 0x04, 0x55, 0xdc, 0x9f, 0xea, 0xd0, 0x99, 0xca, 0x36, 0xd3, 0x65, 0x41, 0x56, 0x98,
	0x66, 0x14, 0x54, 0xb2, 0x76, 0x75, 0x99, 0x32, 0x50, 0x5d, 0xc6, 0x8b, 0xef, 0x5d, 0x5d, 0x56,
	0xfb, 0x17, 0x5d, 0x46, 0xa0, 0x91, 0xc4, 0x69, 0xa6, 0xbb, 0x49, 0x7e, 0x6f, 0xfa, 0xc1, 0xc4,
	0xb6, 0xa3, 0x1f, 0x74, 0x54, 0xba, 0x1f, 0xaa, 0x75, 0x6f, 0x6d, 0xd7, 0xfd, 0xcf, 0x0c, 0x6e,
	0xff, 0x63, 0x06, 0x57, 0x78, 0x07, 0x5b, 0xbc, 0x2b, 0x88, 0xa5, 0x23, 0x16, 0xc4, 0xb2, 0x4b,
	0xc4, 0x52, 0xd1, 0x0a, 0x62, 0x61, 0xe5, 0xf5, 0xe2, 0xfd, 0x95, 0x2f, 0x97, 0xea, 0x3f, 0x56,
	0x3e, 0x34, 0x85, 0xff, 0x5b, 0x7c, 0xde, 0x40, 0x0d, 0x9f, 0x8b, 0x3a, 0xd5, 0x4a, 0x75, 0x42,
	0x6e, 0x8b, 0x0c, 0xa8, 0xf1, 0xda, 0xa4, 0x6a, 0xe1, 0x76, 0xc1, 0x1e, 0xe3, 0x07, 0x65, 0x6f,
	0x72, 0x74, 0xe7, 0x7e, 0x8c, 0x9d, 0x24, 0x97, 0x3c, 0x89, 0x23, 0xce, 0x36, 0x46, 0x56, 0xd9,
	0x08, 0xaf, 0xa4, 0xe7, 0x71, 0x78, 0xe1, 0xfe, 0x5e, 0x83, 0xd6, 0x34, 0x60, 0x91, 0x9f, 0x86,
	0xb1, 0xd8, 0x33, 0xf2, 0x57, 0x8a, 0x96, 0x6d, 0x2a, 0xbf, 0x71, 0x2a, 0x77, 0xcd, 0x50, 0x55,
	0x95, 0xac, 0xbd, 0xaf, 0x67, 0x68, 0x27, 0x28, 0xdf, 0x3f, 0x1f, 0x82, 0x1d, 0xe5, 0x2b, 0x3d,
	0x01, 0x4c, 0xe8, 0x80, 0x22, 0x65, 0x23, 0xe6, 0xbe, 0xbe, 0x8a, 0xcc, 0x0e, 0x8d, 0xf7, 0xd5,
	0x86, 0x76, 0x78, 0xb9, 0xa9, 0xf4, 0x0e, 0x4a, 0x66, 0x66, 0xbe, 0xd8, 0x41, 0xd9, 0x70, 0x71,
	0x05, 0xbe, 0xf5, 0xd3, 0x55, 0x9e, 0x20, 0x06, 0xf7, 0x40, 0x66, 0xef, 0x49, 0x4c, 0x57, 0x49,
	0xa7, 0x4a, 0x48, 0x3e, 0x83, 0xff, 0xbd, 0x64, 0x51, 0xb0, 0x10, 0xb5, 0x2c, 0x90, 0xaa, 0x07,
	0xfa, 0x85, 0xc2, 0x80, 0xef, 0x83, 0xc3, 0x13, 0xff, 0x6d, 0x84, 0xcf, 0x89, 0xc0, 0x5f, 0x7a,
	0x6f, 0xe3, 0xf4, 0xb5, 0x3c, 0x41, 0x1e, 0x99, 0x7e, 0xb8, 0x22, 0xf5, 0xa7, 0x42, 0xfd, 0xbd,
	0xd4, 0x8e, 0x85, 0xd2, 0x1d, 0x41, 0xdb, 0x24, 0x9c, 0x93, 0xaf, 0xa1, 0xcd, 0xcd, 0x42, 0xde,
	0xcb, 0xf6, 0xe0, 0x83, 0xad, 0x73, 0x6b, 0x35, 0xdd, 0x00, 0xdd, 0x5f, 0xea, 0x70, 0xa5, 0x90,
	0x33, 0x9e, 0x2f, 0xb3, 0x69, 0xbe, 0xc2, 0xe0, 0xd6, 0xa4, 0x0f, 0xf5, 0x37, 0x09, 0xd7, 0x4f,
	0x24, 0xf1, 0x49, 0xbe, 0x80, 0xff, 0xe3, 0x8f, 0xbc, 0x48, 0x8b, 0x2c, 0xa7, 0xea, 0x7e, 0xb7,
	0x68, 0x1f, 0x55, 0xe7, 0xa6, 0x5b, 0x04, 0x6b, 0xc8, 0xe7, 0xa0, 0x1f, 0x15, 0x1e, 0x5f, 0xf3,
	0x8c, 0xad, 0xbc, 0x2c, 0x44, 0x42, 0xd4, 0x15, 0x5a, 0x69, 0xa6, 0x52, 0x31, 0x43, 0xb9, 0x68,
	0x43, 0x8d, 0xc6, 0x27, 0x4b, 0xaa, 0xb0, 0x0d, 0x89, 0xd5, 0x6f, 0x8e, 0x67, 0xf8, 0x23, 0x91,
	0xe8, 0x57, 0xd3, 0xa8, 0xec, 0xb7, 0xa9, 0xfc, 0x2a, 0x4d, 0xd5, 0xaf, 0x46, 0x6f, 0xfc, 0xee,
	0x29, 0xbf, 0x4a, 0x5e, 0xf8, 0xc5, 0x41, 0xb4, 0xf4, 0x33, 0x2c, 0xce, 0xda, 0x3b, 0x3e, 0x92,
	0xc5, 0xb2, 0x68, 0x5b, 0x4b, 0x8e, 0x8f, 0xca, 0xea, 0xe1, 0x91, 0xac, 0xcb, 0x46, 0x3d, 0xac,
	0xaa, 0x8f, 0xe5, 0x8c, 0x2a, 0xa9, 0x8f, 0x2b, 0xea, 0xa1, 0xbc, 0xc2, 0x4b, 0xea, 0xa1, 0xe0,
	0xdd, 0x46, 0x3d, 0x94, 0xf3, 0xc7, 0xa2, 0x50, 0xe8, 0x87, 0xee, 0x6f, 0x35, 0x7c, 0xf0, 0x55,
	0xea, 0x84, 0x03, 0xa8, 0x65, 0xea, 0xa8, 0x47, 0xc1, 0xbb, 0xea, 0x5d, 0xe0, 0xf0, 0xd2, 0xd0,
	0x9b, 0x86, 0x8c, 0xef, 0x7e, 0x79, 0x16, 0x97, 0xf8, 0x77, 0x7e, 0xe6, 0xd3, 0x0d, 0x9a, 0x7c,
	0x03, 0x1d, 0x93, 0x76, 0x39, 0x7d, 0xea, 0x92, 0x62, 0x7f, 0x71, 0x9b, 0xea, 0x47, 0xa0, 0x5c,
	0x08, 0x6b, 0x43, 0x06, 0x69, 0xdd, 0xd8, 0x65, 0x5d, 0x9e, 0x5d, 0xfa, 0x72, 0x53, 0xd6, 0xb7,
	0x0b, 0x6b, 0x35, 0x7f, 0x9a, 0x72, 0x86, 0xdb, 0xbc, 0x20, 0x1b, 0x27, 0xdf, 0xc2, 0x3e, 0x57,
	0xcc, 0x95, 0xe5, 0xb5, 0x07, 0x77, 0xde, 0x91, 0x8c, 0x32, 0xc9, 0xa9, 0xb1, 0xb9, 0x37, 0x32,
	0xb7, 0xba, 0xbc, 0x20, 0x0f, 0xc0, 0x9e, 0xbe, 0x38, 0x1b, 0x7b, 0xe3, 0xd3, 0xc7, 0x93, 0xb3,
	0x59, 0xff, 0x12, 0x36, 0x43, 0x67, 0x54, 0x96, 0x58, 0x42, 0xf2, 0x74, 0x76, 0x32, 0xa1, 0x46,
	0x52, 0xbb, 0xf7, 0x83, 0xb9, 0x1e, 0x2a, 0x2e, 0xa6, 0x13, 0xfa, 0x7c, 0x42, 0xcb, 0x2e, 0xb4,
	0xc4, 0x22, 0x0e, 0x5c, 0x56, 0x92, 0x47, 0x93, 0xb3, 0x09, 0x7d, 0x5c, 0x68, 0x6a, 0x1b, 0xe7,
	0x5a, 0x52, 0xbf, 0x77, 0x07, 0xf6, 0xf5, 0xbb, 0x90, 0xb4, 0xa1, 0xf9, 0xec, 0x6c, 0x44, 0x5f,
	0xa0, 0xcf, 0x2e, 0x0e, 0x80, 0x19, 0x9d, 0x8c, 0x9e, 0x3c, 0x3e, 0x7b, 0xd4, 0xb7, 0x5e, 0xee,
	0xc9, 0xbf, 0x3d, 0x5f, 0xfd, 0x11, 0x00, 0x00, 0xff, 0xff, 0x6b, 0xe0, 0x6d, 0x97, 0x32, 0x0d,
	0x00, 0x00,
}
